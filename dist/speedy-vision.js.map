{"version":3,"file":"speedy-vision.js","mappings":";;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyD;AACgB;AACO;AACJ;AACA;AACC;AACA;AACJ;;AAEzE;AACA;AACA;AACO,0CAA0C,8DAAe;AAChE;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,iFAA2B;AAC9C;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,wFAA8B;AACjD;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,oFAA4B;AAC/C;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,oFAA4B;AAC/C;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,qFAA6B;AAChD;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,qFAA6B;AAChD;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,iFAA2B;AAC9C;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACxGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyD;AACc;AACJ;AACc;AACV;AACE;AACJ;AAC2C;;AAEhH;AACA;AACA;AACO,+CAA+C,8DAAe;AACrE;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,qFAAmC;AACtD;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,mFAAiC;AACpD;AACA;;AAEA;AACA;AACA;AACO,yCAAyC,8DAAe;AAC/D;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,+EAA6B;AAChD;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,2EAA2B;AAC9C;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,yFAAkC;AACrD;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,+EAA6B;AAChD;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,iFAA8B;AACjD;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,6EAA4B;AAC/C;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyD;AACoB;AAC0E;AACxE;AACa;AACf;AACF;AACM;AACM;AACA;AACC;AACG;AACI;AACF;AACR;AACa;AACZ;AACc;AACN;AACe;AACY;;AAEzH;AACA;AACA;AACA,oDAAoD,8DAAe;AACnE;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,oGAAsC;AACzD;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,wGAAwC;AAC3D;AACA;;AAEA;AACA;AACA;AACA,sDAAsD,8DAAe;AACrE;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,sGAAuC;AAC1D;AACA;;AAEA;AACA;AACA;AACA,mDAAmD,8DAAe;AAClE;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,8FAAmC;AACtD;AACA;;AAEA;AACA;AACA;AACA,mDAAmD,8DAAe;AAClE;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,2GAAiC;AACpD;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,+FAA+B;AAClD;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,6GAA8C;AACjE;AACA;;AAEA;AACA;AACA;AACO,kDAAkD,8DAAe;AACxE;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,4FAAsC;AACzD;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,0FAAoC;AACvD;AACA;;AAEA;AACA;AACA;AACO,4CAA4C,8DAAe;AAClE;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,qFAAgC;AACnD;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,iFAA8B;AACjD;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,wFAAqC;AACxD;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,wFAAqC;AACxD;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,uFAAiC;AACpD;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,oGAAuC;AAC1D;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,qFAAgC;AACnD;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,mFAA+B;AAClD;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,yFAAkC;AACrD;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,+FAAqC;AACxD;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,+FAAqC;AACxD;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,iGAAyC;AAC5D;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,uGAAwC;AAC3D;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,sHAA+C;AAClE;AACA;;;;;;;;;;;;;;;;;;;AChWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyD;AACgC;AACnB;;AAEtE;AACA;AACA;AACO,6CAA6C,8DAAe;AACnE;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,8EAAwB;AAC3C;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,iGAAiC;AACpD;AACA;;;;;;;;;;;;;;;;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEoD;AACkB;;AAEtE;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,yDAAa;AAChC;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,8EAA6B;AAChD;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyD;AAC0C;AAChC;AACZ;AACQ;AACb;AACF;AACM;AAC6B;AAClB;AACX;;AAEtD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO,4CAA4C,8DAAkB;AACrE;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,YAAY,gEAAS,WAAW,8EAA+B;AAC/D,YAAY,iEAAU,WAAW,8EAA+B;AAChE;;AAEA,mBAAmB,cAAc;AACjC,uBAAuB,gEAAmB,qCAAqC;AAC/E;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA,sBAAsB,4DAAiB;AACvC;AACA,sBAAsB,4DAAiB;;AAEvC;AACA;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B,iBAAiB;AACjB;AACA;AACA;AACA,gBAAgB,gBAAgB,aAAa,gCAAgC;AAC7E;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACvGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyD;AAC0C;AAChC;AACZ;AACL;AACK;AACP;AACa;AACI;;AAEjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,0BAA0B,yDAAa;;AAEvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,aAAa,QAAQ;AACrB,cAAc,UAAU;AACxB,cAAc,UAAU;AACxB;;AAEA;AACA;AACA;AACO,6CAA6C,8DAAkB;AACtE;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,YAAY,gEAAS,WAAW,8EAA+B;AAC/D,YAAY,iEAAU,WAAW,8EAA+B;AAChE;;AAEA,mBAAmB,YAAY;AAC/B,+BAA+B,oDAAU;;AAEzC,mBAAmB,eAAe;AAClC;;AAEA,mBAAmB,4BAA4B;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA,QAAQ,sDAAY,uBAAuB,oDAAU;;AAErD;AACA;AACA,sBAAsB,4DAAiB,6BAA6B,GAAG,GAAG,GAAG;;AAE7E;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,eAAe;AAC9B;AACA;AACA;AACA,QAAQ,sDAAY,kBAAkB,yDAAa;AACnD,QAAQ,sDAAY;;AAEpB;AACA;AACA;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B,iBAAiB;AACjB;AACA;AACA;AACA,gBAAgB,gBAAgB,aAAa,gCAAgC;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8DAAoB;;AAEjD;AACA;AACA;AACA,6BAA6B,8DAAoB;AACjD;AACA;;;;;;;;;;;;;;;;;;;;;;;ACvMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyD;AAC0C;AAChC;AACZ;AACQ;AACf;AACM;AACW;;AAEjE;AACA;AACA;AACO,0CAA0C,8DAAkB;AACnE;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,YAAY,gEAAS,WAAW,8EAA+B;AAC/D,YAAY,iEAAU,WAAW,8EAA+B;AAChE;AACA;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B,iBAAiB;AACjB;AACA;AACA;AACA,gBAAgB,gBAAgB,aAAa,gCAAgC;AAC7E;AACA;AACA;;AAEA;AACA;;AAEA,4CAA4C,0DAAgB;AAC5D;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyD;AAC0C;AAChC;AACZ;AACQ;AACb;AACF;AACM;AAC4B;AACjB;;AAEjE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO,2CAA2C,8DAAkB;AACpE;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,YAAY,gEAAS,WAAW,8EAA+B;AAC/D,6BAA6B,gCAAgC;AAC7D,mCAAmC,0DAAgB;AACnD;AACA,YAAY,iEAAU,WAAW,8EAA+B;AAChE;;AAEA,mBAAmB,YAAY;AAC/B,+BAA+B,oDAAU;AACzC;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA,QAAQ,sDAAY,uBAAuB,oDAAU;;AAErD;AACA;AACA,sBAAsB,4DAAiB;AACvC;AACA,sBAAsB,4DAAiB;;AAEvC;AACA;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B,iBAAiB;AACjB;AACA;AACA;AACA,gBAAgB,gBAAgB,aAAa,gCAAgC;AAC7E;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AC3GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyD;AAC0C;AAChC;AACZ;AACQ;AACf;AACgB;AACwB;AACvB;;AAEjE;AACA,aAAa,uBAAuB;AACpC;;AAEA;AACA;AACA;AACO,4CAA4C,8DAAkB;AACrE;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,YAAY,gEAAS,WAAW,8EAA+B;AAC/D,6BAA6B,gCAAgC;AAC7D,mCAAmC,0DAAgB;AACnD,mCAAmC,0DAAgB;AACnD;AACA,YAAY,iEAAU,WAAW,8EAA+B;AAChE;;AAEA,mBAAmB,QAAQ;AAC3B;;AAEA,mBAAmB,QAAQ;AAC3B;;AAEA,mBAAmB,QAAQ;AAC3B;;AAEA,mBAAmB,yBAAyB;AAC5C;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,yBAAyB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,+DAAoB,uDAAuD,QAAQ;AACzG;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B,iBAAiB;AACjB;AACA;AACA;AACA,gBAAgB,gBAAgB,aAAa,gCAAgC;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,0DAAgB;AACtC;AACA;AACA;AACA,2BAA2B,0DAAgB;AAC3C;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;AClMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyD;AAC0C;AAChC;AACZ;AAC+B;AACtC;AACwC;AACvB;;AAEjE;AACA;AACA;AACO,0CAA0C,8DAAkB;AACnE;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,YAAY,gEAAS,WAAW,8EAA+B;AAC/D,6BAA6B,gCAAgC;AAC7D,mCAAmC,0DAAgB;AACnD;AACA,YAAY,iEAAU,WAAW,8EAA+B;AAChE;;AAEA,mBAAmB,QAAQ;AAC3B;;AAEA,mBAAmB,QAAQ;AAC3B;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B,iBAAiB;AACjB;AACA;AACA;AACA,gBAAgB,gBAAgB,aAAa,gCAAgC;AAC7E;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oDAAoD,8DAAoB;AACxE;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,eAAe;AAC9B,eAAe,gBAAgB;AAC/B,iBAAiB,uBAAuB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAQ,sDAAY,CAAC,0DAAgB;;AAErC;AACA;AACA;AACA,2DAA2D,4DAAkB,EAAE,0DAAgB;AAC/F,uBAAuB,mBAAmB;AAC1C;;AAEA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AC5IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyD;AAC0C;AAChC;AACZ;AACQ;AACb;AACF;AACM;AAC4B;AACjB;;AAEjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,aAAa,QAAQ;AACrB,cAAc,UAAU;AACxB,cAAc,UAAU;AACxB;;AAEA;AACA;AACA;AACO,2CAA2C,8DAAkB;AACpE;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,YAAY,gEAAS,WAAW,8EAA+B;AAC/D,YAAY,iEAAU,WAAW,8EAA+B;AAChE;;AAEA,mBAAmB,YAAY;AAC/B,+BAA+B,oDAAU;;AAEzC,mBAAmB,4BAA4B;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA,QAAQ,sDAAY,uBAAuB,oDAAU;;AAErD;AACA;AACA,sBAAsB,4DAAiB,6BAA6B,GAAG,GAAG,GAAG;;AAE7E;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B,iBAAiB;AACjB;AACA;AACA;AACA,gBAAgB,gBAAgB,aAAa,gCAAgC;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACrJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyD;AAC0C;AAChC;AACb;AACC;AACQ;AACf;AACa;AACI;;;;AAIjE;AACA;AACA;AACA;AACO,4CAA4C,8DAAkB;AACrE;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,YAAY,gEAAS,WAAW,8EAA+B;AAC/D,YAAY,iEAAU,WAAW,8EAA+B;AAChE;;AAEA,mBAAmB,QAAQ;AAC3B;;AAEA,mBAAmB,SAAS;AAC5B;;AAEA,mBAAmB,aAAa;AAChC,+BAA+B,0DAAgB;;AAE/C,mBAAmB,SAAS;AAC5B;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B,iBAAiB;AACjB;AACA;AACA;AACA,gBAAgB,gBAAgB,aAAa,gCAAgC;AAC7E;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,4DAAiB,IAAI,eAAe;;AAE1D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACjIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyD;AAC0C;AAChC;AACZ;AACQ;AACf;AACM;AACW;AACJ;;AAE7D;AACA;AACA;AACO,2CAA2C,8DAAkB;AACpE;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,YAAY,gEAAS,gBAAgB,8EAA+B;AACpE,YAAY,gEAAS,gBAAgB,8EAA+B;AACpE,YAAY,iEAAU,WAAW,8EAA+B;AAChE;;AAEA,mBAAmB,QAAQ;AAC3B;;AAEA,mBAAmB,QAAQ;AAC3B;;AAEA,mBAAmB,QAAQ;AAC3B;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B,iBAAiB;AACjB;AACA;AACA;AACA,+BAA+B,gCAAgC;AAC/D,+BAA+B,gCAAgC;AAC/D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,4DAAiB;;AAEvC;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACxIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEmF;AACgB;AAChC;AACZ;AACQ;AACX;AACJ;AACgB;AACC;;AAEjE,WAAW,UAAU;AACrB;;AAEA;AACA;AACA;AACO,iDAAiD,8DAAkB;AAC1E;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,2CAA2C,gEAAS,mBAAmB,8EAA+B;AACtG,YAAY,iEAAU,WAAW,8EAA+B;AAChE;;AAEA,mBAAmB,QAAQ;AAC3B;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,sBAAsB,+DAAoB,kBAAkB,KAAK;;AAEjE;AACA;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACtFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEmF;AACgB;AAChC;AACb;AACC;AACQ;AACf;AAC0D;AACzC;;;;AAIjE;AACA;AACA;AACA;AACO,gDAAgD,8DAAkB;AACzE;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,YAAY,gEAAS,WAAW,8EAA+B;AAC/D;;AAEA,mBAAmB,aAAa;AAChC,uBAAuB,0DAAgB;;AAEvC,mBAAmB,SAAS;AAC5B;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,sBAAsB,gEAAqB,kBAAkB,eAAe;;AAE5E;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,sBAAsB,gEAAqB,kBAAkB,eAAe;;AAE5E;AACA;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;;AAEA,2CAA2C;AAC3C,uBAAuB,0DAAgB;;AAEvC;AACA;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B,iBAAiB;AACjB;AACA;AACA;AACA,gBAAgB,gBAAgB,aAAa,gCAAgC;AAC7E;;AAEA;AACA;AACA,sBAAsB,4DAAiB,IAAI,eAAe;;AAE1D;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACO,kDAAkD,oEAAwB;AACjF;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,YAAY,iEAAU,WAAW,8EAA+B;AAChE;;AAEA,mBAAmB,wCAAwC;AAC3D;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,wCAAwC;AACvD;AACA;AACA;AACA;AACA,sBAAsB,+DAAoB,4BAA4B,cAAc;;AAEpF;AACA;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B,iBAAiB;AACjB;AACA;AACA;AACA;AACA,sBAAsB,gEAAqB,IAAI,eAAe;;AAE9D;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACnLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyD;AAC0C;AAChC;AACZ;AACQ;AACf;AACe;AACT;AACW;;AAEjE;AACA,mBAAmB,8DAAkB,EAAE,MAAM;AAC7C,qCAAqC;;AAErC;AACA;AACA;AACO,6CAA6C,8DAAkB;AACtE;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,YAAY,gEAAS,WAAW,8EAA+B;AAC/D,YAAY,iEAAU,WAAW,8EAA+B;AAChE;AACA;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B,iBAAiB;AACjB;AACA;AACA;AACA,gBAAgB,gBAAgB,aAAa,gCAAgC;AAC7E;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kCAAkC,QAAQ;AAC1C;;AAEA;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,mBAAmB;AAC9C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;ACvHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEiF;AACkB;AAChC;AACZ;AACQ;AACX;AACa;AACjB;AACM;AACW;;AAEjE;AACA;AACA;AACO,0CAA0C,kEAAsB;AACvE;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,YAAY,gEAAS,WAAW,8EAA+B;AAC/D;;AAEA,mBAAmB,aAAa;AAChC;;AAEA,mBAAmB,aAAa;AAChC,uBAAuB,0DAAgB;AACvC;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,QAAQ,sDAAY;AACpB,eAAe,2DAAgB,iBAAiB,sBAAsB;AACtE;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B,iBAAiB;AACjB;AACA;AACA;AACA,gBAAgB,gBAAgB,aAAa,gCAAgC;;AAE7E,mBAAmB,gEAAa;AAChC;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEmF;AACgB;AAChC;AACZ;AACQ;AACX;AACJ;AACM;AACiC;AACtB;;AAEjE;AACA,8BAA8B;;AAE9B;AACA;AACA;AACO,4CAA4C,oEAAwB;AAC3E;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,YAAY,iEAAU,WAAW,8EAA+B;AAChE;;AAEA,mBAAmB,kBAAkB;AACrC;;AAEA,mBAAmB,QAAQ;AAC3B;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;AACA;AACA,gDAAgD,sDAAW;AAC3D,sBAAsB,+DAAoB,uBAAuB,MAAM;;AAEvE;AACA;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B,iBAAiB;AACjB;AACA;AACA;AACA;AACA,sBAAsB,gEAAqB,uCAAuC,cAAc;;AAEhG;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyD;AACiB;AAC6B;AACpC;AACZ;AACL;AACK;AACQ;AACf;AACiB;AACA;AACA;;;AAGjE;AACA;AACA;AACO,sDAAsD,8DAAkB;AAC/E;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,YAAY,gEAAS,WAAW,kFAAmC;AACnE,YAAY,iEAAU,WAAW,kFAAmC;AACpE;;AAEA,mBAAmB,YAAY;AAC/B,8BAA8B,oDAAU;;AAExC,mBAAmB,eAAe;AAClC,+BAA+B,yDAAa;AAC5C;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B,iBAAiB;AACjB;AACA;AACA;AACA,gBAAgB,6DAA6D,aAAa,oCAAoC;AAC9H;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,gEAAqB;;AAE3C;AACA,yBAAyB,mGAAkD;AAC3E;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uBAAuB,cAAc;AACrC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACxJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyD;AACiB;AAC6B;AACpC;AACZ;AACQ;AACf;AACiB;;;;AAIjE;AACA;AACA;AACA;AACO,+CAA+C,8DAAkB;AACxE;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,YAAY,gEAAS,WAAW,kFAAmC;AACnE,YAAY,iEAAU,WAAW,kFAAmC;AACpE;;AAEA,mBAAmB,QAAQ;AAC3B;;AAEA,mBAAmB,SAAS;AAC5B;;AAEA,mBAAmB,QAAQ;AAC3B;;AAEA,mBAAmB,QAAQ;AAC3B;;AAEA,mBAAmB,QAAQ;AAC3B;;AAEA,mBAAmB,SAAS;AAC5B;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B,iBAAiB;AACjB;AACA;AACA;AACA,gBAAgB,6DAA6D,aAAa,oCAAoC;AAC9H;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACtIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyD;AACiB;AAC6B;AACpC;AACZ;AACQ;AACf;AACiB;AACA;;;AAGjE;AACA;AACA,iBAAiB,gEAAoB;;;;AAIrC;AACA;AACA;AACO,gDAAgD,8DAAkB;AACzE;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,YAAY,gEAAS,WAAW,kFAAmC;AACnE,YAAY,iEAAU,WAAW,kFAAmC;AACpE;;AAEA,mBAAmB,QAAQ;AAC3B;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B,iBAAiB;AACjB;AACA;AACA;AACA,gBAAgB,6DAA6D,aAAa,oCAAoC;AAC9H;AACA;AACA;AACA;;AAEA;AACA,yBAAyB,mGAAkD;AAC3E;;AAEA;AACA,yCAAyC;AACzC,2DAA2D;AAC3D,qDAAqD;AACrD;;AAEA;AACA;AACA,iCAAiC,iGAAgD;;AAEjF;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,gBAAgB;AACvC,sCAAsC;AACtC,6CAA6C;AAC7C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACvIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE4D;AACc;AAChB;AAC+B;AACd;AACxB;;AAEnD;AACA;AACA;AACA;AACO,mDAAmD,8DAAkB;AAC5E;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,6BAA6B;AAC5C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,eAAe;AAC9B,iBAAiB,uBAAuB;AACxC;AACA;AACA;AACA,QAAQ,sDAAY;AACpB,QAAQ,sDAAY;;AAEpB;AACA,qCAAqC,mGAAkD;AACvF;AACA,oCAAoC,iGAAgD;;AAEpF;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE4D;AAC8E;AACpE;AACZ;AAC+B;AAChC;AACN;AACiB;AACO;AACP;;AAEpE;AACA,4BAA4B;;AAE5B;AACA;AACA;AACO,sDAAsD,6EAAoC;AACjG;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,YAAY,gEAAS,kBAAkB,8EAA+B;AACtE,6BAA6B,gCAAgC;AAC7D,mCAAmC,0DAAgB;AACnD;AACA,YAAY,gEAAS,sBAAsB,kFAAmC;AAC9E,YAAY,iEAAU,WAAW,kFAAmC;AACpE;AACA;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B,iBAAiB;AACjB;AACA;AACA;AACA,gBAAgB,6DAA6D,aAAa,oCAAoC;AAC9H,mCAAmC,gCAAgC;AACnE;AACA;;AAEA;AACA,yBAAyB,mGAAkD;AAC3E,sFAAsF;AACtF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AC1FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE4D;AAC8C;AAChC;AAChB;AAC+B;AACtC;AACiB;AACiE;;AAErI;AACA,qBAAqB,gEAAoB,EAAE;AAC3C,yBAAyB,oEAAwB,EAAE;AACnD,iDAAiD;AACjD;;AAEA;AACA,uCAAuC,KAAK;AAC5C,0BAA0B;AAC1B,mCAAmC;;AAEnC;AACA;AACA;AACA;AACO,iDAAiD,8DAAkB;AAC1E;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,6BAA6B;AAC5C;AACA;AACA;AACA;;AAEA,mBAAmB,QAAQ;AAC3B,2CAA2C;;AAE3C,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,yBAAyB;AAC5C;AACA;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,eAAe;AAC9B,eAAe,uBAAuB;AACtC,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,uBAAuB;AACxC;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF,0EAA0E;AAC1E,gEAAgE;AAChE;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,aAAa;AACpC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qFAAqF;AACrF;AACA,0CAA0C;;AAE1C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,6BAA6B,OAAO;AAC3D;AACA;AACA,mFAAmF;AACnF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,oBAAoB;AAC3C;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,uBAAuB;AACtC,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,uBAAuB;AACxC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,wBAAwB;AAC/C,iCAAiC,sEAAqB;AACtD;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA,uBAAuB,wBAAwB;AAC/C;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA,6CAA6C,6DAAiB;AAC9D;;AAEA,wBAAwB,8DAAkB;AAC1C;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA,6CAA6C,6DAAiB;AAC9D;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,6BAA6B;AAC5C;AACA;AACA;AACA;;AAEA,mBAAmB,QAAQ;AAC3B;;AAEA,mBAAmB,QAAQ;AAC3B;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AC5WA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE0E;AACgE;AACpE;AACZ;AACQ;AACT;AACN;AACiB;AACA;AACiB;;AAErF;AACA;;;;AAIA;AACA;AACA;AACO,qDAAqD,mFAA4C;AACxG;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,YAAY,gEAAS,WAAW,8EAA+B;AAC/D,6BAA6B,gCAAgC;AAC7D,mCAAmC,0DAAgB;AACnD;AACA,YAAY,iEAAU,WAAW,kFAAmC;AACpE;;AAEA,mBAAmB,QAAQ;AAC3B;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B,iBAAiB;AACjB;AACA;AACA;AACA,gBAAgB,gBAAgB,aAAa,gCAAgC;AAC7E;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,gEAAqB,0BAA0B,cAAc;;AAEnF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sDAAsD,8DAAkB;AACxE,iDAAiD,iBAAiB;AAClE;AACA,qEAAqE;AACrE;;AAEA;AACA,2CAA2C;AAC3C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;AC9IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE0E;AACgE;AACpE;AACZ;AACQ;AACT;AACJ;AACF;AACuC;AACtB;AACF;;AAElE;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACO,uDAAuD,mFAA4C;AAC1G;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,YAAY,gEAAS,WAAW,8EAA+B;AAC/D,6BAA6B,gCAAgC;AAC7D,mCAAmC,0DAAgB;AACnD;AACA,YAAY,iEAAU,WAAW,kFAAmC;AACpE;;AAEA,mBAAmB,YAAY;AAC/B,+BAA+B,oDAAU;;AAEzC,mBAAmB,QAAQ;AAC3B;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA,sBAAsB,+DAAoB,oBAAoB,WAAW;;AAEzE;AACA;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B,iBAAiB;AACjB;AACA;AACA;AACA,gBAAgB,gBAAgB,aAAa,gCAAgC;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,gEAAqB,0BAA0B,cAAc;;AAEnF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sDAAsD,+DAAkB;AACxE,iDAAiD,iBAAiB;AAClE,6BAA6B,8DAAoB;AACjD;AACA;AACA,mEAAmE;AACnE;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAuB,eAAe;AACtC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AClMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyD;AAC8C;AACpC;AACZ;AACQ;AACf;AACiB;AACX;AACiC;AACxB;;;AAG/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,uDAAuD,8DAAkB;AAChF;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,YAAY,gEAAS,eAAe,kFAAmC;AACvE,YAAY,gEAAS,sBAAsB,kFAAmC;AAC9E,YAAY,iEAAU,WAAW,kFAAmC;AACpE;;AAEA,mBAAmB,QAAQ;AAC3B,0BAA0B,8DAAkB;AAC5C;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B,iBAAiB;AACjB;AACA;AACA;AACA,gCAAgC,oCAAoC;AACpE,gCAAgC,oCAAoC;AACpE;;AAEA;AACA;AACA,sBAAsB,gEAAqB;;AAE3C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AC3GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyD;AAC8C;AACpC;AACZ;AACQ;AACf;AACiB;AACX;AACoD;AAC1C;;AAEhE,WAAW,uBAAuB;AAClC;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,8DAA8D,8DAAkB;AACvF;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,YAAY,gEAAS,eAAe,kFAAmC;AACvE,6BAA6B,oCAAoC;AACjE;AACA;AACA,YAAY,gEAAS,sBAAsB,kFAAmC;AAC9E,6BAA6B,oCAAoC;AACjE;AACA;AACA,YAAY,iEAAU,WAAW,kFAAmC;AACpE;;AAEA,mBAAmB,QAAQ;AAC3B,0BAA0B,+DAAmB,MAAM;AACnD;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B,iBAAiB;AACjB;AACA;AACA;AACA,gCAAgC,oCAAoC;AACpE,gCAAgC,oCAAoC;AACpE;;AAEA;AACA;AACA,sBAAsB,gEAAqB;;AAE3C;AACA;AACA,sBAAsB,4DAAiB,uDAAuD,oBAAoB;;AAElH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AC5HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE4D;AAC8C;AACpC;AACK;AACjB;AAC+B;AACtC;AACmC;AAClB;;AAEpE,WAAW,uBAAuB;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO,6DAA6D,8DAAkB;AACtF;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,YAAY,gEAAS,sBAAsB,kFAAmC;AAC9E,6BAA6B,oCAAoC;AACjE;AACA;AACA,YAAY,gEAAS,qBAAqB,kFAAmC;AAC7E,6BAA6B,oCAAoC;AACjE;AACA;AACA,YAAY,iEAAU,WAAW,wFAAyC;AAC1E;;AAEA,mBAAmB,QAAQ;AAC3B;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B,iBAAiB;AACjB;AACA;AACA;AACA,gBAAgB,6DAA6D,aAAa,oCAAoC;AAC9H,oCAAoC,oCAAoC;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,+DAAoB,gCAAgC,cAAc;AACxF;AACA,sBAAsB,4DAAiB,iCAAiC,eAAe,OAAO,cAAc;;AAE5G;AACA;AACA,yBAAyB,mGAAkD;AAC3E,2BAA2B,mGAAkD;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sDAAsD;AACtD;AACA,uBAAuB,wBAAwB;AAC/C,6EAA6E;;AAE7E;AACA,gCAAgC,yBAAyB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;ACtJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE4D;AACkF;AACxE;AACK;AACjB;AAC4D;AAC7B;AACtC;AACgB;AACC;;AAEpE,cAAc,qCAAqC;;AAEnD,WAAW,QAAQ;AACnB;;AAEA,WAAW,oBAAoB;AAC/B;;AAEA,aAAa,uCAAuC;AACpD;AACA;AACA;AACA;AACA;;AAEA,WAAW,QAAQ;AACnB,uBAAuB,mFAAsC,iCAAiC;AAC9F,iBAAiB,6EAAgC,iCAAiC;AAClF,oEAAoE;AACpE,0BAA0B,EAAE,GAAG,EAAE,IAAI,EAAE;AACvC;AACA;AACA;;;;AAIA;AACA;AACA;AACO,8CAA8C,8DAAkB;AACvE;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,YAAY,gEAAS,sBAAsB,kFAAmC;AAC9E,6BAA6B,oCAAoC;AACjE;AACA;AACA,YAAY,gEAAS,gBAAgB,kFAAmC;AACxE,YAAY,iEAAU,WAAW,wFAAyC;AAC1E;;AAEA,mBAAmB,QAAQ;AAC3B;;AAEA,mBAAmB,oBAAoB;AACvC;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;AACA,sBAAsB,+DAAoB,4BAA4B,QAAQ;;AAE9E;AACA;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B,iBAAiB;AACjB;AACA;AACA;AACA,gBAAgB,6DAA6D,aAAa,oCAAoC;AAC9H,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,+DAAoB,kDAAkD,cAAc;;AAE1G,QAAQ,sDAAY;AACpB,QAAQ,sDAAY;AACpB,QAAQ,sDAAY;;AAEpB;AACA,yBAAyB,mGAAkD;AAC3E;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,wBAAwB;AAC/C;AACA;AACA,oCAAoC,yBAAyB;AAC7D;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;AChNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEsF;AACoB;AACpC;AACT;AACqB;AACxB;AAC+B;AACC;AACvC;AACiB;AAK7B;;;;AAIvC;AACA;AACA;AACO,gDAAgD,oEAAwB;AAC/E;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,YAAY,iEAAU,WAAW,kFAAmC;AACpE;;AAEA,mBAAmB,kBAAkB;AACrC;;AAEA,mBAAmB,kBAAkB;AACrC;;AAEA,mBAAmB,QAAQ;AAC3B,+BAA+B,0EAA4B;;AAE3D,mBAAmB,QAAQ;AAC3B,yBAAyB,mEAAqB;;AAE9C,mBAAmB,gBAAgB;AACnC;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;AACA;AACA,yFAAyF,4DAAc;AACvG,sBAAsB,+DAAoB;;AAE1C;AACA,yCAAyC;AACzC,sDAAsD;AACtD,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA,YAAY,sFAAwC;AACpD,sBAAsB,+DAAoB,8BAA8B,EAAE,uBAAuB,kFAAoC,OAAO;;AAE5I;AACA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA,YAAY,gFAAkC;AAC9C,sBAAsB,+DAAoB,uBAAuB,EAAE,uBAAuB,4EAA8B,OAAO;;AAE/H;AACA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,gEAAqB;;AAE3C;AACA;AACA;;AAEA,mBAAmB,uDAAS;AAC5B;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACpLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyD;AACiB;AAC6B;AACpC;AACZ;AACQ;AACf;AACiB;AACA;AACA;;AAEjE;AACA;AACA;AACO,8CAA8C,8DAAkB;AACvE;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,YAAY,gEAAS,gBAAgB,kFAAmC;AACxE,YAAY,gEAAS,gBAAgB,kFAAmC;AACxE,YAAY,iEAAU,WAAW,kFAAmC;AACpE;AACA;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B,iBAAiB;AACjB;AACA;AACA;AACA,gCAAgC,oCAAoC;AACpE,gCAAgC,oCAAoC;AACpE;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,gEAAqB;;AAE3C;AACA,qBAAqB,mGAAkD;AACvE,qBAAqB,mGAAkD;AACvE;;AAEA;AACA,8BAA8B,iGAAgD;AAC9E;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB,cAAc;AACrC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AChHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEmF;AAChB;AACA;AACZ;AACQ;AACX;AACJ;AACgB;AACC;;AAEjE,WAAW,UAAU;AACrB;;AAEA;AACA;AACA;AACO,oDAAoD,8DAAkB;AAC7E;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,2CAA2C,gEAAS,mBAAmB,kFAAmC;AAC1G,YAAY,iEAAU,WAAW,kFAAmC;AACpE;;AAEA,mBAAmB,QAAQ;AAC3B;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,sBAAsB,+DAAoB,kBAAkB,KAAK;;AAEjE;AACA;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACtFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEmF;AACoB;AAC7B;AACP;AACZ;AACQ;AACf;AACuC;AACtB;;;;AAIjE;AACA;AACA;AACA;AACO,mDAAmD,8DAAkB;AAC5E;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,YAAY,gEAAS,WAAW,kFAAmC;AACnE;;AAEA,mBAAmB,QAAQ;AAC3B;;AAEA,mBAAmB,QAAQ;AAC3B;;AAEA,mBAAmB,QAAQ;AAC3B;;AAEA,mBAAmB,SAAS;AAC5B;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,sBAAsB,gEAAqB,kBAAkB,eAAe;;AAE5E;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,sBAAsB,gEAAqB,kBAAkB,eAAe;;AAE5E;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,sBAAsB,gEAAqB,kBAAkB,eAAe;;AAE5E;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,sBAAsB,gEAAqB,kBAAkB,eAAe;;AAE5E;AACA;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;;AAEA,8BAA8B,iGAAgD;AAC9E,iFAAiF;AACjF;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B,iBAAiB;AACjB;AACA;AACA;AACA,gBAAgB,6DAA6D,aAAa,oCAAoC;AAC9H;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACO,qDAAqD,oEAAwB;AACpF;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,YAAY,iEAAU,WAAW,kFAAmC;AACpE;;AAEA,mBAAmB,2CAA2C;AAC9D;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,2CAA2C;AAC1D;AACA;AACA;AACA;AACA,sBAAsB,+DAAoB,4BAA4B,cAAc;;AAEpF;AACA;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B,iBAAiB;AACjB;AACA;AACA;AACA;AACA,sBAAsB,gEAAqB,IAAI,eAAe;;AAE9D;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACjNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyD;AACiB;AAC6B;AACpC;AACZ;AACP;AACiB;;;AAGjE;AACA;AACA;AACO,iDAAiD,8DAAkB;AAC1E;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,YAAY,gEAAS,WAAW,kFAAmC;AACnE,YAAY,iEAAU,WAAW,kFAAmC;AACpE;;AAEA,mBAAmB,QAAQ;AAC3B;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B,iBAAiB;AACjB;AACA;AACA;AACA,cAAc,6DAA6D,aAAa,oCAAoC;AAC5H,yBAAyB,mGAAkD;AAC3E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB,cAAc;AACrC;;AAEA;AACA;AACA;;AAEA;AACA;AACA,qCAAqC,iGAAgD;AACrF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qCAAqC,iBAAiB;AACtD,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA,kBAAkB,uDAAa,CAAC,qDAAW;;AAE3C,8BAA8B,OAAO;AACrC;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA;;AAEA,sBAAsB;AACtB;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEiF;AACP;AAC2G;AAClH;AACZ;AACqB;AACU;AAClC;AACJ;AACM;AACsD;AAC3C;AACuC;AACzB;AACV;AACd;AAMpB;;AAEnC;AACA;;AAEA;AACA;;;AAGA;AACA;AACA,cAAc,gBAAgB;AAC9B;AACA;AACA,qDAAqD,kEAAsB;AAC3E;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,6BAA6B;AAC5C;AACA;AACA;AACA;;AAEA,mBAAmB,eAAe;AAClC;;AAEA,mBAAmB,qBAAqB;AACxC,kCAAkC,2EAAmB;;AAErD,mBAAmB,QAAQ;AAC3B;;AAEA,mBAAmB,SAAS;AAC5B;;AAEA,mBAAmB,SAAS;AAC5B;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA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A;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEmF;AACT;AAC6B;AAC/C;AACD;AACQ;AACf;AACgB;AACC;AACP;AACiC;;AAE3F;AACA,6BAA6B;AAC7B,0BAA0B;AAC1B,wDAAwD;;AAExD;AACA;AACA;AACO,+CAA+C,oEAAwB;AAC9E;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,YAAY,iEAAU,WAAW,kFAAmC;AACpE;;AAEA,mBAAmB,kBAAkB;AACrC;;AAEA,mBAAmB,cAAc;AACjC;;AAEA,mBAAmB,QAAQ;AAC3B,yBAAyB,qEAAwB;AACjD;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA,sBAAsB,+DAAoB;;AAE1C;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA,6DAA6D,iEAAoB;AACjF;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,iGAAgD,2CAA2C;;AAEzH;;AAEA;AACA,uBAAuB,eAAe;AACtC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA,QAAQ,sDAAY;;AAEpB;AACA;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,kBAAkB;AACjC,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AClLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyD;AACiB;AAC6D;AACpE;AACZ;AACQ;AACT;AACN;AACgB;AACC;;AAEjE,cAAc,iEAAiE;;AAE/E,YAAY,yCAAyC;AACrD;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACO,wDAAwD,8DAAkB;AACjF;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,YAAY,gEAAS,kBAAkB,8EAA+B;AACtE,6BAA6B,gCAAgC;AAC7D,mCAAmC,0DAAgB;AACnD;AACA,YAAY,gEAAS,sBAAsB,kFAAmC;AAC9E,YAAY,iEAAU,WAAW,kFAAmC;AACpE,YAAY,iEAAU,0BAA0B,gFAAiC;AACjF;;AAEA,mBAAmB,0BAA0B;AAC7C;;AAEA,mBAAmB,QAAQ;AAC3B;;AAEA,mBAAmB,QAAQ;AAC3B;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,0BAA0B;AACzC;AACA;AACA;AACA;AACA,sBAAsB,+DAAoB,qBAAqB,KAAK;;AAEpE;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B,iBAAiB;AACjB;AACA;AACA;AACA,gBAAgB,6DAA6D,aAAa,oCAAoC;AAC9H,gBAAgB,gBAAgB,aAAa,gCAAgC;AAC7E;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,yBAAyB,mGAAkD;AAC3E,iFAAiF;AACjF;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE4D;AACe;AAC+D;AACpE;AACZ;AACQ;AACT;AACJ;AACF;AACoC;AACnB;AACiB;;AAErF;AACA,gCAAgC,oDAAU,UAAU;AACpD,kCAAkC,+DAAkB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACO,kDAAkD,8DAAkB;AAC3E;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,YAAY,gEAAS,0BAA0B,8EAA+B;AAC9E,6BAA6B,gCAAgC;AAC7D,mCAAmC,0DAAgB;AACnD;AACA,YAAY,gEAAS,sBAAsB,8EAA+B;AAC1E,6BAA6B,gCAAgC;AAC7D,mCAAmC,0DAAgB;AACnD;AACA,YAAY,gEAAS,8BAA8B,kFAAmC;AACtF,YAAY,iEAAU,WAAW,kFAAmC;AACpE,YAAY,iEAAU,iBAAiB,gFAAiC;AACxE;;AAEA,mBAAmB,YAAY;AAC/B;;AAEA,mBAAmB,QAAQ;AAC3B;;AAEA,mBAAmB,QAAQ;AAC3B;;AAEA,mBAAmB,QAAQ;AAC3B;;AAEA,mBAAmB,QAAQ;AAC3B;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA,sBAAsB,4DAAiB,eAAe,6BAA6B;AACnF;AACA;AACA;AACA,sBAAsB,4DAAiB,uBAAuB,6BAA6B,qCAAqC,kBAAkB;AAClJ;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA,QAAQ,sDAAY,0BAA0B,+DAAkB;AAChE;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA,QAAQ,sDAAY;AACpB;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA,QAAQ,sDAAY;AACpB;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA,QAAQ,sDAAY;AACpB;AACA;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B,iBAAiB;AACjB;AACA;AACA;AACA,gBAAgB,6DAA6D,aAAa,oCAAoC;AAC9H,2CAA2C,gCAAgC;AAC3E,uCAAuC,gCAAgC;AACvE;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,gEAAqB;AAC3C;AACA,sBAAsB,gEAAqB;;AAE3C;AACA;;AAEA;AACA,6BAA6B,mGAAkD;AAC/E;AACA;;AAEA;AACA;AACA,kCAAkC,UAAU;AAC5C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACpPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyD;AAC8C;AACpC;AACZ;AACQ;AACf;AACiB;AACX;AACU;;;AAGhE;AACA;AACA;AACO,oDAAoD,8DAAkB;AAC7E;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,YAAY,gEAAS,WAAW,kFAAmC;AACnE,YAAY,iEAAU,WAAW,kFAAmC;AACpE;;AAEA,mBAAmB,cAAc;AACjC,0BAA0B,+DAAmB,qCAAqC;AAClF;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA,sBAAsB,+DAAoB,qCAAqC,UAAU;;AAEzF;AACA;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B,iBAAiB;AACjB;AACA;AACA;AACA,gBAAgB,6DAA6D,aAAa,oCAAoC;AAC9H;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AC5FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyD;AAC0C;AAChC;AACZ;AACQ;AACf;AACwC;AACvB;AACD;AACV;;AAEtD;AACA;;AAEA;AACA;AACA;AACO,gDAAgD,8DAAkB;AACzE;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,YAAY,gEAAS,WAAW,8EAA+B;AAC/D,YAAY,iEAAU,WAAW,8EAA+B;AAChE;;AAEA,mBAAmB,cAAc;AACjC,0BAA0B,+DAAmB,qCAAqC;AAClF;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA,sBAAsB,+DAAoB,qCAAqC,UAAU;;AAEzF;AACA;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B,iBAAiB;AACjB;AACA;AACA;AACA,gBAAgB,gBAAgB,aAAa,gCAAgC;AAC7E;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,QAAQ;AACvB,iBAAiB,UAAU;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0CAA0C;AAC1C,0CAA0C;AAC1C,0CAA0C;;AAE1C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;AC9IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyD;AAC0C;AAChC;AACZ;AACQ;AACf;AACgB;AACV;AACJ;AACK;AACU;;AAEjE,cAAc,sBAAsB;;AAEpC;AACA;AACA;AACO,uCAAuC,8DAAkB;AAChE;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,YAAY,gEAAS,WAAW,8EAA+B;AAC/D,YAAY,iEAAU,WAAW,8EAA+B;AAChE;;AAEA,mBAAmB,YAAY;AAC/B,yBAAyB,oDAAU;;AAEnC,mBAAmB,eAAe;AAClC,0BAA0B,yDAAa;;AAEvC,mBAAmB,gCAAgC;AACnD;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,gCAAgC;AAC/C;AACA;AACA;AACA;AACA,sBAAsB,+DAAoB,4BAA4B,OAAO;;AAE7E;AACA;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B,iBAAiB;AACjB;AACA;AACA;AACA,gBAAgB,gBAAgB,aAAa,gCAAgC;AAC7E;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACjJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEiF;AACsB;AACpC;AACZ;AACqB;AACb;AACf;AACiB;AACV;;AAEvD;AACA;;;AAGA;AACA;AACA;AACO,4CAA4C,kEAAsB;AACzE;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,YAAY,gEAAS,WAAW,gFAAiC;AACjE;;AAEA,mBAAmB,iBAAiB;AACpC;;AAEA,mBAAmB,qBAAqB;AACxC,kCAAkC,2EAAmB;;AAErD,mBAAmB,QAAQ;AAC3B;;AAEA,mBAAmB,SAAS;AAC5B;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,wEAAqB;AACpC;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B,iBAAiB;AACjB;AACA;AACA;AACA,gBAAgB,UAAU,aAAa,oCAAoC;AAC3E;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,uBAAuB,UAAU;AACjC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,gBAAgB,6DAAmB;AACnC,gBAAgB,6DAAmB;;AAEnC;AACA,6BAA6B,yDAAa;AAC1C;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE0C;AACM;AACS;AACuB;AAC/B;;AAEjD;AACA;AACA,UAAU;AACV;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,2BAA2B;AAC1C;AACA;AACA;AACA,mBAAmB,2BAA2B;AAC9C;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,2BAA2B;AAC1C,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA,kCAAkC,KAAK;AACvC;;AAEA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB,iBAAiB,uBAAuB;AACxC;AACA;AACA;AACA,kBAAkB,8DAAmB;AACrC;;AAEA;AACA;AACA,eAAe,2BAA2B;AAC1C,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,uBAAuB;AACxC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,uBAAuB;AAC1C;;AAEA,mBAAmB,aAAa;AAChC,uBAAuB,0DAAgB;AACvC;;AAEA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,aAAa;AAC5B,iBAAiB,uBAAuB;AACxC;AACA,wBAAwB,0DAAgB;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,uBAAuB;AAC1C;;AAEA,mBAAmB,QAAQ;AAC3B;;AAEA,mBAAmB,QAAQ;AAC3B;;AAEA,mBAAmB,QAAQ;AAC3B;AACA;;AAEA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,uBAAuB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAQ,sDAAY;AACpB,QAAQ,sDAAY;AACpB,QAAQ,sDAAY;;AAEpB;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,uBAAuB;AAC1C;AACA;;AAEA;AACA;AACA,eAAe,uBAAuB;AACtC,iBAAiB,uBAAuB;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,WAAW;AAC9B;AACA;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B,iBAAiB,uBAAuB;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,uBAAuB;AAC1C;;AAEA,mBAAmB,QAAQ;AAC3B;AACA;;AAEA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,QAAQ;AACvB,iBAAiB,uBAAuB;AACxC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAQ,sDAAY;;AAEpB;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA,WAAW,2BAA2B;AACtC,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,KAAK;AACxB;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;ACtcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE0C;AACU;AACO;AACoB;AACyB;AACrC;AAClB;AAC+B;AACV;;AAEtE,cAAc,wCAAwC;AACtD,cAAc,yCAAyC;;AAEvD;AACA;;AAEA;AACA,mDAAmD,qBAAqB;;AAExE;AACA,oDAAoD,sBAAsB;;AAE1E;AACA;AACA,WAAW,2BAA2B;AACtC,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,4BAA4B;AACvC,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;AAIA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,6BAA6B;AAC5C;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;;AAEA,mBAAmB,yBAAyB;AAC5C;;;;AAIA;AACA;AACA,sCAAsC,2BAA2B;AACjE,uCAAuC,4BAA4B;;AAEnE,mBAAmB,qBAAqB;AACxC;;AAEA,mBAAmB,sBAAsB;AACzC;;;;AAIA;AACA;AACA,sBAAsB,+DAAoB,kBAAkB,WAAW,aAAa,cAAc;AAClG;AACA,sBAAsB,+DAAoB,qCAAqC,cAAc;AAC7F;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,kBAAkB,sBAAsB,GAAG,UAAU;AACrD;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA,qBAAqB,gFAAoC;AACzD;AACA;AACA;;AAEA,kBAAkB,+DAAoB,0BAA0B,UAAU,UAAU,cAAc;AAClG;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA,sBAAsB,iFAAqC;AAC3D;AACA;AACA;;AAEA,kBAAkB,+DAAoB,2BAA2B,UAAU,UAAU,cAAc;AACnG;;AAEA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,sDAAY,8FAA8F,UAAU,KAAK,cAAc;;AAEvJ;AACA;AACA;AACA;AACA,gBAAgB,sDAAY,8FAA8F,UAAU,KAAK,cAAc;AACvJ,SAAS;AACT;;AAEA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,iBAAiB;AACjB;AACA;AACA;AACA,kBAAkB,8DAAmB;AACrC;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA,0CAA0C,QAAQ;AAClD;AACA;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,uBAAuB;AACtC,iBAAiB;AACjB;AACA;AACA;AACA,kCAAkC,2EAAmB;AACrD;AACA;AACA;;AAEA,uCAAuC;AACvC;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,uBAAuB;AACtC,iBAAiB;AACjB;AACA;AACA;AACA,QAAQ,sDAAY,CAAC,yDAAa,GAAG;AACrC;AACA;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,uBAAuB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,6BAA6B;AAC5C;AACA;AACA;AACA;AACA,QAAQ,sDAAY;AACpB;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,6BAA6B;AAC5C;AACA;AACA;AACA;AACA,QAAQ,sDAAY;AACpB;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,kBAAkB,8DAAmB;AACrC;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AC5YA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE0C;AAC+E;AAC5D;AACgC;AACxC;;AAErD;AACA;AACA;AACA;AACA,0BAA0B,+EAAgC;;AAE1D;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,wBAAwB;AACvC,eAAe,oBAAoB;AACnC;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;;AAEA,mBAAmB,wBAAwB;AAC3C;;AAEA,mBAAmB,oBAAoB;AACvC;;AAEA,mBAAmB,uBAAuB;AAC1C;;;AAGA;AACA,QAAQ,sDAAY,sDAAsD,WAAW;AACrF;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA;AACA;AACA,kBAAkB,8DAAmB;AACrC;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,kBAAkB,8DAAmB;AACrC;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AA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AAwB;AACjE;;;;;;;;;;;;;;;;;ACrHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEsF;AAC5C;;AAE1C;AACA;AACA,aAAa,0CAA0C;AACvD;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,2BAA2B;AAC1C,eAAe,iCAAiC;AAChD;AACA;AACA;AACA,mBAAmB,2BAA2B;AAC9C;;AAEA,mBAAmB,iCAAiC;AACpD;;;AAGA;AACA,QAAQ,sDAAY,8BAA8B,gFAAiC;AACnF;;AAEA;AACA;AACA,eAAe,wBAAwB;AACvC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,uBAAuB;AACtC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iCAAiC,wEAAyB;AAC1D,oBAAoB,wEAAyB;AAC7C;;AAEA,+BAA+B,MAAM,aAAa,qBAAqB;AACvE;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACnGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE0C;AACiB;AACyC;AACG;AACC;AACvD;AACH;AACM;;AAEpD;AACA;AACA,aAAa,oBAAoB;AACjC;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;;AAEA,mBAAmB,sBAAsB;AACzC;;AAEA,mBAAmB,WAAW;AAC9B;;AAEA,mBAAmB,SAAS;AAC5B;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,+CAA+C,OAAO;AACtD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,gBAAgB,uBAAuB;AACvC,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;AACA,sBAAsB,gEAAqB;AAC3C;AACA,sBAAsB,+DAAoB;;AAE1C;AACA,wBAAwB,sDAAS;;AAEjC;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,uBAAuB,2BAA2B;AAClD;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,sBAAsB,gEAAqB;;AAE3C;AACA,+CAA+C,QAAQ;AACvD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,qCAAqC;AACtD;AACA;AACA;AACA,QAAQ,sDAAY;;AAEpB;AACA;AACA;AACA,uBAAuB,gEAAa;AACpC;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iCAAiC,0BAA0B;;AAE3D;AACA;;AAEA;AACA;;AAEA;AACA,YAAY,oEAAiB;;AAE7B;AACA;;AAEA;;AAEA;;AAEA;AACA,mDAAmD,QAAQ;AAC3D;;AAEA;AACA;;AAEA,SAAS;AACT;;AAEA;AACA;AACA,eAAe,sBAAsB;AACrC,eAAe,WAAW;AAC1B,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,cAAc,OAAO;AACrB;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,eAAe,wEAAqB;AACpC;;AAEA;AACA;AACA,eAAe,sBAAsB;AACrC,iBAAiB;AACjB;AACA;AACA;AACA,sBAAsB,+BAA+B;;AAErD;AACA,mDAAmD,WAAW;AAC9D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mEAAmE,WAAW;;AAE9E;AACA,kCAAkC,gEAAqB;AACvD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,sBAAsB;AACrC,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA,uBAAuB,kBAAkB;AACzC;;AAEA,uBAAuB,kBAAkB;AACzC;AACA;;AAEA,2BAA2B,mBAAmB;AAC9C;AACA;;AAEA;AACA,8BAA8B,gEAAqB,iDAAiD,cAAc;;AAElH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,sBAAsB;AACrC,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA,sCAAsC,QAAQ;AAC9C;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,sBAAsB;AACrC;AACA;AACA;AACA;AACA,sBAAsB,gEAAqB;AAC3C;AACA,sBAAsB,gEAAqB;AAC3C;AACA,sBAAsB,gEAAqB;AAC3C;AACA;;;;;;;;;;;;;;;;AC3SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,2CAA2C,qBAAqB;AAChE;AACA;;;;;;;;;;;;;;;;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEsD;;AAEtD;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA,mCAAmC,8DAAkB;;AAErD,mBAAmB,QAAQ;AAC3B;;AAEA,mBAAmB,QAAQ;AAC3B;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,sCAAsC,WAAW,GAAG,cAAc;AAClE;AACA;;;;;;;;;;;;;;;;;;;;;AC5EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEwE;AACV;AAChB;AACE;;AAEhD;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,+BAA+B;AAC9C;AACA;AACA;AACA,mBAAmB,cAAc;AACjC,6BAA6B,uDAAY;;AAEzC,mBAAmB,QAAQ;AAC3B;;AAEA,mBAAmB,QAAQ;AAC3B;;AAEA,mBAAmB,QAAQ;AAC3B;;AAEA,mBAAmB,+BAA+B;AAClD;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iCAAiC,OAAO,GAAG,OAAO;AAClD;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,+BAA+B;AAC9C,eAAe,eAAe;AAC9B;AACA,4FAA4F,yDAAa;AACzG;AACA;;AAEA,mBAAmB,eAAe;AAClC;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,+BAA+B;AAC9C,eAAe,uBAAuB;AACtC;AACA;AACA;AACA;;AAEA,mBAAmB,uBAAuB;AAC1C;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC9NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEwD;AACjB;AACe;;AAEtD,cAAc,6CAA6C;AAC3D,cAAc,kDAAkD;AAChE,cAAc,6DAA6D;AAC3E,cAAc,uDAAuD;;AAErE,cAAc,6DAA6D;;AAE3E,YAAY,kBAAkB;AAC9B;AACA;AACA,CAAC;;;AAGD;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,mBAAmB;AAClC;AACA;AACA;AACA,QAAQ,sDAAY;AACpB,QAAQ,sDAAY,4CAA4C;;AAEhE,mBAAmB,QAAQ;AAC3B;;AAEA,mBAAmB,QAAQ;AAC3B;;AAEA,mBAAmB,mBAAmB;AACtC;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,kBAAkB;AACjC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,kBAAkB;AACjC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,yBAAyB;AACxC,iBAAiB;AAC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Q;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC,eAAe,kBAAkB;AACjC;AACA;AACA;AACA,QAAQ,sDAAY;AACpB;AACA;;AAEA;AACA;AACA,eAAe,sBAAsB;AACrC,eAAe,wBAAwB;AACvC,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC,eAAe,kBAAkB;AACjC;AACA;AACA;AACA,QAAQ,sDAAY;AACpB;AACA;;AAEA;AACA;AACA,eAAe,sBAAsB;AACrC,eAAe,wBAAwB;AACvC,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC,eAAe,kBAAkB;AACjC;AACA;AACA;AACA,QAAQ,sDAAY;AACpB;AACA;;AAEA;AACA;AACA,eAAe,sBAAsB;AACrC,eAAe,wBAAwB;AACvC,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC,eAAe,kBAAkB;AACjC;AACA;AACA;AACA,QAAQ,sDAAY;AACpB;AACA;;AAEA;AACA;AACA,eAAe,sBAAsB;AACrC,eAAe,wBAAwB;AACvC,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACpkBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEwD;AACA;AACT;AACS;AACjB;AACgB;;AAEvD;AACA;AACA;AACO;AACP;AACA;AACA;AA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A,gDAAgD,aAAa;AAC7D,8CAA8C,UAAU;AACxD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,6BAA6B;AAC9C;AACA;AACA;AACA;AACA,eAAe,wEAAqB;AACpC;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,4BAA4B,wBAAwB;AACpD,6BAA6B,kBAAkB;AAC/C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,sBAAsB;AACrC,eAAe,wBAAwB;AACvC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACnaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEuC;AACiB;AACyD;AACvE;;AAE1C,cAAc,iEAAiE;;AAE/E;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA,sBAAsB,gEAAqB;;AAE3C,mBAAmB,gCAAgC;AACnD;AACA;;AAEA;AACA;AACA,eAAe,gCAAgC;AAC/C,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,+DAAoB,4BAA4B,cAAc;AACpF;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,kBAAkB,8DAAmB;AACrC;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,kBAAkB,8DAAmB;AACrC;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,kBAAkB,8DAAmB;AACrC;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,kBAAkB,8DAAmB;AACrC;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,gCAAgC;AAC/C,iBAAiB;AACjB;AACA;AACA;AACA,kBAAkB,8DAAmB;AACrC;;AAEA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,gEAAa;AAChC,YAAY,mDAAS,gBAAgB,WAAW,qBAAqB,QAAQ;;AAE7E;AACA,2BAA2B,uDAAY,IAAI,WAAW,4BAA4B,QAAQ,aAAa,QAAQ;AAC/G,aAAa;;AAEb;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA,mBAAmB,kBAAkB;AACrC;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,yDAAe;AAC9B;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,sBAAsB,gEAAqB;;AAE3C,mCAAmC,kBAAkB;AACrD;AACA;;AAEA;AACA;AACA,eAAe,kBAAkB;AACjC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA,yDAAyD;AACzD,uBAAuB,gEAAa;AACpC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA,eAAe,kBAAkB;AACjC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA,mBAAmB,kBAAkB;AACrC;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,yDAAe;AAC9B;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,sBAAsB,gEAAqB;;AAE3C,mCAAmC,kBAAkB;AACrD;AACA;;AAEA;AACA;AACA,eAAe,kBAAkB;AACjC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA,oCAAoC;AACpC,uBAAuB,gEAAa;AACpC;AACA;AACA,aAAa;AACb;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA,eAAe,kBAAkB;AACjC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA,mBAAmB,mBAAmB;AACtC;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,0DAAgB;AAC/B;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,sBAAsB,gEAAqB;;AAE3C,0BAA0B,4DAAkB;AAC5C;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,mBAAmB;AAClC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,gEAAa;AAChC;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,eAAe,mBAAmB;AAClC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA,mBAAmB,aAAa;AAChC;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,0DAAgB;AAC/B;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,sBAAsB,gEAAqB;;AAE3C,mBAAmB,gEAAa;AAChC;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,aAAa;AAC5B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,gEAAa;AAChC;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,eAAe,aAAa;AAC5B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;AC7kBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE8C;AACQ;AACC;AACuB;AACvC;AACmB;AACF;AACb;;AAE3C,cAAc,gEAAgE;;AAE9E;AACA,aAAa,QAAQ;AACrB,cAAc,aAAa;AAC3B;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,mBAAmB;AAClC,eAAe,oBAAoB;AACnC;AACA,2CAA2C;AAC3C;AACA;AACA;AACA,sBAAsB,gEAAqB;;;;AAI3C,mBAAmB,mBAAmB;AACtC;;AAEA,mBAAmB,aAAa;AAChC,uEAAuE,0DAAgB;;AAEvF,mBAAmB,oBAAoB;AACvC,wCAAwC,kCAAkC;;;;AAI1E;AACA;AACA,sBAAsB,gEAAqB,uBAAuB,OAAO;AACzE,iCAAiC,0DAAgB,qBAAqB,0DAAgB;AACtF,sBAAsB,+DAAoB,oBAAoB,aAAa;AAC3E;;AAEA;AACA;AACA;AACA,eAAe,gCAAgC;AAC/C,eAAe,oBAAoB;AACnC,eAAe,SAAS;AACxB,iBAAiB;AACjB;AACA,yCAAyC;AACzC;AACA,eAAe,wEAAsB;AACrC,YAAY,sDAAY;;AAExB;AACA;;AAEA;AACA;AACA,gBAAgB,mDAAS,8BAA8B,YAAY;;AAEnE;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,iBAAiB,gCAAgC;AACjD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,yDAAe;AAChC;;AAEA,iBAAiB,yDAAe;AAChC;;AAEA,iBAAiB,0DAAgB;AACjC;;AAEA,iBAAiB,0DAAgB;AACjC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,oDAAU;AAC7B;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,YAAY,mDAAS;AACrB;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,4BAA4B;AAC7C;AACA;AACA;AACA;AACA;AACA,sBAAsB,gEAAqB;;AAE3C;AACA;;AAEA;AACA,eAAe,wEAAqB;AACpC;;AAEA;AACA;AACA,eAAe,mBAAmB;AAClC,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,sBAAsB,gEAAqB;AAC3C;AACA,sBAAsB,gEAAqB;AAC3C,qCAAqC,0DAAgB;AACrD,mBAAmB,wEAAqB;AACxC;AACA,uBAAuB,gEAAa;AACpC;AACA;;;;;;;;;;;;;;;;;AC9PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEqD;;AAErD;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,8DAAmB;AACrC;AACA;;;;;;;;;;;;;;;;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEgD;;AAEhD;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;;AAEA,mBAAmB,QAAQ;AAC3B;AACA;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,+BAA+B,kBAAkB,IAAI,kBAAkB;AACvE;;AAEA;AACA;AACA,eAAe,eAAe;AAC9B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,yDAAa;AAChC;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC1HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;;AAEA,mBAAmB,QAAQ;AAC3B;AACA;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,6BAA6B,WAAW,IAAI,YAAY;AACxD;;AAEA;AACA;AACA,eAAe,YAAY;AAC3B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC7GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;;AAEA,mBAAmB,QAAQ;AAC3B;AACA;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,gCAAgC,kBAAkB,IAAI,kBAAkB;AACxE;;AAEA;AACA;AACA,eAAe,eAAe;AAC9B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,eAAe;AAC9B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,eAAe;AAC9B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,eAAe;AAC9B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,eAAe;AAC9B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AChLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE0C;AACmB;AACR;AACS;AACpB;;;;AAI1C;AACA;AACA;;AAEA;AACA,iBAAiB,iEAAY;AAC7B;;AAEA;AACA;AACA,wBAAwB,iEAAY;AACpC,sCAAsC,sCAAsC;AAC5E;AACA,+BAA+B;;AAE/B;AACA;AACA,yBAAyB,iEAAY;AACrC,uCAAuC,iCAAiC;AACxE;AACA,gCAAgC;;AAEhC;AACA,yBAAyB,iEAAY;AACrC,uCAAuC,iCAAiC;AACxE;AACA,gCAAgC;AAChC;AACA;AACA,mBAAmB,iEAAY;AAC/B,iCAAiC,sBAAsB;AACvD;AACA,0BAA0B;;AAE1B;AACA,2BAA2B,iEAAY;AACvC,yCAAyC,gBAAgB;AACzD;;AAEA,yBAAyB,iEAAY;AACrC,uCAAuC,gBAAgB;AACvD;;AAEA;AACA,oBAAoB,iEAAY;AAChC,kCAAkC,gBAAgB;AAClD;;AAEA,6BAA6B,iEAAY;AACzC,2CAA2C,gBAAgB;AAC3D;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,0BAA0B,8DAAoB;;AAE9C;AACA;;;;AAIA;AACA;AACA;AACA;AACO,wCAAwC,q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;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;;AAGA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;;;;AAIA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,eAAe,GAAG,SAAS,IAAI,MAAM;AAC/E;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC7eA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE0C;AACmB;AACY;AACpB;AACiB;;;;AAItE;AACA;AACA;;AAEA,kBAAkB,iEAAY;AAC9B,oBAAoB,iEAAY;;;AAGhC;AACA;AACA;AACA;AACO,yCAAyC,qEAAkB;AAClE;AACA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gCAAgC,mEAAK;AACrC;AACA;AACA,gCAAgC,mEAAK;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iCAAiC,mEAAK;AACtC;AACA;AACA;AACA;AACA,iCAAiC,mEAAK;AACtC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACtFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE0C;AACmB;AACR;AACK;;;;AAI1D;AACA;AACA;;AAEA;AACA,wBAAwB,iEAAY;AACpC;;AAEA;AACA,sBAAsB,iEAAY;AAClC;AACA;AACA,sBAAsB;AACtB;;AAEA,uBAAuB,iEAAY;AACnC;AACA;AACA,uBAAuB;AACvB;;AAEA;AACA,oBAAoB,iEAAY;AAChC;;AAEA;AACA;AACA;AACA;AACO,2CAA2C,qEAAkB;AACpE;AACA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACzEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE0C;AACmB;AACY;AACpB;AACX;;;;AAI1C;AACA;AACA;;AAEA;AACA,aAAa,iEAAY;;AAEzB;AACA,sBAAsB,iEAAY,yCAAyC,WAAW;;AAEtF;AACA,sBAAsB,iEAAY,yCAAyC,WAAW;;AAEtF;AACA,cAAc,iEAAY;;AAE1B;AACA,aAAa,iEAAY;;AAEzB;AACA,uBAAuB,iEAAY;;AAEnC;AACA,uBAAuB,iEAAY;;AAEnC;AACA,qBAAqB,iEAAY;;AAEjC;AACA,yBAAyB,iEAAY;;;;;AAKrC;AACA;AACA;AACA;AACO,sCAAs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;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEwD;AACX;AACgB;;;;AAI7D;AACA;AACA,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB;AACO;AACP;AACA;AACA;AACA,0BAA0B;;AAE1B;AACA;AACA,kBAAkB,+DAAoB,4DAA4D,MAAM;AACxG;AACA,kBAAkB,+DAAoB,qCAAqC,iBAAiB;;AAE5F;AACA;;AAEA;AACA,uCAAuC,yDAAe,CAAC,8DAAoB,KAAK,8DAAoB;AACpG;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,cAAc,gBAAgB,UAAU,IAAI,UAAU,aAAa,GAAG;AAC1F;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,UAAU;;AAEV;AACA;AACA;;AAEA;AACA,WAAW,iEAAY;AACvB;;;;;AAKA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB;AACO;AACP;AACA;AACA;;;;;AAKA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB;AACO;AACP;AACA;AACA;;;;;AAKA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA,0BAA0B;;AAE1B;AACA;AACA,kBAAkB,+DAAoB,4DAA4D,MAAM;AACxG;AACA,kBAAkB,+DAAoB,gDAAgD,KAAK,KAAK;;AAEhG;AACA;;AAEA;AACA,uCAAuC,8DAAoB;AAC3D;AACA;AACA;AACA,mBAAmB,cAAc,gBAAgB,SAAS,gBAAgB,GAAG;AAC7E;AACA,mBAAmB,cAAc,mBAAmB,SAAS,aAAa,GAAG;AAC7E;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,UAAU;;AAEV;AACA;AACA;;AAEA;AACA,WAAW,iEAAY;AACvB;;;;;;;;;;AC3JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC/FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEiD;AACU;AACpB;AACa;;AAEpD;AACA;AACA;AACA;;AAEA,WAAW,QAAQ;AACnB;;AAEA,WAAW,QAAQ;AACnB,uCAAuC;;AAEvC;AACA;AACA;AACO,iCAAiC,mEAAe;AACvD;AACA;AACA;AACA,eAAe,eAAe;AAC9B,eAAe,cAAc;AAC7B,eAAe,QAAQ;AACvB,iBAAiB,eAAe;AAChC;AACA;AACA;AACA,QAAQ,sDAAY,8EAA8E,eAAe;;AAEjH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,+CAA+C;;AAE/C;AACA;AACA;AACA,sBAAsB,4DAAiB,sCAAsC,UAAU,MAAM,mBAAmB;;AAEhH;AACA;AACA,uBAAuB,yBAAyB;AAChD;AACA;;AAEA;AACA,YAAY,sDAAY;AACxB,YAAY,sDAAY;;AAExB;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ,mDAAS;AACjB,0BAA0B,MAAM,GAAG,QAAQ,cAAc,qBAAqB;AAC9E,eAAe,mBAAmB;AAClC,4BAA4B,mCAAmC;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACjGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEuC;AACU;AACO;AACkB;;AAE1E,cAAc,8CAA8C;;AAE5D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAW,UAAU;AACrB;;AAEA,WAAW,uBAAuB;AAClC;;;;AAIA;AACA;AACA;AACO,uBAAuB,yDAAU;AACxC;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,QAAQ,sDAAY;AACpB;;;;AAIA,mBAAmB,SAAS;AAC5B;;AAEA,mBAAmB,mBAAmB;AACtC;;AAEA,mBAAmB,wBAAwB;AAC3C;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,iBAAiB;AACjB;AACA;AACA;AACA,uBAAuB,4DAAkB;;AAEzC;AACA,YAAY,uDAAa;AACzB;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,SAAS,SAAS;;AAElB;AACA;;AAEA;AACA;AACA,eAAe,mBAAmB;AAClC,iBAAiB;AACjB;AACA;AACA;AACA,QAAQ,mDAAS,eAAe,iBAAiB;;AAEjD;AACA;AACA,sBAAsB,4DAAiB;;AAEvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA,sBAAsB,4DAAiB;;AAEvC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAQ,uDAAa;;AAErB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,4DAAiB;;AAEvC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,mCAAmC;AACnD;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,gEAAa;AAChC;AACA;AACA;AACA;AACA,mDAAmD;AACnD,aAAa;AACb,SAAS;AACT;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,uBAAuB;AACtC;AACA;AACA;AACA;AACA;AACA,sBAAsB,+DAAoB,8BAA8B,MAAM;;AAE9E;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AC1QA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEuC;AACU;AACa;AACJ;AACQ;AACF;AACR;AACjB;AACU;;;AAGjD;AACA;AACA;AACO,wBAAwB,yDAAU;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,UAAU;AAC7B,yBAAyB,yDAAiB;;AAE1C,mBAAmB,qBAAqB;AACxC,6BAA6B,uEAAmB;;AAEhD,mBAAmB,mBAAmB;AACtC,gCAAgC,mEAAiB;;AAEjD,mBAAmB,uBAAuB;AAC1C,oCAAoC,2EAAqB;;;;AAIzD;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,eAAe;AAC9B,iBAAiB,mBAAmB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,uDAAa,2BAA2B,OAAO,IAAI,OAAO;AACtE;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,mBAAmB;AAClC,eAAe,eAAe;AAC9B,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,QAAQ,sDAAY;;AAEpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,qBAAqB;AACrC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,6BAA6B,uEAAmB;AAChD,gCAAgC,mEAAiB;AACjD,oCAAoC,2EAAqB;;AAEzD;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;AC3LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEwE;AACb;AACpB;AACY;;AAEnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAW,QAAQ;AACZ;;AAEP,WAAW,QAAQ;AACZ;;AAEP,WAAW,UAAU;AACd;;AAEP,WAAW,UAAU;AACd;;AAEP,WAAW,UAAU;AACd;;AAEP;AACA,aAAa,QAAQ;AACrB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB;;AAEA,WAAW,kDAAkD;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA,cAAc,aAAa;AAC3B,cAAc,6BAA6B;AAC3C,cAAc,oDAAoD;;AAElE,WAAW,QAAQ;AACZ;;AAEP,WAAW,QAAQ;AACZ;;AAEP,WAAW,sCAAsC;AACjD,gCAAgC,qDAAW;AAC3C;AACA;;AAEA,WAAW,8CAA8C;AACzD,kCAAkC,qDAAW;AAC7C;AACA;;AAEA,WAAW,cAAc;AACzB,0FAA0F;AAC1F;AACA;AACA,YAAY,uDAAa,CAAC,qDAAW;AACrC,YAAY,uDAAa,CAAC,qDAAW;AACrC,YAAY,uDAAa,CAAC,qDAAW;AACrC;;AAEA;AACA;AACA,YAAY,uDAAa,CAAC,qDAAW;AACrC,YAAY,uDAAa,CAAC,qDAAW;AACrC;AACA,CAAC;;AAED;AACA;AACA;;AAEA,WAAW,QAAQ;AACnB;;AAEA,WAAW,0BAA0B;AACrC;;;;AAIA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,eAAe;AAC9B,eAAe,eAAe;AAC9B,eAAe,cAAc;AAC7B,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAQ,sDAAY;AACpB,QAAQ,sDAAY,sHAAsH,gBAAgB;AAC1J,QAAQ,sDAAY,qIAAqI,gBAAgB;AACzK,QAAQ,sDAAY,mBAAmB,2DAAe,mDAAmD,mBAAmB;AAC5H,QAAQ,sDAAY,gFAAgF,WAAW,iBAAiB,SAAS;;AAEzI,mBAAmB,YAAY;AAC/B;;AAEA,mBAAmB,QAAQ;AAC3B;;AAEA,mBAAmB,QAAQ;AAC3B;;AAEA,mBAAmB,cAAc;AACjC;;AAEA,mBAAmB,eAAe;AAClC;;AAEA,mBAAmB,eAAe;AAClC,6BAA6B,2EAAyB;AACtD;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,QAAQ,sDAAY;AACpB,QAAQ,sDAAY;;AAEpB;AACA;;AAEA;AACA;AACA,eAAe,eAAe;AAC9B,eAAe,cAAc;AAC7B,eAAe,cAAc;AAC7B,eAAe,QAAQ;AACvB,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6FAA6F;AAC7F,iFAAiF;AACjF;AACA;;AAEA;AACA,QAAQ,sDAAY;AACpB,QAAQ,sDAAY;AACpB,QAAQ,sDAAY;;AAEpB;AACA;AACA,QAAQ,mDAAS;AACjB,wBAAwB,YAAY,EAAE,aAAa,kBAAkB,qBAAqB;AAC1F,eAAe,mBAAmB,uCAAuC,UAAU;AACnF,gBAAgB,aAAa,GAAG,cAAc,SAAS,wCAAwC;AAC/F,6CAA6C,wCAAwC;AACrF;;AAEA;AACA;AACA;AACA,YAAY,uDAAa,oCAAoC,oBAAoB,UAAU,aAAa,oBAAoB,+BAA+B,oFAAoF,SAAS;AACxP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,4BAA4B,uDAAa,CAAC,qDAAW;;AAErD;AACA;AACA;AACA,uBAAuB,yBAAyB;AAChD,oDAAoD;AACpD;;AAEA;AACA,+BAA+B,oBAAoB;AACnD;AACA;AACA;AACA;;AAEA;AACA;AACA,6CAA6C,8BAA8B;AAC3E;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ,mDAAS;AACjB,6BAA6B,YAAY,EAAE,aAAa,kBAAkB,qBAAqB;AAC/F,eAAe,mBAAmB,uCAAuC,UAAU;AACnF;AACA,wBAAwB,qFAAqF;AAC7G,wBAAwB,gCAAgC;AACxD,+BAA+B,cAAc;AAC7C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,cAAc;AAC7B,iBAAiB,UAAU;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAQ,sDAAY;AACpB;AACA;AACA;;AAEA;AACA,2BAA2B,oBAAoB;AAC/C;;AAEA;AACA;AACA,2BAA2B,cAAc;AACzC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,YAAY,sDAAY;AACxB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,QAAQ;AAC3B;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B;AAC1B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;;;AC3jBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyC;AACkB;AACI;AACI;AACF;AACI;AACT;;AAE5D;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;;AAEA,mBAAmB,WAAW;AAC9B;;AAEA,mBAAmB,2BAA2B;AAC9C;;AAEA,mBAAmB,8BAA8B;AACjD;;AAEA,mBAAmB,4BAA4B;AAC/C;;AAEA,mBAAmB,6BAA6B;AAChD;;AAEA,mBAAmB,yBAAyB;AAC5C;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,qDAAqD,wEAAyB;AAC9E;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,2DAA2D,8EAA4B;AACvF;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,uDAAuD,0EAA0B;AACjF;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,yDAAyD,4EAA2B;AACpF;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iDAAiD,oEAAuB;AACxE;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,qEAAkB;AACtD;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;;;;;;AC5HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyD;AACR;AACR;;AAEzC,cAAc,iDAAiD;;AAE/D;AACA,aAAa,QAAQ;AACrB,cAAc,kCAAkC;AAChD,cAAc,kCAAkC;AAChD;;AAEA,YAAY,sBAAsB;AAClC;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B;;AAEA,mBAAmB,iBAAiB;AACpC;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,mBAAmB;AAClC,eAAe,sBAAsB;AACrC,iBAAiB;AACjB;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,QAAQ;AAC/C;AACA,aAAa;AACb,SAAS;;AAET;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,uBAAuB,2BAA2B;AAClD;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,mBAAmB;AAClC,eAAe,sBAAsB;AACrC,iBAAiB;AACjB;AACA,2CAA2C;AAC3C;AACA,4BAA4B,0DAAa;AACzC;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC5IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEwE;AAChB;AACC;AAClB;AACmE;;AAE1G,YAAY,uBAAuB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,aAAa,QAAQ;AACrB,cAAc,SAAS;AACvB,cAAc,SAAS;AACvB;;AAEA,cAAc,iDAAiD;;AAE/D;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,wBAAwB;AACvC,eAAe,mBAAmB;AAClC,eAAe,sBAAsB;AACrC;AACA,6CAA6C;AAC7C;AACA;;AAEA,mBAAmB,eAAe;AAClC;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,wBAAwB;AACvC,eAAe,mBAAmB;AAClC,eAAe,sBAAsB;AACrC;AACA;AACA;AACA;AACA;AACA,sBAAsB,gEAAqB;;AAE3C;AACA;AACA;AACA;AACA;AACA,SAAS;;;;AAIT,mBAAmB,wBAAwB;AAC3C;;AAEA,mBAAmB,cAAc;AACjC;;AAEA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA,SAAS;;AAET,mBAAmB,UAAU;AAC7B;;AAEA,mBAAmB,WAAW;AAC9B;;AAEA,mBAAmB,WAAW;AAC9B;;AAEA,mBAAmB,SAAS;AAC5B;;AAEA,mBAAmB,QAAQ;AAC3B;;AAEA,mBAAmB,QAAQ;AAC3B;;AAEA,mBAAmB,yBAAyB;AAC5C;;AAEA,mBAAmB,QAAQ;AAC3B;;AAEA,mBAAmB,6BAA6B;AAChD;;AAEA,mBAAmB,mBAAmB;AACtC;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,2BAA2B;AAClD;AACA;AACA;AACA;AACA,8BAA8B,gEAAqB,sBAAsB,QAAQ;AACjF;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,8BAA8B;AAC9C,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,+DAAoB,8DAA8D,gBAAgB,QAAQ,YAAY;;AAE5I;AACA,yBAAyB,uDAAa;AACtC,yCAAyC,QAAQ;AACjD;AACA,0BAA0B,4DAAiB;AAC3C;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,kCAAkC,iBAAiB;AACnD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,QAAQ,GAAG,aAAa;AACpE,kCAAkC,+DAAoB,+CAA+C,QAAQ;AAC7G,wDAAwD,gCAAgC,QAAQ,GAAG,EAAE,oBAAoB;AACzH;AACA;AACA;AACA,8BAA8B,+DAAoB,6CAA6C,QAAQ;AACvG;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,2CAA2C;;AAE3C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,+BAA+B;AAC/C,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,eAAe;AAChC;AACA;AACA;AACA,QAAQ,sDAAY;;AAEpB;AACA;AACA;;AAEA;AACA,uBAAuB,0BAA0B;AACjD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,0BAA0B;AACzC,iBAAiB,eAAe;AAChC;AACA;AACA;AACA,QAAQ,sDAAY,oFAAoF,qBAAqB;;AAE7H;AACA,uBAAuB,0BAA0B;AACjD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,0BAA0B;AACjD;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,iBAAiB;AAChC,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,wBAAwB;AACvC,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,kDAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;;;;;;;AAOA;AACA;AACA,WAAW,wBAAwB;AACnC,WAAW,sBAAsB;AACjC,aAAa;AACb;AACA,aAAa,QAAQ;AACrB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB;AACA,aAAa,QAAQ;AACrB,cAAc,aAAa;AAC3B,cAAc,aAAa;AAC3B;AACA;AACA;AACA,eAAe,wBAAwB;AACvC;;AAEA,eAAe,oBAAoB;AACnC;AACA;AACA;AACA,KAAK;;AAEL,eAAe,wBAAwB;AACvC;;;;AAIA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;;AAE9C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;AAMA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,sBAAsB;AACjC;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA,kBAAkB,4DAAiB,8BAA8B,UAAU;;AAE3E,eAAe,sBAAsB;AACrC;;AAEA,eAAe,QAAQ;AACvB;AACA;;AAEA,eAAe,QAAQ;AACvB;;AAEA,eAAe,QAAQ;AACvB;;AAEA,eAAe,gCAAgC;AAC/C;AACA;;AAEA;AACA;AACA,WAAW,wBAAwB;AACnC,WAAW,2BAA2B;AACtC,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA,gCAAgC,UAAU;;AAE1C;AACA;AACA;AACA;AACA,sBAAsB,4DAAiB,gCAAgC,MAAM,WAAW,oCAAoC;AAC5H;AACA,sBAAsB,4DAAiB;AACvC;AACA,sBAAsB,+DAAoB,iCAAiC,OAAO;AAClF;AACA,sBAAsB,+DAAoB;;AAE1C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE;AACA,4DAA4D;AAC5D;AACA;AACA,sBAAsB,+DAAoB,qDAAqD,UAAU,KAAK,MAAM;AACpH;AACA;AACA,kBAAkB,+DAAoB,6CAA6C,MAAM;;AAEzF;AACA;;AAEA;AACA;AACA;;;;;AAKA;AACA,aAAa,QAAQ;AACrB,cAAc,aAAa;AAC3B,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,sBAAsB;AACpC;;AAEA;AACA;AACA,WAAW,wBAAwB;AACnC,WAAW,cAAc;AACzB;AACA;AACA;AACA,eAAe,wBAAwB;AACvC;;AAEA,eAAe,cAAc;AAC7B;;AAEA,eAAe,QAAQ;AACvB;;AAEA,eAAe,yBAAyB;AACxC;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,yEAAyE;AACzE;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;;;;;ACvvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEuC;AACE;AACgB;AACN;;AAEnD;AACA;AACA;;;AAGA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;;;AAIA;AACA,aAAa,QAAQ;AACrB;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,oBAAoB;AACnC,eAAe,oBAAoB;AACnC;AACA;AACA;AACA,mBAAmB,uBAAuB;AAC1C;;AAEA,mBAAmB,oBAAoB;AACvC;;AAEA,mBAAmB,oBAAoB;AACvC;;AAEA,mBAAmB,SAAS;AAC5B;AACA;AACA;;;;AAIA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,QAAQ;AACvB;AACA;AACA;AACA,QAAQ,sDAAY;;AAEpB,mBAAmB,iBAAiB;AACpC,oCAAoC,kBAAkB;;AAEtD,mBAAmB,oBAAoB;AACvC;;AAEA,mBAAmB,WAAW;AAC9B;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,sBAAsB,2DAAgB,8BAA8B,oBAAoB;;AAExF;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,uBAAuB;AACtC,iBAAiB;AACjB;AACA;AACA;AACA;AACA,QAAQ,sDAAY;;AAEpB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,uBAAuB,yBAAyB;AAChD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,wBAAwB;AACvC,eAAe,eAAe;AAC9B,iBAAiB;AACjB;AACA;AACA;AACA,4BAA4B,kEAAqB;AACjD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;;;;;;;AClLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEuC;AACU;AACR;AACe;AACC;AACsB;;AAE/E;;AAEA;AACA,UAAU,QAAQ,gBAAgB;AAClC;AACA;AACA;;AAEA;AACA,UAAU,0CAA0C;AACpD;AACA;AACA;AACA,4EAA4E;;AAE5E;AACA;AACA;AACA;AACA,8BAA8B,yDAAU;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,KAAK;AACxB;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,GAAG;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,sBAAsB,gEAAqB;;AAE3C;AACA;AACA;;AAEA,cAAc,QAAQ;;AAEtB;AACA,aAAa,QAAQ;AACrB,cAAc,aAAa;AAC3B,cAAc,YAAY;AAC1B;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA,QAAQ,sDAAY;;AAEpB,mBAAmB,cAAc;AACjC;;AAEA,mBAAmB,eAAe;AAClC;;AAEA,mBAAmB,6BAA6B;AAChD;;AAEA,mBAAmB,8BAA8B;AACjD;;AAEA,mBAAmB,SAAS;AAC5B;;AAEA,mBAAmB,SAAS;AAC5B;AACA;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA,QAAQ,sDAAY;;AAEpB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,iDAAiD;AACjD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,SAAS;AACxB,iBAAiB,2BAA2B;AAC5C;AACA;AACA;AACA,QAAQ,sDAAY;;AAEpB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,iDAAiD;AACjD;;AAEA;AACA;AACA,mBAAmB,wEAAqB;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,yCAAyC,0BAA0B;AACnE,aAAa;AACb,SAAS;;AAET;AACA,4BAA4B,gEAAa;AACzC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,qDAAqD;AACrD;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,sDAAsD,QAAQ;AAC9D,yCAAyC,mDAAmD;AAC5F;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,8BAA8B;AACrD;AACA,mDAAmD;AACnD;AACA;AACA;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;;AAEA,uBAAuB,sBAAsB;AAC7C;AACA;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;;AAEA,0CAA0C,QAAQ;AAClD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,wBAAwB;AACvC,eAAe,aAAa;AAC5B,eAAe,YAAY;AAC3B,eAAe,kBAAkB;AACjC,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,eAAe,SAAS;AACxB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,QAAQ,sDAAY;;AAEpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB;;AAEpB;AACA,mBAAmB,gEAAa;AAChC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT,sBAAsB,gEAAqB;AAC3C,SAAS;AACT;AACA,SAAS;AACT;;AAEA;AACA;AACA,eAAe,wBAAwB;AACvC,eAAe,WAAW;AAC1B,eAAe,YAAY;AAC3B,eAAe,UAAU;AACzB,eAAe,UAAU;AACzB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,uDAAY,uCAAuC,uDAAY;AAC1F;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C,kDAAkD;AAClD,6CAA6C;AAC7C;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;;;;AC/aA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyC;AACQ;AACe;;AAEhE;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B;AACA;;AAEA;AACA;AACA,eAAe,mBAAmB;AAClC,eAAe,eAAe;AAC9B,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyC;AACF;AACmE;AACpD;;AAEtD;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,wBAAwB;AACvC,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA,mBAAmB,wBAAwB;AAC3C;;AAEA,mBAAmB,QAAQ;AAC3B;;AAEA,mBAAmB,QAAQ;AAC3B;;AAEA,mBAAmB,SAAS;AAC5B;;AAEA,mBAAmB,QAAQ;AAC3B;;AAEA,mBAAmB,QAAQ;AAC3B;;AAEA,mBAAmB,QAAQ;AAC3B;;AAEA,mBAAmB,QAAQ;AAC3B;;AAEA,mBAAmB,QAAQ;AAC3B;;AAEA,mBAAmB,cAAc;AACjC;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,gEAAqB;;AAE3C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,gBAAgB;AAC/B,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,eAAe;AAC/B;AACA;AACA;AACA;AACA,QAAQ,sDAAY;;AAEpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oBAAoB;AACpB,mBAAmB,8DAAkB,aAAa,8DAAkB;AACpE,sBAAsB,4DAAiB,yCAAyC,OAAO,IAAI,OAAO,mBAAmB,8DAAkB,EAAE,IAAI,8DAAkB,CAAC;AAChK;AACA,sBAAsB,+DAAoB,0BAA0B,OAAO,IAAI,OAAO;;AAEtF;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,yBAAyB;AACxC,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,sDAAY;;AAExB;AACA,+BAA+B,uBAAuB;AACtD;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,sDAAY;;AAE5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,wBAAwB;AACvC,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,QAAQ,sDAAY;;AAEpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,wBAAwB;AACvC,eAAe,cAAc;AAC7B,eAAe,SAAS;AACxB,eAAe,SAAS;AACxB,eAAe,gBAAgB;AAC/B,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;;AAE5C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,wBAAwB;AACvC,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA,mBAAmB,kBAAkB;AACrC;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,gEAAqB;;AAE3C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,eAAe;AAC9B,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAQ,sDAAY;;AAEpB;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,SAAS;AACxB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oBAAoB;AACpB;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,yFAAyF;;AAEzF;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wDAAwD;;AAExD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,wBAAwB;AACvC,eAAe,cAAc;AAC7B,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;;AAExD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kDAAO,8BAA8B,OAAO,GAAG,OAAO;AAC5E;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,wBAAwB;AACvC,eAAe,kBAAkB;AACjC,eAAe,cAAc;AAC7B,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,eAAe,SAAS;AACxB,eAAe,OAAO;AACtB,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9rBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAc,wBAAwB;;AAEtC;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,kBAAkB;AACrC;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,kBAAkB;AACjC;AACA;AACA;AACA,wCAAwC,QAAQ;AAChD;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,kBAAkB;AACjC;AACA;AACA;AACA,yCAAyC,QAAQ;AACjD;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,kBAAkB;AACjC;AACA;AACA;AACA,8BAA8B,QAAQ;AACtC;;AAEA;AACA;AACA,eAAe,wBAAwB;AACvC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,kBAAkB;AACjC;AACA;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,kBAAkB;AACjC;AACA;AACA;AACA,mCAAmC,QAAQ;AAC3C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,kBAAkB;AACjC;AACA;AACA;AACA,oCAAoC,QAAQ;AAC5C;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,kBAAkB;AACjC;AACA;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,kBAAkB;AACjC;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,kBAAkB;AACjC;AACA;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,kBAAkB;AACjC;AACA;AACA;AACA,8BAA8B,QAAQ;AACtC;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,kBAAkB;AACjC;AACA;AACA;AACA,mCAAmC,QAAQ;AAC3C;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,kBAAkB;AACjC;AACA;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,kBAAkB;AACjC;AACA;AACA;AACA,oCAAoC,QAAQ;AAC5C;AACA;;;;;;;;;;;;;;;;ACnTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEiD;;AAEjD,YAAY,QAAQ;AACpB;;AAEA,WAAW,iBAAiB;AAC5B;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;;AAEA,mBAAmB,QAAQ;AAC3B;;AAEA,mBAAmB,QAAQ;AAC3B;;AAEA,mBAAmB,QAAQ;AAC3B;;AAEA,mBAAmB,kBAAkB;AACrC;;;;AAIA;AACA;AACA,sBAAsB,0DAAqB;;AAE3C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,WAAW,QAAQ;AACZ;;AAEP,WAAW,QAAQ;AACZ;;AAEP,WAAW,QAAQ;AACZ;;;;AAIP;AACA;AACA;;AAEA,WAAW,QAAQ;AACZ,oBAAoB;;AAE3B,WAAW,QAAQ;AACZ,sCAAsC;;;;AAI7C;AACA;AACA;;AAEA,WAAW,QAAQ;AACZ,uDAAuD;;;;AAI9D;AACA;AACA;;AAEA,WAAW,QAAQ;AACZ;;AAEP,WAAW,QAAQ;AACZ,8BAA8B;;AAErC,WAAW,QAAQ;AACZ;;AAEP,WAAW,QAAQ;AACZ;;AAEP,WAAW,QAAQ;AACZ;;AAEP,WAAW,QAAQ;AACZ;;AAEP,WAAW,QAAQ;AACZ,8DAA8D;;AAErE,WAAW,QAAQ;AACZ;;AAEP,WAAW,QAAQ;AACZ;;AAEP,WAAW,QAAQ;AACZ;;;;AAIP;AACA;AACA;;AAEA,WAAW,SAAS;AACb;AACP;AACA,CAAC;;;;;;;;;;;;;;;ACpGD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B;;AAEA,mBAAmB,UAAU;AAC7B;;AAEA,mBAAmB,cAAc;AACjC;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,QAAQ;AACvB;AACA;AACA;AACA,kDAAkD,QAAQ;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,8BAA8B;AACrD;AACA;AACA;;;;;;;;;;;;;;;ACjFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,uDAAuD;;AAEvD;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,2DAA2D;AAC1E;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,iEAAiE;AAChF,eAAe,qEAAqE;AACpF,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wCAAwC;AACxC,uCAAuC;AACvC;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,qEAAqE;AACpF,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC,iBAAiB;AACjB;AACA;AACA;AACA,4BAA4B,aAAa;AACzC;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB;;AAEtB;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,wCAAwC,WAAW;AACnD;AACA,wCAAwC,cAAc,cAAc;AACpE;AACA,wCAAwC,aAAa,cAAc;AACnE;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,GAAG;AAClB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6DAA6D;AAC5E,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kDAAkD,iBAAiB,qCAAqC;AACxG,2BAA2B,YAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,6DAA6D;AAC5E,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,2BAA2B,YAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,eAAe,GAAG;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B;AAC/B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,cAAc;AACzC;AACA;;AAEA;AACA;AACA;AACA,mEAAmE;AACnE,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,cAAc;AACzC;AACA;;AAEA;AACA;AACA;AACA,mEAAmE;AACnE,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,GAAG;AAClB;AACA;AACA;AACA,iFAAiF;AACjF;AACA;AACA;;AAEA;AACA,mCAAmC;;AAEnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,YAAY,+BAA+B;AAC1E,+BAA+B,WAAW;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB;;AAErB;AACA;AACA,mBAAmB;AACnB,6CAA6C;AAC7C;;;;;;;;;;;;;;;;;;;ACrcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACO;AACP;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA,UAAU;AACV;AACO;AACP;AACA;AACA,CAAC;;AAED;AACA;AACA,aAAa,QAAQ;AACrB;AACO;AACP;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;;;;AC7DD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEiH;AAChE;;AAEjD,eAAe,4BAA4B;AAC3C,cAAc,iCAAiC;;AAE/C,WAAW,gCAAgC;AAC3C;AACA,iCAAiC,oBAAoB;AACrD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA,KAAK;AACL,CAAC;;;;AAID;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,QAAQ;AACvB,gBAAgB;AAChB;AACA;AACA;AACA;AACA,sBAAsB,mDAAc;AACpC;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,UAAU;AACnC;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,+CAAU,uCAAuC,KAAK;AAC5E;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,qBAAqB;AAClC;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,SAAS;AACxB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ,EAAE,SAAS;AAC3C,wBAAwB,EAAE,EAAE,SAAS,gBAAgB,EAAE,EAAE,SAAS;AAClE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,yDAAoB,iDAAiD,YAAY;AACvG;AACA,sBAAsB,yDAAoB,2CAA2C,MAAM;;AAE3F;AACA;AACA;;AAEA;AACA,qCAAqC;AACrC,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,gBAAgB;AACvC;AACA;AACA;;AAEA,2BAA2B,WAAW;AACtC,2BAA2B,WAAW;;AAEtC;AACA;AACA;AACA;AACA;AACA;;AAEA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cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,SAAS,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,QAAQ,QAAQ,OAAO,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,SAAS,QAAQ,QAAQ,SAAS,QAAQ,QAAQ,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,QAAQ,QAAQ,QAAQ,OAAO,SAAS,QAAQ,QAAQ,SAAS,QAAQ,QAAQ,SAAS,QAAQ,QAAQ,SAAS,QAAQ,QAAQ,SAAS,QAAQ,QAAQ,SAAS,QAAQ,QAAQ,QAAQ,QAAQ,SAAS,SAAS,QAAQ,QAAQ,OAAO,QAAQ,QAAQ,SAAS,QAAQ,QAAQ,QAAQ,QAAQ,OAAO,OAAO,SAAS,SAAS,OAAO,SAAS,QAAQ,QAAQ,SAAS,QAAQ,QAAQ,SAAS,QAAQ,SAAS,SAAS,SAAS,SAAS,iBAAiB,sCAAsC,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,SAAS,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,SAAS,QAAQ,QAAQ,QAAQ,SAAS,SAAS,SAAS,SAAS,SAAS,QAAQ,SAAS,SAAS,QAAQ,SAAS,SAAS,QAAQ,SAAS,SAAS,OAAO,QAAQ,OAAO,QAAQ,QAAQ,QAAQ,OAAO,OAAO,SAAS,OAAO,QAAQ,OAAO,QAAQ,QAAQ,QAAQ,OAAO,OAAO,SAAS,OAAO,OAAO,OAAO,OAAO,QAAQ,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,QAAQ,QAAQ,QAAQ,QAAQ,SAAS,SAAS,OAAO,SAAS,SAAS,QAAQ,SAAS,SAAS,QAAQ,SAAS,SAAS,QAAQ,SAAS,SAAS,OAAO,OAAO,SAAS,SAAS,SAAS,SAAS,SAAS,QAAQ,QAAQ,QAAQ,QAAQ,SAAS,SAAS,OAAO,SAAS,SAAS,QAAQ,SAAS,SAAS,QAAQ,SAAS,SAAS,QAAQ,SAAS,SAAS,OAAO,OAAO,SAAS,SAAS,SAAS,SAAS,SAAS,OAAO,OAAO,OAAO,OAAO,QAAQ,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,QAAQ,SAAS,SAAS,QAAQ,SAAS,QAAQ,SAAS,SAAS,QAAQ,SAAS,SAAS,SAAS,SAAS,SAAS,OAAO,SAAS,SAAS,SAAS,SAAS,SAAS,QAAQ,SAAS,SAAS,SAAS,SAAS,SAAS,QAAQ,SAAS,SAAS,SAAS,SAAS,SAAS,QAAQ,SAAS,S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AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;UC3dA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE2C;AACO;AACD;AACI;AACF;AACH;AACmB;AACZ;AACG;AAC2B;AACE;AACM;AACF;AACF;AACnD;AACU;;AAEhD;AACA,cAAc,6CAA6C;AAC3D,cAAc,sDAAsD;AACpE,cAAc,kDAAkD;AAChE,cAAc,qEAAqE;AACnF,cAAc,iDAAiD;;;AAG/D;;AAEA,WAAW,qBAAqB;AAChC,0BAA0B,4EAAmB;;AAE7C,WAAW,8BAA8B;AACzC,2BAA2B,mGAA4B;;;;AAIvD;AACA;AACA;AACe;AACf;AACA;AACA;AACA,eAAe,gCAAgC;AAC/C,eAAe,oBAAoB;AACnC,iBAAiB;AACjB;AACA,2CAA2C;AAC3C;AACA,eAAe,gEAAgB;AAC/B;;AAEA;AACA;AACA,eAAe,iCAAiC;AAChD,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;;AAET,eAAe,oEAAyB;AACxC,qBAAqB,gEAAgB;AACrC;AACA;;AAEA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,gEAAoB;AACjC;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,4DAAY;AAC/B;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,yDAAU;AAC7B;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,gEAAa;AAC5B;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,mEAAc;AACjC;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,8FAA0B;AACzC;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,iGAA2B;AAC1C;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,uGAA8B;AAC7C;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,qGAA6B;AAC5C;;AAEA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA,WAAW,IAA2B;AACtC,mBAAmB,WAAkB;AACrC;AACA,YAAY,EAA0B;AACtC;;AAEA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA,eAAe,uEAAuB;AACtC;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,oEAAwB;AACvC;;AAEA;AACA;AACA,eAAe,uBAAuB;AACtC;AACA;AACA;AACA,QAAQ,oEAAwB;AAChC;AACA;;AAEA;AACA,oDAAS;AACT,sBAAsB,eAAe;AACrC;AACA,IAAI,0CAAkB;AACtB;;AAEA;AACA,IAAI,0DAAa;AACjB,IAAI,wDAAa","sources":["webpack://Speedy/webpack/universalModuleDefinition","webpack://Speedy/./src/core/pipeline/factories/filter-factory.js","webpack://Speedy/./src/core/pipeline/factories/image-factory.js","webpack://Speedy/./src/core/pipeline/factories/keypoint-factory.js","webpack://Speedy/./src/core/pipeline/factories/transform-factory.js","webpack://Speedy/./src/core/pipeline/factories/vector2-factory.js","webpack://Speedy/./src/core/pipeline/nodes/filters/convolution.js","webpack://Speedy/./src/core/pipeline/nodes/filters/gaussian-blur.js","webpack://Speedy/./src/core/pipeline/nodes/filters/greyscale.js","webpack://Speedy/./src/core/pipeline/nodes/filters/median-blur.js","webpack://Speedy/./src/core/pipeline/nodes/filters/nightvision.js","webpack://Speedy/./src/core/pipeline/nodes/filters/normalize.js","webpack://Speedy/./src/core/pipeline/nodes/filters/simple-blur.js","webpack://Speedy/./src/core/pipeline/nodes/images/buffer.js","webpack://Speedy/./src/core/pipeline/nodes/images/mixer.js","webpack://Speedy/./src/core/pipeline/nodes/images/multiplexer.js","webpack://Speedy/./src/core/pipeline/nodes/images/portal.js","webpack://Speedy/./src/core/pipeline/nodes/images/pyramid.js","webpack://Speedy/./src/core/pipeline/nodes/images/sink.js","webpack://Speedy/./src/core/pipeline/nodes/images/source.js","webpack://Speedy/./src/core/pipeline/nodes/keypoints/border-clipper.js","webpack://Speedy/./src/core/pipeline/nodes/keypoints/buffer.js","webpack://Speedy/./src/core/pipeline/nodes/keypoints/clipper.js","webpack://Speedy/./src/core/pipeline/nodes/keypoints/descriptors/descriptor.js","webpack://Speedy/./src/core/pipeline/nodes/keypoints/descriptors/orb.js","webpack://Speedy/./src/core/pipeline/nodes/keypoints/detectors/detector.js","webpack://Speedy/./src/core/pipeline/nodes/keypoints/detectors/fast.js","webpack://Speedy/./src/core/pipeline/nodes/keypoints/detectors/harris.js","webpack://Speedy/./src/core/pipeline/nodes/keypoints/distance-filter.js","webpack://Speedy/./src/core/pipeline/nodes/keypoints/hamming-distance-filter.js","webpack://Speedy/./src/core/pipeline/nodes/keypoints/matchers/bf-knn.js","webpack://Speedy/./src/core/pipeline/nodes/keypoints/matchers/lsh-knn.js","webpack://Speedy/./src/core/pipeline/nodes/keypoints/matchers/lsh-static-tables.js","webpack://Speedy/./src/core/pipeline/nodes/keypoints/mixer.js","webpack://Speedy/./src/core/pipeline/nodes/keypoints/multiplexer.js","webpack://Speedy/./src/core/pipeline/nodes/keypoints/portal.js","webpack://Speedy/./src/core/pipeline/nodes/keypoints/shuffler.js","webpack://Speedy/./src/core/pipeline/nodes/keypoints/sink.js","webpack://Speedy/./src/core/pipeline/nodes/keypoints/source.js","webpack://Speedy/./src/core/pipeline/nodes/keypoints/subpixel.js","webpack://Speedy/./src/core/pipeline/nodes/keypoints/trackers/lk.js","webpack://Speedy/./src/core/pipeline/nodes/keypoints/transformer.js","webpack://Speedy/./src/core/pipeline/nodes/transforms/perspective-warp.js","webpack://Speedy/./src/core/pipeline/nodes/transforms/resize.js","webpack://Speedy/./src/core/pipeline/nodes/vector2/sink.js","webpack://Speedy/./src/core/pipeline/pipeline-message.js","webpack://Speedy/./src/core/pipeline/pipeline-node.js","webpack://Speedy/./src/core/pipeline/pipeline-port.js","webpack://Speedy/./src/core/pipeline/pipeline-portbuilder.js","webpack://Speedy/./src/core/pipeline/pipeline-portspec.js","webpack://Speedy/./src/core/pipeline/pipeline.js","webpack://Speedy/./src/core/speedy-keypoint-descriptor.js","webpack://Speedy/./src/core/speedy-keypoint-match.js","webpack://Speedy/./src/core/speedy-keypoint.js","webpack://Speedy/./src/core/speedy-matrix-expr.js","webpack://Speedy/./src/core/speedy-matrix-factory.js","webpack://Speedy/./src/core/speedy-matrix-wasm.js","webpack://Speedy/./src/core/speedy-matrix.js","webpack://Speedy/./src/core/speedy-media-source.js","webpack://Speedy/./src/core/speedy-media.js","webpack://Speedy/./src/core/speedy-namespace.js","webpack://Speedy/./src/core/speedy-point.js","webpack://Speedy/./src/core/speedy-size.js","webpack://Speedy/./src/core/speedy-vector.js","webpack://Speedy/./src/gpu/programs/filters.js","webpack://Speedy/./src/gpu/programs/keypoints.js","webpack://Speedy/./src/gpu/programs/pyramids.js","webpack://Speedy/./src/gpu/programs/transforms.js","webpack://Speedy/./src/gpu/programs/utils.js","webpack://Speedy/./src/gpu/shader-declaration.js","webpack://Speedy/./src/gpu/shader-preprocessor.js","webpack://Speedy/./src/gpu/shaders/filters/convolution.js","webpack://Speedy//home/alexandre/projects/speedy-vision/src/gpu/shaders/include|sync|/^\\.\\/.*$/","webpack://Speedy//home/alexandre/projects/speedy-vision/src/gpu/shaders|sync|/^\\.\\/.*$/","webpack://Speedy/./src/gpu/speedy-descriptordb.js","webpack://Speedy/./src/gpu/speedy-gl.js","webpack://Speedy/./src/gpu/speedy-gpu.js","webpack://Speedy/./src/gpu/speedy-lsh.js","webpack://Speedy/./src/gpu/speedy-program-center.js","webpack://Speedy/./src/gpu/speedy-program-group.js","webpack://Speedy/./src/gpu/speedy-program.js","webpack://Speedy/./src/gpu/speedy-texture-pool.js","webpack://Speedy/./src/gpu/speedy-texture-reader.js","webpack://Speedy/./src/gpu/speedy-texture-uploader.js","webpack://Speedy/./src/gpu/speedy-texture.js","webpack://Speedy/./src/utils/errors.js","webpack://Speedy/./src/utils/fps-counter.js","webpack://Speedy/./src/utils/globals.js","webpack://Speedy/./src/utils/observable.js","webpack://Speedy/./src/utils/speedy-promise.js","webpack://Speedy/./src/utils/types.js","webpack://Speedy/./src/utils/utils.js","webpack://Speedy/./src/gpu/shaders/filters/convolution1d.glsl","webpack://Speedy/./src/gpu/shaders/filters/convolution2d.glsl","webpack://Speedy/./src/gpu/shaders/filters/fast-median.glsl","webpack://Speedy/./src/gpu/shaders/filters/nightvision.glsl","webpack://Speedy/./src/gpu/shaders/filters/normalize-image.glsl","webpack://Speedy/./src/gpu/shaders/filters/rgb2grey.glsl","webpack://Speedy/./src/gpu/shaders/include/colors.glsl","webpack://Speedy/./src/gpu/shaders/include/filters.glsl","webpack://Speedy/./src/gpu/shaders/include/fixed-point.glsl","webpack://Speedy/./src/gpu/shaders/include/float16.glsl","webpack://Speedy/./src/gpu/shaders/include/global.glsl","webpack://Speedy/./src/gpu/shaders/include/int32.glsl","webpack://Speedy/./src/gpu/shaders/include/keypoint-descriptors.glsl","webpack://Speedy/./src/gpu/shaders/include/keypoint-matches.glsl","webpack://Speedy/./src/gpu/shaders/include/keypoints.glsl","webpack://Speedy/./src/gpu/shaders/include/math.glsl","webpack://Speedy/./src/gpu/shaders/include/pyramids.glsl","webpack://Speedy/./src/gpu/shaders/include/subpixel.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/allocate-descriptors.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/allocate-extra.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/apply-homography.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/bf-knn.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/clip-border.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/clip.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/distance-filter.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/encode-keypoint-long-offsets.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/encode-keypoint-offsets.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/encode-keypoint-positions.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/encode-keypoint-properties.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/encode-keypoints.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/encode-null-keypoints.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/fast.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/fast.vs.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/hamming-distance-filter.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/harris-cutoff.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/harris.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/knn-init.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/knn-transfer.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/laplacian.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/lk.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/lookup-of-locations.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/lookup-of-locations.vs.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/lsh-knn.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/mix-keypoints.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/nonmax-scale.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/nonmax-space.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/nonmax-suppression.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/orb-descriptor.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/orb-orientation.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/refine-scale.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/score-findmax.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/shuffle.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/sort-keypoints.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/subpixel-refinement.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/transfer-flow.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/transfer-orientation.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/transfer-to-extra.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/upload-keypoints.glsl","webpack://Speedy/./src/gpu/shaders/pyramids/downsample2.glsl","webpack://Speedy/./src/gpu/shaders/pyramids/upsample2.glsl","webpack://Speedy/./src/gpu/shaders/transforms/additive-mix.glsl","webpack://Speedy/./src/gpu/shaders/transforms/resize.glsl","webpack://Speedy/./src/gpu/shaders/transforms/warp-perspective.glsl","webpack://Speedy/./src/gpu/shaders/utils/copy-components.glsl","webpack://Speedy/./src/gpu/shaders/utils/copy-raster.glsl","webpack://Speedy/./src/gpu/shaders/utils/copy.glsl","webpack://Speedy/./src/gpu/shaders/utils/fill-components.glsl","webpack://Speedy/./src/gpu/shaders/utils/fill.glsl","webpack://Speedy/./src/gpu/shaders/utils/flip-y.vs.glsl","webpack://Speedy/./src/gpu/shaders/utils/scan-minmax2d.glsl","webpack://Speedy/./src/gpu/shaders/utils/sobel-derivatives.glsl","webpack://Speedy/./src/gpu/shaders/utils/sobel-derivatives.vs.glsl","webpack://Speedy/./src/core/wasm/speedy-matrix.wasm.txt","webpack://Speedy/webpack/bootstrap","webpack://Speedy/webpack/runtime/define property getters","webpack://Speedy/webpack/runtime/hasOwnProperty shorthand","webpack://Speedy/webpack/runtime/make namespace object","webpack://Speedy/./src/main.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Speedy\"] = factory();\n\telse\n\t\troot[\"Speedy\"] = factory();\n})(self, function() {\nreturn ","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * filter-factory.js\n * Image filters\n */\n\nimport { SpeedyNamespace } from '../../speedy-namespace';\nimport { SpeedyPipelineNodeGreyscale } from '../nodes/filters/greyscale';\nimport { SpeedyPipelineNodeGaussianBlur } from '../nodes/filters/gaussian-blur';\nimport { SpeedyPipelineNodeSimpleBlur } from '../nodes/filters/simple-blur';\nimport { SpeedyPipelineNodeMedianBlur } from '../nodes/filters/median-blur';\nimport { SpeedyPipelineNodeConvolution } from '../nodes/filters/convolution';\nimport { SpeedyPipelineNodeNightvision } from '../nodes/filters/nightvision';\nimport { SpeedyPipelineNodeNormalize } from '../nodes/filters/normalize';\n\n/**\n * Image filters\n */\nexport class SpeedyPipelineFilterFactory extends SpeedyNamespace\n{\n    /**\n     * Convert image to greyscale\n     * @param {string} [name]\n     * @returns {SpeedyPipelineNodeGreyscale}\n     */\n    static Greyscale(name = undefined)\n    {\n        return new SpeedyPipelineNodeGreyscale(name);\n    }\n\n    /**\n     * Gaussian Blur\n     * @param {string} [name]\n     * @returns {SpeedyPipelineNodeGaussianBlur}\n     */\n    static GaussianBlur(name = undefined)\n    {\n        return new SpeedyPipelineNodeGaussianBlur(name);\n    }\n\n    /**\n     * Simple Blur (Box Filter)\n     * @param {string} [name]\n     * @returns {SpeedyPipelineNodeSimpleBlur}\n     */\n    static SimpleBlur(name = undefined)\n    {\n        return new SpeedyPipelineNodeSimpleBlur(name);\n    }\n\n    /**\n     * Median Blur\n     * @param {string} [name]\n     * @returns {SpeedyPipelineNodeMedianBlur}\n     */\n    static MedianBlur(name = undefined)\n    {\n        return new SpeedyPipelineNodeMedianBlur(name);\n    }\n\n    /**\n     * Image Convolution\n     * @param {string} [name]\n     * @returns {SpeedyPipelineNodeConvolution}\n     */\n    static Convolution(name = undefined)\n    {\n        return new SpeedyPipelineNodeConvolution(name);\n    }\n\n    /**\n     * Nightvision\n     * @param {string} [name]\n     * @returns {SpeedyPipelineNodeNightvision}\n     */\n    static Nightvision(name = undefined)\n    {\n        return new SpeedyPipelineNodeNightvision(name);\n    }\n\n    /**\n     * Normalize image\n     * @param {string} [name]\n     * @returns {SpeedyPipelineNodeNormalize}\n     */\n    static Normalize(name = undefined)\n    {\n        return new SpeedyPipelineNodeNormalize(name);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * image-factory.js\n * Image-related nodes\n */\n\nimport { SpeedyNamespace } from '../../speedy-namespace';\nimport { SpeedyPipelineNodeImageSource } from '../nodes/images/source';\nimport { SpeedyPipelineNodeImageSink } from '../nodes/images/sink';\nimport { SpeedyPipelineNodeImageMultiplexer } from '../nodes/images/multiplexer';\nimport { SpeedyPipelineNodeImageBuffer } from '../nodes/images/buffer';\nimport { SpeedyPipelineNodeImagePyramid } from '../nodes/images/pyramid';\nimport { SpeedyPipelineNodeImageMixer } from '../nodes/images/mixer';\nimport { SpeedyPipelineNodeImagePortalSource, SpeedyPipelineNodeImagePortalSink } from '../nodes/images/portal';\n\n/**\n * Portal nodes\n */\nexport class SpeedyPipelineImagePortalFactory extends SpeedyNamespace\n{\n    /**\n     * Create an image portal source\n     * @param {string} [name] name of the node\n     * @returns {SpeedyPipelineNodeImagePortalSource}\n     */\n    static Source(name = undefined)\n    {\n        return new SpeedyPipelineNodeImagePortalSource(name);\n    }\n\n    /**\n     * Create an image portal sink\n     * @param {string} [name] name of the node\n     * @returns {SpeedyPipelineNodeImagePortalSink}\n     */\n    static Sink(name = undefined)\n    {\n        return new SpeedyPipelineNodeImagePortalSink(name);\n    }\n}\n\n/**\n * Image nodes\n */\nexport class SpeedyPipelineImageFactory extends SpeedyNamespace\n{\n    /**\n     * Create an image source\n     * @param {string} [name] name of the node\n     * @returns {SpeedyPipelineNodeImageSource}\n     */\n    static Source(name = undefined)\n    {\n        return new SpeedyPipelineNodeImageSource(name);\n    }\n\n    /**\n     * Create an image sink\n     * @param {string} [name] name of the node\n     * @returns {SpeedyPipelineNodeImageSink}\n     */\n    static Sink(name = undefined)\n    {\n        return new SpeedyPipelineNodeImageSink(name);\n    }\n\n    /**\n     * Create an image multiplexer\n     * @param {string} [name] name of the node\n     * @returns {SpeedyPipelineNodeImageMultiplexer}\n     */\n    static Multiplexer(name = undefined)\n    {\n        return new SpeedyPipelineNodeImageMultiplexer(name);\n    }\n\n    /**\n     * Create an image buffer\n     * @param {string} [name] name of the node\n     * @returns {SpeedyPipelineNodeImageBuffer}\n     */\n    static Buffer(name = undefined)\n    {\n        return new SpeedyPipelineNodeImageBuffer(name);\n    }\n\n    /**\n     * Image Pyramid\n     * @param {string} [name] name of the node\n     * @returns {SpeedyPipelineNodeImagePyramid}\n     */\n    static Pyramid(name = undefined)\n    {\n        return new SpeedyPipelineNodeImagePyramid(name);\n    }\n\n    /**\n     * Image Mixer (blending)\n     * @param {string} [name] name of the node\n     * @returns {SpeedyPipelineNodeImageMixer}\n     */\n    static Mixer(name = undefined)\n    {\n        return new SpeedyPipelineNodeImageMixer(name);\n    }\n\n    /**\n     * Image Portals\n     * @returns {typeof SpeedyPipelineImagePortalFactory}\n     */\n    static get Portal()\n    {\n        return SpeedyPipelineImagePortalFactory;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * keypoint-factory.js\n * Keypoint-related nodes\n */\n\nimport { SpeedyNamespace } from '../../speedy-namespace';\nimport { SpeedyPipelineNodeKeypointSource } from '../nodes/keypoints/source';\nimport { SpeedyPipelineNodeKeypointSink, SpeedyPipelineNodeTrackedKeypointSink, SpeedyPipelineNodeMatchedKeypointSink } from '../nodes/keypoints/sink';\nimport { SpeedyPipelineNodeKeypointClipper } from '../nodes/keypoints/clipper';\nimport { SpeedyPipelineNodeKeypointBorderClipper } from '../nodes/keypoints/border-clipper';\nimport { SpeedyPipelineNodeKeypointBuffer } from '../nodes/keypoints/buffer';\nimport { SpeedyPipelineNodeKeypointMixer } from '../nodes/keypoints/mixer';\nimport { SpeedyPipelineNodeKeypointShuffler } from '../nodes/keypoints/shuffler';\nimport { SpeedyPipelineNodeKeypointMultiplexer } from '../nodes/keypoints/multiplexer';\nimport { SpeedyPipelineNodeKeypointTransformer } from '../nodes/keypoints/transformer';\nimport { SpeedyPipelineNodeKeypointSubpixelRefiner } from '../nodes/keypoints/subpixel';\nimport { SpeedyPipelineNodeFASTKeypointDetector } from '../nodes/keypoints/detectors/fast';\nimport { SpeedyPipelineNodeHarrisKeypointDetector } from '../nodes/keypoints/detectors/harris';\nimport { SpeedyPipelineNodeORBKeypointDescriptor } from '../nodes/keypoints/descriptors/orb';\nimport { SpeedyPipelineNodeLKKeypointTracker } from '../nodes/keypoints/trackers/lk';\nimport { SpeedyPipelineNodeStaticLSHTables } from '../nodes/keypoints/matchers/lsh-static-tables';\nimport { SpeedyPipelineNodeLSHKNNMatcher } from '../nodes/keypoints/matchers/lsh-knn';\nimport { SpeedyPipelineNodeBruteForceKNNKeypointMatcher } from '../nodes/keypoints/matchers/bf-knn';\nimport { SpeedyPipelineNodeKeypointDistanceFilter } from '../nodes/keypoints/distance-filter';\nimport { SpeedyPipelineNodeKeypointHammingDistanceFilter } from '../nodes/keypoints/hamming-distance-filter';\nimport { SpeedyPipelineNodeKeypointPortalSource, SpeedyPipelineNodeKeypointPortalSink } from '../nodes/keypoints/portal';\n\n/**\n * Keypoint detectors\n */\nclass SpeedyPipelineKeypointDetectorFactory extends SpeedyNamespace\n{\n    /**\n     * FAST corner detector\n     * @param {string} [name]\n     * @returns {SpeedyPipelineNodeFASTKeypointDetector}\n     */\n    static FAST(name = undefined)\n    {\n        return new SpeedyPipelineNodeFASTKeypointDetector(name);\n    }\n\n    /**\n     * Harris corner detector\n     * @param {string} [name]\n     * @returns {SpeedyPipelineNodeHarrisKeypointDetector}\n     */\n    static Harris(name = undefined)\n    {\n        return new SpeedyPipelineNodeHarrisKeypointDetector(name);\n    }\n}\n\n/**\n * Keypoint descriptors\n */\nclass SpeedyPipelineKeypointDescriptorFactory extends SpeedyNamespace\n{\n    /**\n     * ORB descriptors\n     * @param {string} [name]\n     * @returns {SpeedyPipelineNodeORBKeypointDescriptor}\n     */\n    static ORB(name = undefined)\n    {\n        return new SpeedyPipelineNodeORBKeypointDescriptor(name);\n    }\n}\n\n/**\n * Keypoint trackers\n */\nclass SpeedyPipelineKeypointTrackerFactory extends SpeedyNamespace\n{\n    /**\n     * LK optical-flow\n     * @param {string} [name]\n     * @returns {SpeedyPipelineNodeLKKeypointTracker}\n     */\n    static LK(name = undefined)\n    {\n        return new SpeedyPipelineNodeLKKeypointTracker(name);\n    }\n}\n\n/**\n * Keypoint matchers\n */\nclass SpeedyPipelineKeypointMatcherFactory extends SpeedyNamespace\n{\n    /**\n     * Static LSH tables\n     * @param {string} [name]\n     * @returns {SpeedyPipelineNodeStaticLSHTables}\n     */\n    static StaticLSHTables(name = undefined)\n    {\n        return new SpeedyPipelineNodeStaticLSHTables(name);\n    }\n\n    /**\n     * LSH-based K-approximate nearest neighbors\n     * @param {string} [name]\n     * @returns {SpeedyPipelineNodeLSHKNNMatcher}\n     */\n    static LSHKNN(name = undefined)\n    {\n        return new SpeedyPipelineNodeLSHKNNMatcher(name);\n    }\n\n    /**\n     * Brute-force K-nearest neighbors keypoint matcher\n     * @param {string} [name]\n     * @returns {SpeedyPipelineNodeBruteForceKNNKeypointMatcher}\n     */\n    static BFKNN(name = undefined)\n    {\n        return new SpeedyPipelineNodeBruteForceKNNKeypointMatcher(name);\n    }\n}\n\n/**\n * Portal nodes\n */\nexport class SpeedyPipelineKeypointPortalFactory extends SpeedyNamespace\n{\n    /**\n     * Create an image portal source\n     * @param {string} [name] name of the node\n     * @returns {SpeedyPipelineNodeKeypointPortalSource}\n     */\n    static Source(name = undefined)\n    {\n        return new SpeedyPipelineNodeKeypointPortalSource(name);\n    }\n\n    /**\n     * Create an image portal sink\n     * @param {string} [name] name of the node\n     * @returns {SpeedyPipelineNodeKeypointPortalSink}\n     */\n    static Sink(name = undefined)\n    {\n        return new SpeedyPipelineNodeKeypointPortalSink(name);\n    }\n}\n\n/**\n * Keypoint-related nodes\n */\nexport class SpeedyPipelineKeypointFactory extends SpeedyNamespace\n{\n    /**\n     * Keypoint detectors\n     * @returns {typeof SpeedyPipelineKeypointDetectorFactory}\n     */\n    static get Detector()\n    {\n        return SpeedyPipelineKeypointDetectorFactory;\n    }\n\n    /**\n     * Keypoint descriptors\n     * @returns {typeof SpeedyPipelineKeypointDescriptorFactory}\n     */\n    static get Descriptor()\n    {\n        return SpeedyPipelineKeypointDescriptorFactory;\n    }\n\n    /**\n     * Keypoint trackers\n     * @returns {typeof SpeedyPipelineKeypointTrackerFactory}\n     */\n    static get Tracker()\n    {\n        return SpeedyPipelineKeypointTrackerFactory;\n    }\n\n    /**\n     * Keypoint matchers\n     * @returns {typeof SpeedyPipelineKeypointMatcherFactory}\n     */\n    static get Matcher()\n    {\n        return SpeedyPipelineKeypointMatcherFactory;\n    }\n\n    /**\n     * Keypoint Portals\n     * @returns {typeof SpeedyPipelineKeypointPortalFactory}\n     */\n    static get Portal()\n    {\n        return SpeedyPipelineKeypointPortalFactory;\n    }\n\n    /**\n     * Create a keypoint source\n     * @param {string} [name]\n     * @returns {SpeedyPipelineNodeKeypointSource}\n     */\n    static Source(name = undefined)\n    {\n        return new SpeedyPipelineNodeKeypointSource(name);\n    }\n\n    /**\n     * Create a keypoint sink\n     * @param {string} [name]\n     * @returns {SpeedyPipelineNodeKeypointSink}\n     */\n    static Sink(name = undefined)\n    {\n        return new SpeedyPipelineNodeKeypointSink(name);\n    }\n\n    /**\n     * Create a sink of tracked keypoints\n     * @param {string} [name]\n     * @returns {SpeedyPipelineNodeTrackedKeypointSink}\n     */\n    static SinkOfTrackedKeypoints(name = undefined)\n    {\n        return new SpeedyPipelineNodeTrackedKeypointSink(name);\n    }\n\n    /**\n     * Create a sink of matched keypoints\n     * @param {string} [name]\n     * @returns {SpeedyPipelineNodeMatchedKeypointSink}\n     */\n    static SinkOfMatchedKeypoints(name = undefined)\n    {\n        return new SpeedyPipelineNodeMatchedKeypointSink(name);\n    }\n\n    /**\n     * Keypoint clipper\n     * @param {string} [name]\n     * @returns {SpeedyPipelineNodeKeypointClipper}\n     */\n    static Clipper(name = undefined)\n    {\n        return new SpeedyPipelineNodeKeypointClipper(name);\n    }\n\n    /**\n     * Border Clipper\n     * @param {string} [name]\n     * @returns {SpeedyPipelineNodeKeypointBorderClipper}\n     */\n    static BorderClipper(name = undefined)\n    {\n        return new SpeedyPipelineNodeKeypointBorderClipper(name);\n    }\n\n    /**\n     * Create a keypoint buffer\n     * @param {string} [name]\n     * @returns {SpeedyPipelineNodeKeypointBuffer}\n     */\n    static Buffer(name = undefined)\n    {\n        return new SpeedyPipelineNodeKeypointBuffer(name);\n    }\n\n    /**\n     * Create a keypoint mixer\n     * @param {string} [name]\n     * @returns {SpeedyPipelineNodeKeypointMixer}\n     */\n    static Mixer(name = undefined)\n    {\n        return new SpeedyPipelineNodeKeypointMixer(name);\n    }\n\n    /**\n     * Create a keypoint shuffler\n     * @param {string} [name]\n     * @returns {SpeedyPipelineNodeKeypointShuffler}\n     */\n    static Shuffler(name = undefined)\n    {\n        return new SpeedyPipelineNodeKeypointShuffler(name);\n    }\n\n    /**\n     * Create a keypoint multiplexer\n     * @param {string} [name]\n     * @returns {SpeedyPipelineNodeKeypointMultiplexer}\n     */\n    static Multiplexer(name = undefined)\n    {\n        return new SpeedyPipelineNodeKeypointMultiplexer(name);\n    }\n\n    /**\n     * Create a keypoint transformer\n     * @param {string} [name]\n     * @returns {SpeedyPipelineNodeKeypointTransformer}\n     */\n    static Transformer(name = undefined)\n    {\n        return new SpeedyPipelineNodeKeypointTransformer(name);\n    }\n\n    /**\n     * Create a subpixel refiner of keypoint locations\n     * @param {string} [name]\n     * @returns {SpeedyPipelineNodeKeypointSubpixelRefiner}\n     */\n    static SubpixelRefiner(name = undefined)\n    {\n        return new SpeedyPipelineNodeKeypointSubpixelRefiner(name);\n    }\n\n    /**\n     * Distance filter\n     * @param {string} [name]\n     * @returns {SpeedyPipelineNodeDistanceFilter}\n     */\n    static DistanceFilter(name = undefined)\n    {\n        return new SpeedyPipelineNodeKeypointDistanceFilter(name);\n    }\n\n    /**\n     * Hamming distance filter\n     * @param {string} [name]\n     * @returns {SpeedyPipelineNodeHammingDistanceFilter}\n     */\n    static HammingDistanceFilter(name = undefined)\n    {\n        return new SpeedyPipelineNodeKeypointHammingDistanceFilter(name);\n    }\n}\n","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * transform-factory.js\n * Image transforms\n */\n\nimport { SpeedyNamespace } from '../../speedy-namespace';\nimport { SpeedyPipelineNodePerspectiveWarp } from '../nodes/transforms/perspective-warp';\nimport { SpeedyPipelineNodeResize } from '../nodes/transforms/resize';\n\n/**\n * Image transforms\n */\nexport class SpeedyPipelineTransformFactory extends SpeedyNamespace\n{\n    /**\n     * Resize image\n     * @param {string} [name]\n     * @returns {SpeedyPipelineNodeResize}\n     */\n    static Resize(name = undefined)\n    {\n        return new SpeedyPipelineNodeResize(name);\n    }\n\n    /**\n     * Warp an image using a perspective transformation\n     * @param {string} [name]\n     * @returns {SpeedyPipelineNodePerspectiveWarp}\n     */\n    static PerspectiveWarp(name = undefined)\n    {\n        return new SpeedyPipelineNodePerspectiveWarp(name);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * vector2-factory.js\n * 2D vectors\n */\n\nimport { SpeedyVector2 } from '../../speedy-vector';\nimport { SpeedyPipelineNodeVector2Sink } from '../nodes/vector2/sink';\n\n/**\n * 2D vectors\n */\nexport class SpeedyPipelineVector2Factory extends Function\n{\n    /**\n     * Constructor\n     */\n    constructor()\n    {\n        // This factory can be invoked as a function\n        super('...args', 'return this._create(...args)');\n        return this.bind(this);\n    }\n\n    /**\n     * @private\n     *\n     * Create a 2D vector\n     * @param {number} x x-coordinate\n     * @param {number} y y-coordinate\n     * @returns {SpeedyVector2}\n     */\n    _create(x, y)\n    {\n        return new SpeedyVector2(x, y);\n    }\n\n    /**\n     * Create a Vector2 sink\n     * @param {string} [name]\n     * @returns {SpeedyPipelineNodeVector2Sink}\n     */\n    Sink(name = undefined)\n    {\n        return new SpeedyPipelineNodeVector2Sink(name);\n    }\n}\n","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * convolution.js\n * Image convolution\n */\n\nimport { SpeedyPipelineNode } from '../../pipeline-node';\nimport { SpeedyPipelineMessageType, SpeedyPipelineMessageWithImage } from '../../pipeline-message';\nimport { InputPort, OutputPort } from '../../pipeline-portbuilder';\nimport { SpeedyGPU } from '../../../../gpu/speedy-gpu';\nimport { SpeedyTexture } from '../../../../gpu/speedy-texture';\nimport { SpeedySize } from '../../../speedy-size';\nimport { Utils } from '../../../../utils/utils';\nimport { ImageFormat } from '../../../../utils/types';\nimport { NotSupportedError, IllegalArgumentError } from '../../../../utils/errors';\nimport { SpeedyPromise } from '../../../../utils/speedy-promise';\nimport { SpeedyMatrix } from '../../../speedy-matrix';\n\n// 2D convolution programs\nconst CONVOLUTION = {\n    3: 'convolution3',\n    5: 'convolution5',\n    7: 'convolution7',\n};\n\n/**\n * Image convolution\n */\nexport class SpeedyPipelineNodeConvolution extends SpeedyPipelineNode\n{\n    /**\n     * Constructor\n     * @param {string} [name] name of the node\n     */\n    constructor(name = undefined)\n    {\n        super(name, 1, [\n            InputPort().expects(SpeedyPipelineMessageType.Image),\n            OutputPort().expects(SpeedyPipelineMessageType.Image),\n        ]);\n\n        /** @type {SpeedyMatrix} convolution kernel (square matrix) */\n        this._kernel = SpeedyMatrix.Create(3, 3, [0, 0, 0, 0, 1, 0, 0, 0, 0]); // identity transform\n    }\n\n    /**\n     * Convolution kernel\n     * @returns {SpeedyMatrix}\n     */\n    get kernel()\n    {\n        return this._kernel;\n    }\n\n    /**\n     * Convolution kernel\n     * @param {SpeedyMatrix} kernel\n     */\n    set kernel(kernel)\n    {\n        if(kernel.rows != kernel.columns)\n            throw new NotSupportedError(`Use a square kernel`);\n        else if(!(kernel.rows == 3 || kernel.rows == 5 || kernel.rows == 7))\n            throw new NotSupportedError(`Invalid kernel size. Supported sizes: 3x3, 5x5, 7x7`);\n\n        this._kernel = kernel;\n    }\n\n    /**\n     * Run the specific task of this node\n     * @param {SpeedyGPU} gpu\n     * @returns {void|SpeedyPromise<void>}\n     */\n    _run(gpu)\n    {\n        const { image, format } = /** @type {SpeedyPipelineMessageWithImage} */ ( this.input().read() );\n        const width = image.width, height = image.height;\n        const outputTexture = this._tex[0];\n        const ksize = this._kernel.rows;\n        const conv = CONVOLUTION[ksize];\n        const kernel = this._kernel.read();\n\n        (gpu.programs.filters[conv]\n            .outputs(width, height, outputTexture)\n        )(image, kernel);\n\n        this.output().swrite(outputTexture, format);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * gaussian-blur.js\n * Gaussian Blur\n */\n\nimport { SpeedyPipelineNode } from '../../pipeline-node';\nimport { SpeedyPipelineMessageType, SpeedyPipelineMessageWithImage } from '../../pipeline-message';\nimport { InputPort, OutputPort } from '../../pipeline-portbuilder';\nimport { SpeedyGPU } from '../../../../gpu/speedy-gpu';\nimport { SpeedySize } from '../../../speedy-size';\nimport { SpeedyVector2 } from '../../../speedy-vector';\nimport { Utils } from '../../../../utils/utils';\nimport { NotSupportedError } from '../../../../utils/errors';\nimport { SpeedyPromise } from '../../../../utils/speedy-promise';\n\n/**\n * Default kernels for different sizes: 3x3, 5x5, 7x7... (use sigma_x = sigma_y)\n * Heuristics: in order to pick a sigma, we set radius = 2 * sigma. Since\n * ksize = 1 + 2 * radius, it follows that sigma = (ksize - 1) / 4. When\n * ksize is 3, we set sigma = 1. Therefore, sigma = max(1, (ksize - 1) / 4).\n */\nconst DEFAULT_KERNEL = Object.freeze({\n    3: [ 0.27901008925473514, 0.44197982149052983, 0.27901008925473514 ], // 1D convolution (sigma = 1)\n    5: [ 0.06135959781344021, 0.2447701955296099, 0.3877404133138998, 0.2447701955296099, 0.06135959781344021 ], // 1D convolution (separable kernel)\n    7: [ 0.03873542500847274, 0.11308485700794121, 0.2150068609928349, 0.26634571398150225, 0.2150068609928349, 0.11308485700794121, 0.03873542500847274 ],\n    9: [ 0.028532262603370988, 0.067234535494912, 0.12400932997922749, 0.17904386461741617, 0.20236001461014655, 0.17904386461741617, 0.12400932997922749, 0.067234535494912, 0.028532262603370988 ],\n    11:[ 0.022656882730580346, 0.04610857898527292, 0.08012661469398517, 0.11890414969751599, 0.15067709325491124, 0.16305336127546846, 0.15067709325491124, 0.11890414969751599, 0.08012661469398517, 0.04610857898527292, 0.022656882730580346 ],\n    13:[ 0.018815730430644363, 0.03447396964662016, 0.05657737457255748, 0.08317258170844948, 0.10952340502389682, 0.12918787500405662, 0.13649812722755, 0.12918787500405662, 0.10952340502389682, 0.08317258170844948, 0.05657737457255748, 0.03447396964662016, 0.018815730430644363 ],\n    15:[ 0.016100340991695383, 0.027272329212157102, 0.042598338587449644, 0.06135478775568558, 0.08148767614129326, 0.09979838342934616, 0.11270444144735056, 0.11736740487004466, 0.11270444144735056, 0.09979838342934616, 0.08148767614129326, 0.06135478775568558, 0.042598338587449644, 0.027272329212157102, 0.016100340991695383 ],\n    //3: [ 0.25, 0.5, 0.25 ],\n    //5: [ 0.05, 0.25, 0.4, 0.25, 0.05 ],\n});\n\n/** Zero vector. When we set sigma_x = sigma_y = 0, we use the default rule to compute the actual sigma */\nconst DEFAULT_SIGMA = new SpeedyVector2(0,0);\n\n/** convolution programs (x-axis) */\nconst CONVOLUTION_X = Object.freeze({\n    3: 'convolution3x',\n    5: 'convolution5x',\n    7: 'convolution7x',\n    9: 'convolution9x',\n    11: 'convolution11x',\n    13: 'convolution13x',\n    15: 'convolution15x',\n});\n\n/** convolution programs (y-axis) */\nconst CONVOLUTION_Y = Object.freeze({\n    3: 'convolution3y',\n    5: 'convolution5y',\n    7: 'convolution7y',\n    9: 'convolution9y',\n    11: 'convolution11y',\n    13: 'convolution13y',\n    15: 'convolution15y',\n});\n\n/**\n * @typedef {object} SeparableConvolutionKernel\n * @property {number[]} x\n * @property {number[]} y\n */\n\n/**\n * Gaussian Blur\n */\nexport class SpeedyPipelineNodeGaussianBlur extends SpeedyPipelineNode\n{\n    /**\n     * Constructor\n     * @param {string} [name] name of the node\n     */\n    constructor(name = undefined)\n    {\n        super(name, 2, [\n            InputPort().expects(SpeedyPipelineMessageType.Image),\n            OutputPort().expects(SpeedyPipelineMessageType.Image),\n        ]);\n\n        /** @type {SpeedySize} size of the kernel */\n        this._kernelSize = new SpeedySize(5,5);\n\n        /** @type {SpeedyVector2} sigma of the Gaussian kernel (0 means: use default settings) */\n        this._sigma = DEFAULT_SIGMA;\n\n        /** @type {SeparableConvolutionKernel} convolution kernel */\n        this._kernel = {\n            x: DEFAULT_KERNEL[this._kernelSize.width],\n            y: DEFAULT_KERNEL[this._kernelSize.height]\n        };\n    }\n\n    /**\n     * Size of the kernel\n     * @returns {SpeedySize}\n     */\n    get kernelSize()\n    {\n        return this._kernelSize;\n    }\n\n    /**\n     * Size of the kernel\n     * @param {SpeedySize} kernelSize\n     */\n    set kernelSize(kernelSize)\n    {\n        Utils.assert(kernelSize instanceof SpeedySize);\n\n        const kw = kernelSize.width, kh = kernelSize.height;\n        if(kw < 3 || kh < 3 || kw > 15 || kh > 15 || kw % 2 == 0 || kh % 2 == 0)\n            throw new NotSupportedError(`Unsupported kernel size: ${kw}x${kh}`);\n\n        this._kernelSize = kernelSize;\n        this._updateKernel();\n    }\n\n    /**\n     * Sigma of the Gaussian kernel\n     * @returns {SpeedyVector2}\n     */\n    get sigma()\n    {\n        return this._sigma;\n    }\n\n    /**\n     * Sigma of the Gaussian kernel\n     * @param {SpeedyVector2} sigma\n     */\n    set sigma(sigma)\n    {\n        Utils.assert(sigma instanceof SpeedyVector2, `Sigma must be a SpeedyVector2`);\n        Utils.assert(sigma.x >= 0 && sigma.y >= 0);\n\n        this._sigma = sigma;\n        this._updateKernel();\n    }\n\n    /**\n     * Run the specific task of this node\n     * @param {SpeedyGPU} gpu\n     * @returns {void|SpeedyPromise<void>}\n     */\n    _run(gpu)\n    {\n        const { image, format } = /** @type {SpeedyPipelineMessageWithImage} */ ( this.input().read() );\n        const width = image.width, height = image.height;\n        const kernX = this._kernel.x;\n        const kernY = this._kernel.y;\n        const convX = CONVOLUTION_X[this._kernelSize.width];\n        const convY = CONVOLUTION_Y[this._kernelSize.height];\n        const tex = this._tex[0];\n        const outputTexture = this._tex[1];\n\n        (gpu.programs.filters[convX]\n            .outputs(width, height, tex)\n        )(image, kernX);\n\n        (gpu.programs.filters[convY]\n            .outputs(width, height, outputTexture)\n        )(tex, kernY);\n\n        this.output().swrite(outputTexture, format);\n    }\n\n    /**\n     * Update the internal kernel to match\n     * sigma and kernelSize\n     */\n    _updateKernel()\n    {\n        if(this._sigma.x == DEFAULT_SIGMA.x)\n            this._kernel.x = DEFAULT_KERNEL[this._kernelSize.width];\n        else\n            this._kernel.x = Utils.gaussianKernel(this._sigma.x, this._kernelSize.width, true);\n\n        if(this._sigma.y == DEFAULT_SIGMA.y)\n            this._kernel.y = DEFAULT_KERNEL[this._kernelSize.height];\n        else\n            this._kernel.y = Utils.gaussianKernel(this._sigma.y, this._kernelSize.height, true);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * greyscale.js\n * Convert an image to greyscale\n */\n\nimport { SpeedyPipelineNode } from '../../pipeline-node';\nimport { SpeedyPipelineMessageType, SpeedyPipelineMessageWithImage } from '../../pipeline-message';\nimport { InputPort, OutputPort } from '../../pipeline-portbuilder';\nimport { SpeedyGPU } from '../../../../gpu/speedy-gpu';\nimport { SpeedyTexture } from '../../../../gpu/speedy-texture';\nimport { Utils } from '../../../../utils/utils';\nimport { ImageFormat } from '../../../../utils/types';\nimport { SpeedyPromise } from '../../../../utils/speedy-promise';\n\n/**\n * Convert an image to greyscale\n */\nexport class SpeedyPipelineNodeGreyscale extends SpeedyPipelineNode\n{\n    /**\n     * Constructor\n     * @param {string} [name] name of the node\n     */\n    constructor(name = undefined)\n    {\n        super(name, 1, [\n            InputPort().expects(SpeedyPipelineMessageType.Image),\n            OutputPort().expects(SpeedyPipelineMessageType.Image),\n        ]);\n    }\n\n    /**\n     * Run the specific task of this node\n     * @param {SpeedyGPU} gpu\n     * @returns {void|SpeedyPromise<void>}\n     */\n    _run(gpu)\n    {\n        const { image, format } = /** @type {SpeedyPipelineMessageWithImage} */ ( this.input().read() );\n        const width = image.width, height = image.height;\n        const outputTexture = this._tex[0];\n        const filters = gpu.programs.filters;\n\n        filters.rgb2grey.outputs(width, height, outputTexture);\n        filters.rgb2grey(image);\n\n        this.output().swrite(outputTexture, ImageFormat.GREY);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * median-blur.js\n * Median Blur\n */\n\nimport { SpeedyPipelineNode } from '../../pipeline-node';\nimport { SpeedyPipelineMessageType, SpeedyPipelineMessageWithImage } from '../../pipeline-message';\nimport { InputPort, OutputPort } from '../../pipeline-portbuilder';\nimport { SpeedyGPU } from '../../../../gpu/speedy-gpu';\nimport { SpeedyTexture } from '../../../../gpu/speedy-texture';\nimport { SpeedySize } from '../../../speedy-size';\nimport { Utils } from '../../../../utils/utils';\nimport { ImageFormat } from '../../../../utils/types';\nimport { NotSupportedError, NotImplementedError } from '../../../../utils/errors';\nimport { SpeedyPromise } from '../../../../utils/speedy-promise';\n\n// Median programs\nconst MEDIAN = {\n    3: 'median3',\n    5: 'median5',\n    7: 'median7',\n};\n\n/**\n * Median Blur\n */\nexport class SpeedyPipelineNodeMedianBlur extends SpeedyPipelineNode\n{\n    /**\n     * Constructor\n     * @param {string} [name] name of the node\n     */\n    constructor(name = undefined)\n    {\n        super(name, 1, [\n            InputPort().expects(SpeedyPipelineMessageType.Image).satisfying(\n                ( /** @type {SpeedyPipelineMessageWithImage} */ msg ) =>\n                    msg.format === ImageFormat.GREY\n            ),\n            OutputPort().expects(SpeedyPipelineMessageType.Image),\n        ]);\n\n        /** @type {SpeedySize} size of the kernel (assumed to be square) */\n        this._kernelSize = new SpeedySize(5,5);\n    }\n\n    /**\n     * Size of the kernel\n     * @returns {SpeedySize}\n     */\n    get kernelSize()\n    {\n        return this._kernelSize;\n    }\n\n    /**\n     * Size of the kernel\n     * @param {SpeedySize} kernelSize\n     */\n    set kernelSize(kernelSize)\n    {\n        Utils.assert(kernelSize instanceof SpeedySize);\n\n        const ksize = kernelSize.width;\n        if(!(ksize == 3 || ksize == 5 || ksize == 7))\n            throw new NotSupportedError(`Supported kernel sizes: 3x3, 5x5, 7x7`);\n        else if(kernelSize.width != kernelSize.height)\n            throw new NotSupportedError(`Use a square kernel`);\n\n        this._kernelSize = kernelSize;\n    }\n\n    /**\n     * Run the specific task of this node\n     * @param {SpeedyGPU} gpu\n     * @returns {void|SpeedyPromise<void>}\n     */\n    _run(gpu)\n    {\n        const { image, format } = /** @type {SpeedyPipelineMessageWithImage} */ ( this.input().read() );\n        const width = image.width, height = image.height;\n        const ksize = this._kernelSize.width;\n        const med = MEDIAN[ksize];\n        const outputTexture = this._tex[0];\n\n        (gpu.programs.filters[med]\n            .outputs(width, height, outputTexture)\n        )(image);\n\n        this.output().swrite(outputTexture, format);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * nightvision.js\n * Nightvision filter\n */\n\nimport { SpeedyPipelineNode } from '../../pipeline-node';\nimport { SpeedyPipelineMessageType, SpeedyPipelineMessageWithImage } from '../../pipeline-message';\nimport { InputPort, OutputPort } from '../../pipeline-portbuilder';\nimport { SpeedyGPU } from '../../../../gpu/speedy-gpu';\nimport { SpeedyTexture } from '../../../../gpu/speedy-texture';\nimport { Utils } from '../../../../utils/utils';\nimport { IllegalArgumentError } from '../../../../utils/errors';\nimport { ImageFormat, PixelComponent, ColorComponentId } from '../../../../utils/types';\nimport { SpeedyPromise } from '../../../../utils/speedy-promise';\n\n/**\n * @typedef {\"high\"|\"medium\"|\"low\"} NightvisionQualityLevel\n */\n\n/**\n * Nightvision filter: \"see in the dark\"\n */\nexport class SpeedyPipelineNodeNightvision extends SpeedyPipelineNode\n{\n    /**\n     * Constructor\n     * @param {string} [name] name of the node\n     */\n    constructor(name = undefined)\n    {\n        super(name, 3, [\n            InputPort().expects(SpeedyPipelineMessageType.Image).satisfying(\n                ( /** @type {SpeedyPipelineMessageWithImage} */ msg ) =>\n                    msg.format === ImageFormat.RGBA ||\n                    msg.format === ImageFormat.GREY\n            ),\n            OutputPort().expects(SpeedyPipelineMessageType.Image),\n        ]);\n\n        /** @type {number} a value typically in [0,1]: larger number => higher contrast */\n        this._gain = 0.5;\n\n        /** @type {number} a value typically in [0,1]: controls brightness */\n        this._offset = 0.5;\n\n        /** @type {number} gain decay, a value in [0,1] */\n        this._decay = 0.0;\n\n        /** @type {NightvisionQualityLevel} quality level */\n        this._quality = 'medium';\n    }\n\n    /**\n     * Gain, a value typically in [0,1]: larger number => higher contrast\n     * @returns {number}\n     */\n    get gain()\n    {\n        return this._gain;\n    }\n\n    /**\n     * Gain, a value typically in [0,1]: larger number => higher contrast\n     * @param {number} gain\n     */\n    set gain(gain)\n    {\n        this._gain = +gain;\n    }\n\n    /**\n     * Offset, a value typically in [0,1] that controls the brightness\n     * @returns {number}\n     */\n    get offset()\n    {\n        return this._offset;\n    }\n\n    /**\n     * Offset, a value typically in [0,1] that controls the brightness\n     * @param {number} offset\n     */\n    set offset(offset)\n    {\n        this._offset = +offset;\n    }\n\n    /**\n     * Gain decay, a value in [0,1] that controls how the gain decays from the center of the image\n     * @returns {number}\n     */\n    get decay()\n    {\n        return this._decay;\n    }\n\n    /**\n     * Gain decay, a value in [0,1] that controls how the gain decays from the center of the image\n     * @param {number} decay\n     */\n    set decay(decay)\n    {\n        this._decay = Math.max(0.0, Math.min(+decay, 1.0));\n    }\n\n    /**\n     * Quality level of the filter\n     * @returns {NightvisionQualityLevel}\n     */\n    get quality()\n    {\n        return this._quality;\n    }\n\n    /**\n     * Quality level of the filter\n     * @param {NightvisionQualityLevel} quality\n     */\n    set quality(quality)\n    {\n        if(quality === 'high' || quality === 'medium' || quality === 'low')\n            this._quality = quality;\n        else\n            throw new IllegalArgumentError(`Invalid quality level for the Nightvision filter: \"${quality}\"`);\n    }\n\n    /**\n     * Run the specific task of this node\n     * @param {SpeedyGPU} gpu\n     * @returns {void|SpeedyPromise<void>}\n     */\n    _run(gpu)\n    {\n        const { image, format } = /** @type {SpeedyPipelineMessageWithImage} */ ( this.input().read() );\n        const width = image.width, height = image.height;\n        const gain = this._gain;\n        const offset = this._offset;\n        const decay = this._decay;\n        const quality = this._quality;\n        const filters = gpu.programs.filters;\n        const tmp = this._tex[0];\n        const illuminationMap = this._tex[1];\n        const outputTexture = this._tex[2];\n\n        // compute illumination map\n        if(quality == 'medium') {\n            filters.illuminationMapX.outputs(width, height, tmp);\n            filters.illuminationMapY.outputs(width, height, illuminationMap);\n            filters.illuminationMapX(image);\n            filters.illuminationMapY(tmp);\n        }\n        else if(quality == 'high') {\n            filters.illuminationMapHiX.outputs(width, height, tmp);\n            filters.illuminationMapHiY.outputs(width, height, illuminationMap);\n            filters.illuminationMapHiX(image);\n            filters.illuminationMapHiY(tmp);\n        }\n        else if(quality == 'low') {\n            filters.illuminationMapLoX.outputs(width, height, tmp);\n            filters.illuminationMapLoY.outputs(width, height, illuminationMap);\n            filters.illuminationMapLoX(image);\n            filters.illuminationMapLoY(tmp);\n        }\n\n        // run nightvision\n        if(format === ImageFormat.GREY) {\n            filters.nightvisionGreyscale.outputs(width, height, outputTexture);\n            filters.nightvisionGreyscale(image, illuminationMap, gain, offset, decay);\n        }\n        else if(format === ImageFormat.RGBA) {\n            filters.nightvision.outputs(width, height, outputTexture);\n            filters.nightvision(image, illuminationMap, gain, offset, decay);\n        }\n\n        // done!\n        this.output().swrite(outputTexture, format);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * normalize.js\n * Normalize image to a range\n */\n\nimport { SpeedyPipelineNode } from '../../pipeline-node';\nimport { SpeedyPipelineMessageType, SpeedyPipelineMessageWithImage } from '../../pipeline-message';\nimport { InputPort, OutputPort } from '../../pipeline-portbuilder';\nimport { SpeedyGPU } from '../../../../gpu/speedy-gpu';\nimport { SpeedyTexture, SpeedyDrawableTexture } from '../../../../gpu/speedy-texture';\nimport { Utils } from '../../../../utils/utils';\nimport { ImageFormat, PixelComponent, ColorComponentId } from '../../../../utils/types';\nimport { SpeedyPromise } from '../../../../utils/speedy-promise';\n\n/**\n * Normalize image to a range\n */\nexport class SpeedyPipelineNodeNormalize extends SpeedyPipelineNode\n{\n    /**\n     * Constructor\n     * @param {string} [name] name of the node\n     */\n    constructor(name = undefined)\n    {\n        super(name, 4, [\n            InputPort().expects(SpeedyPipelineMessageType.Image).satisfying(\n                ( /** @type {SpeedyPipelineMessageWithImage} */ msg ) =>\n                    msg.format === ImageFormat.GREY\n            ),\n            OutputPort().expects(SpeedyPipelineMessageType.Image),\n        ]);\n\n        /** @type {number} a value in [0,255] */\n        this._minValue = 0;\n\n        /** @type {number} a value in [0,255] */\n        this._maxValue = 255;\n    }\n\n    /**\n     * Minimum intensity in the output image, a value in [0,255]\n     * @returns {number}\n     */\n    get minValue()\n    {\n        return this._minValue;\n    }\n\n    /**\n     * Minimum intensity in the output image, a value in [0,255]\n     * @param {number} minValue\n     */\n    set minValue(minValue)\n    {\n        this._minValue = Math.max(0, Math.min(+minValue, 255));\n    }\n\n    /**\n     * Maximum intensity in the output image, a value in [0,255]\n     * @returns {number}\n     */\n    get maxValue()\n    {\n        return this._maxValue;\n    }\n\n    /**\n     * Maximum intensity in the output image, a value in [0,255]\n     * @param {number} maxValue\n     */\n    set maxValue(maxValue)\n    {\n        this._maxValue = Math.max(0, Math.min(+maxValue, 255));\n    }\n\n    /**\n     * Run the specific task of this node\n     * @param {SpeedyGPU} gpu\n     * @returns {void|SpeedyPromise<void>}\n     */\n    _run(gpu)\n    {\n        const { image, format } = /** @type {SpeedyPipelineMessageWithImage} */ ( this.input().read() );\n        const width = image.width, height = image.height;\n        const outputTexture = this._tex[3];\n        let minValue = this._minValue;\n        let maxValue = this._maxValue;\n\n        if(minValue > maxValue)\n            minValue = maxValue = (minValue + maxValue) / 2;\n\n        const minmax = this._scanMinMax(gpu, image, PixelComponent.GREEN);\n        gpu.programs.filters.normalizeGreyscale.outputs(width, height, outputTexture);\n        gpu.programs.filters.normalizeGreyscale(minmax, minValue, maxValue);\n\n        this.output().swrite(outputTexture, format);\n    }\n\n    /**\n     * Scan a single component in all pixels of the image and find the min & max intensities\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyTexture} image input image\n     * @param {PixelComponent} pixelComponent a single PixelComponent flag\n     * @returns {SpeedyDrawableTexture} RGBA = (max, min, max - min, original_pixel)\n     */\n    _scanMinMax(gpu, image, pixelComponent)\n    {\n        const tex = this._tex;\n        const program = gpu.programs.utils;\n        const width = image.width, height = image.height;\n        const numIterations = Math.ceil(Math.log2(Math.max(width, height))) | 0;\n\n        Utils.assert(ColorComponentId[pixelComponent] !== undefined);\n\n        program.copyComponents.outputs(width, height, tex[2]);\n        program.scanMinMax2D.outputs(width, height, tex[0], tex[1]);\n        \n        let texture = program.copyComponents(image, image, PixelComponent.ALL, ColorComponentId[pixelComponent]);\n        for(let i = 0; i < numIterations; i++)\n            texture = program.scanMinMax2D(texture, i);\n\n        return texture;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * simple-blur.js\n * Simple Blur (Box Filter)\n */\n\nimport { SpeedyPipelineNode } from '../../pipeline-node';\nimport { SpeedyPipelineMessageType, SpeedyPipelineMessageWithImage } from '../../pipeline-message';\nimport { InputPort, OutputPort } from '../../pipeline-portbuilder';\nimport { SpeedyGPU } from '../../../../gpu/speedy-gpu';\nimport { SpeedyTexture } from '../../../../gpu/speedy-texture';\nimport { SpeedySize } from '../../../speedy-size';\nimport { Utils } from '../../../../utils/utils';\nimport { ImageFormat } from '../../../../utils/types';\nimport { NotSupportedError, NotImplementedError } from '../../../../utils/errors';\nimport { SpeedyPromise } from '../../../../utils/speedy-promise';\n\n/** 1D convolution filters */\nconst BOX_FILTER = Object.freeze({\n    3: (new Array(3)).fill(1/3),\n    5: (new Array(5)).fill(1/5),\n    7: (new Array(7)).fill(1/7),\n    9: (new Array(9)).fill(1/9),\n    11: (new Array(11)).fill(1/11),\n    13: (new Array(13)).fill(1/13),\n    15: (new Array(15)).fill(1/15),\n});\n\n/** convolution programs (x-axis) */\nconst CONVOLUTION_X = Object.freeze({\n    3: 'convolution3x',\n    5: 'convolution5x',\n    7: 'convolution7x',\n    9: 'convolution9x',\n    11: 'convolution11x',\n    13: 'convolution13x',\n    15: 'convolution15x',\n});\n\n/** convolution programs (y-axis) */\nconst CONVOLUTION_Y = Object.freeze({\n    3: 'convolution3y',\n    5: 'convolution5y',\n    7: 'convolution7y',\n    9: 'convolution9y',\n    11: 'convolution11y',\n    13: 'convolution13y',\n    15: 'convolution15y',\n});\n\n/**\n * @typedef {object} SeparableConvolutionKernel\n * @property {number[]} x\n * @property {number[]} y\n */\n\n/**\n * Simple Blur (Box Filter)\n */\nexport class SpeedyPipelineNodeSimpleBlur extends SpeedyPipelineNode\n{\n    /**\n     * Constructor\n     * @param {string} [name] name of the node\n     */\n    constructor(name = undefined)\n    {\n        super(name, 2, [\n            InputPort().expects(SpeedyPipelineMessageType.Image),\n            OutputPort().expects(SpeedyPipelineMessageType.Image),\n        ]);\n\n        /** @type {SpeedySize} size of the kernel */\n        this._kernelSize = new SpeedySize(5,5);\n\n        /** @type {SeparableConvolutionKernel} convolution kernel */\n        this._kernel = {\n            x: BOX_FILTER[this._kernelSize.width],\n            y: BOX_FILTER[this._kernelSize.height]\n        };\n    }\n\n    /**\n     * Size of the kernel\n     * @returns {SpeedySize}\n     */\n    get kernelSize()\n    {\n        return this._kernelSize;\n    }\n\n    /**\n     * Size of the kernel\n     * @param {SpeedySize} kernelSize\n     */\n    set kernelSize(kernelSize)\n    {\n        Utils.assert(kernelSize instanceof SpeedySize);\n\n        const kw = kernelSize.width, kh = kernelSize.height;\n        if(kw < 3 || kh < 3 || kw > 15 || kh > 15 || kw % 2 == 0 || kh % 2 == 0)\n            throw new NotSupportedError(`Unsupported kernel size: ${kw}x${kh}`);\n\n        this._kernelSize = kernelSize;\n        this._kernel.x = BOX_FILTER[this._kernelSize.width];\n        this._kernel.y = BOX_FILTER[this._kernelSize.height];\n    }\n\n    /**\n     * Run the specific task of this node\n     * @param {SpeedyGPU} gpu\n     * @returns {void|SpeedyPromise<void>}\n     */\n    _run(gpu)\n    {\n        const { image, format } = /** @type {SpeedyPipelineMessageWithImage} */ ( this.input().read() );\n        const width = image.width, height = image.height;\n        const kernX = this._kernel.x;\n        const kernY = this._kernel.y;\n        const convX = CONVOLUTION_X[this._kernelSize.width];\n        const convY = CONVOLUTION_Y[this._kernelSize.height];\n        const tex = this._tex[0];\n        const outputTexture = this._tex[1];\n\n        (gpu.programs.filters[convX]\n            .outputs(width, height, tex)\n        )(image, kernX);\n\n        (gpu.programs.filters[convY]\n            .outputs(width, height, outputTexture)\n        )(tex, kernY);\n\n        this.output().swrite(outputTexture, format);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * buffer.js\n * Image Buffer\n */\n\nimport { SpeedyPipelineNode } from '../../pipeline-node';\nimport { SpeedyPipelineMessageType, SpeedyPipelineMessageWithImage } from '../../pipeline-message';\nimport { InputPort, OutputPort } from '../../pipeline-portbuilder';\nimport { ImageFormat } from '../../../../utils/types';\nimport { SpeedyGPU } from '../../../../gpu/speedy-gpu';\nimport { SpeedyTexture } from '../../../../gpu/speedy-texture';\nimport { Utils } from '../../../../utils/utils';\nimport { NotSupportedError } from '../../../../utils/errors';\nimport { SpeedyPromise } from '../../../../utils/speedy-promise';\n\n\n\n/**\n * Image Buffer: a node with memory.\n * At time t, it outputs the image received at time t-1\n */\nexport class SpeedyPipelineNodeImageBuffer extends SpeedyPipelineNode\n{\n    /**\n     * Constructor\n     * @param {string} [name] name of the node\n     */\n    constructor(name = undefined)\n    {\n        super(name, 2, [\n            InputPort().expects(SpeedyPipelineMessageType.Image),\n            OutputPort().expects(SpeedyPipelineMessageType.Image)\n        ]);\n\n        /** @type {number} current page: 0 or 1 */\n        this._pageIndex = 0;\n\n        /** @type {boolean} first run? */\n        this._initialized = false;\n\n        /** @type {ImageFormat} previous image format */\n        this._previousFormat = ImageFormat.RGBA;\n\n        /** @type {boolean} frozen buffer? */\n        this._frozen = false;\n    }\n\n    /**\n     * A frozen buffer discards the input, effectively increasing the buffering time\n     * @returns {boolean}\n     */\n    get frozen()\n    {\n        return this._frozen;\n    }\n\n    /**\n     * A frozen buffer discards the input, effectively increasing the buffering time\n     * @param {boolean} value\n     */\n    set frozen(value)\n    {\n        this._frozen = Boolean(value);\n    }\n\n    /**\n     * Releases this node\n     * @param {SpeedyGPU} gpu\n     */\n    release(gpu)\n    {\n        this._initialized = false;\n        super.release(gpu);\n    }\n\n    /**\n     * Run the specific task of this node\n     * @param {SpeedyGPU} gpu\n     * @returns {void|SpeedyPromise<void>}\n     */\n    _run(gpu)\n    {\n        const { image, format } = /** @type {SpeedyPipelineMessageWithImage} */ ( this.input().read() );\n        const previousFormat = this._previousFormat;\n        const page = this._tex;\n        const previousInputTexture = page[1 - this._pageIndex];\n        const outputTexture = page[this._pageIndex];\n\n        // can't store pyramids\n        if(image.hasMipmaps())\n            throw new NotSupportedError(`${this.fullName} can't bufferize a pyramid`);\n\n        // bufferize\n        if(!this._frozen || !this._initialized) {\n            // store input\n            this._previousFormat = format;\n            previousInputTexture.resize(image.width, image.height);\n            image.copyTo(previousInputTexture);\n\n            // page flipping\n            this._pageIndex = 1 - this._pageIndex;\n        }\n\n        // first run?\n        if(!this._initialized) {\n            this._initialized = true;\n            this.output().swrite(previousInputTexture, format);\n            return;\n        }\n\n        // done!\n        this.output().swrite(outputTexture, previousFormat);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * mixer.js\n * Image Mixer\n */\n\nimport { SpeedyPipelineNode } from '../../pipeline-node';\nimport { SpeedyPipelineMessageType, SpeedyPipelineMessageWithImage } from '../../pipeline-message';\nimport { InputPort, OutputPort } from '../../pipeline-portbuilder';\nimport { SpeedyGPU } from '../../../../gpu/speedy-gpu';\nimport { SpeedyTexture } from '../../../../gpu/speedy-texture';\nimport { Utils } from '../../../../utils/utils';\nimport { ImageFormat } from '../../../../utils/types';\nimport { SpeedyPromise } from '../../../../utils/speedy-promise';\nimport { NotSupportedError } from '../../../../utils/errors';\n\n/**\n * Image Mixer\n */\nexport class SpeedyPipelineNodeImageMixer extends SpeedyPipelineNode\n{\n    /**\n     * Constructor\n     * @param {string} [name] name of the node\n     */\n    constructor(name = undefined)\n    {\n        super(name, 1, [\n            InputPort('in0').expects(SpeedyPipelineMessageType.Image),\n            InputPort('in1').expects(SpeedyPipelineMessageType.Image),\n            OutputPort().expects(SpeedyPipelineMessageType.Image),\n        ]);\n\n        /** @type {number} alpha coefficient (applied to image0) */\n        this._alpha = 0.5;\n\n        /** @type {number} beta coefficient (applied to image1) */\n        this._beta = 0.5;\n\n        /** @type {number} gamma coefficient (brightness control) */\n        this._gamma = 0.0;\n    }\n\n    /**\n     * Alpha coefficient (applied to image0)\n     * @returns {number}\n     */\n    get alpha()\n    {\n        return this._alpha;\n    }\n\n    /**\n     * Alpha coefficient (applied to image0)\n     * @param {number} value\n     */\n    set alpha(value)\n    {\n        this._alpha = +value;\n    }\n\n    /**\n     * Beta coefficient (applied to image1)\n     * @returns {number}\n     */\n    get beta()\n    {\n        return this._beta;\n    }\n\n    /**\n     * Beta coefficient (applied to image1)\n     * @param {number} value\n     */\n    set beta(value)\n    {\n        this._beta = +value;\n    }\n\n    /**\n     * Gamma coefficient (brightness control)\n     * @returns {number}\n     */\n    get gamma()\n    {\n        return this._gamma;\n    }\n\n    /**\n     * Gamma coefficient (brightness control)\n     * @param {number} value\n     */\n    set gamma(value)\n    {\n        this._gamma = +value;\n    }\n\n    /**\n     * Run the specific task of this node\n     * @param {SpeedyGPU} gpu\n     * @returns {void|SpeedyPromise<void>}\n     */\n    _run(gpu)\n    {\n        const in0 = /** @type {SpeedyPipelineMessageWithImage} */ ( this.input('in0').read() );\n        const in1 = /** @type {SpeedyPipelineMessageWithImage} */ ( this.input('in1').read() );\n        const image0 = in0.image, image1 = in1.image;\n        const format0 = in0.format, format1 = in1.format;\n        const width = Math.max(image0.width, image1.width);\n        const height = Math.max(image0.height, image1.height);\n        const alpha = this._alpha, beta = this._beta, gamma = this._gamma;\n        const outputTexture = this._tex[0];\n\n        if(format0 != format1)\n            throw new NotSupportedError(`Can't mix images of different formats`);\n\n        gpu.programs.transforms.additiveMix.outputs(width, height, outputTexture);\n        gpu.programs.transforms.additiveMix(image0, image1, alpha, beta, gamma);\n\n        this.output().swrite(outputTexture, format0);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * multiplexer.js\n * Image multiplexer\n */\n\nimport { SpeedyPipelineNode, SpeedyPipelineSourceNode } from '../../pipeline-node';\nimport { SpeedyPipelineMessageType, SpeedyPipelineMessageWithImage } from '../../pipeline-message';\nimport { InputPort, OutputPort } from '../../pipeline-portbuilder';\nimport { SpeedyGPU } from '../../../../gpu/speedy-gpu';\nimport { SpeedyTexture } from '../../../../gpu/speedy-texture';\nimport { SpeedyMedia } from '../../../speedy-media';\nimport { Utils } from '../../../../utils/utils';\nimport { IllegalArgumentError } from '../../../../utils/errors';\nimport { SpeedyPromise } from '../../../../utils/speedy-promise';\n\n/** @type {string[]} the names of the input ports indexed by their number */\nconst INPUT_PORT = [ 'in0', 'in1' ];\n\n/**\n * Image multiplexer\n */\nexport class SpeedyPipelineNodeImageMultiplexer extends SpeedyPipelineNode\n{\n    /**\n     * Constructor\n     * @param {string} [name] name of the node\n     */\n    constructor(name = undefined)\n    {\n        super(name, 0, [\n            ...(INPUT_PORT.map(portName => InputPort(portName).expects(SpeedyPipelineMessageType.Image))),\n            OutputPort().expects(SpeedyPipelineMessageType.Image),\n        ]);\n\n        /** @type {number} which port should be linked to the output? */\n        this._port = 0;\n    }\n\n    /**\n     * The number of the port that should be linked to the output\n     * @returns {number}\n     */\n    get port()\n    {\n        return this._port;\n    }\n\n    /**\n     * The number of the port that should be linked to the output\n     * @param {number} port\n     */\n    set port(port)\n    {\n        if(port < 0 || port >= INPUT_PORT.length)\n            throw new IllegalArgumentError(`Invalid port: ${port}`);\n\n        this._port = port | 0;\n    }\n\n    /**\n     * Run the specific task of this node\n     * @param {SpeedyGPU} gpu\n     * @returns {void|SpeedyPromise<void>}\n     */\n    _run(gpu)\n    {\n        const message = this.input(INPUT_PORT[this._port]).read();\n\n        this.output().write(message);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * portal.js\n * Image Portals\n */\n\nimport { SpeedyPipelineNode, SpeedyPipelineSourceNode } from '../../pipeline-node';\nimport { SpeedyPipelineMessageType, SpeedyPipelineMessageWithImage } from '../../pipeline-message';\nimport { InputPort, OutputPort } from '../../pipeline-portbuilder';\nimport { ImageFormat } from '../../../../utils/types';\nimport { SpeedyGPU } from '../../../../gpu/speedy-gpu';\nimport { SpeedyTexture } from '../../../../gpu/speedy-texture';\nimport { Utils } from '../../../../utils/utils';\nimport { NotSupportedError, IllegalOperationError, IllegalArgumentError } from '../../../../utils/errors';\nimport { SpeedyPromise } from '../../../../utils/speedy-promise';\n\n\n\n/**\n * A sink of an Image Portal\n * This is not a pipeline sink - it doesn't export any data!\n */\nexport class SpeedyPipelineNodeImagePortalSink extends SpeedyPipelineNode\n{\n    /**\n     * Constructor\n     * @param {string} [name] name of the node\n     */\n    constructor(name = undefined)\n    {\n        super(name, 1, [\n            InputPort().expects(SpeedyPipelineMessageType.Image),\n        ]);\n\n        /** @type {ImageFormat} stored image format */\n        this._format = ImageFormat.RGBA;\n\n        /** @type {boolean} is this node initialized? */\n        this._initialized = false;\n    }\n\n    /**\n     * Stored image\n     * @returns {SpeedyTexture}\n     */\n    get image()\n    {\n        if(!this._initialized)\n            throw new IllegalOperationError(`Portal error: ${this.fullName} holds no data`);\n\n        return this._tex[0];\n    }\n\n    /**\n     * Stored image format\n     * @returns {ImageFormat}\n     */\n    get format()\n    {\n        if(!this._initialized)\n            throw new IllegalOperationError(`Portal error: ${this.fullName} holds no data`);\n\n        return this._format;\n    }\n\n    /**\n     * Initializes this node\n     * @param {SpeedyGPU} gpu\n     */\n    init(gpu)\n    {\n        super.init(gpu);\n\n        this._tex[0].resize(1, 1).clear(); // initial texture\n        this._format = ImageFormat.RGBA;\n\n        this._initialized = true;\n    }\n\n    /**\n     * Releases this node\n     * @param {SpeedyGPU} gpu\n     */\n    release(gpu)\n    {\n        this._initialized = false;\n        super.release(gpu);\n    }\n\n    /**\n     * Run the specific task of this node\n     * @param {SpeedyGPU} gpu\n     * @returns {void|SpeedyPromise<void>}\n     */\n    _run(gpu)\n    {\n        const { image, format } = /** @type {SpeedyPipelineMessageWithImage} */ ( this.input().read() );\n        const tex = this._tex[0];\n\n        // can't store pyramids\n        if(image.hasMipmaps())\n            throw new NotSupportedError(`${this.fullName} can't store a pyramid`);\n\n        // copy input\n        this._format = format;\n        tex.resize(image.width, image.height);\n        image.copyTo(tex);\n    }\n}\n\n\n\n/**\n * A source of an Image Portal\n */\nexport class SpeedyPipelineNodeImagePortalSource extends SpeedyPipelineSourceNode\n{\n    /**\n     * Constructor\n     * @param {string} [name] name of the node\n     */\n    constructor(name = undefined)\n    {\n        super(name, 0, [\n            OutputPort().expects(SpeedyPipelineMessageType.Image),\n        ]);\n\n        /** @type {SpeedyPipelineNodeImagePortalSink|null} portal sink */\n        this._source = null;\n    }\n\n    /**\n     * Data source\n     * @returns {SpeedyPipelineNodeImagePortalSink|null}\n     */\n    get source()\n    {\n        return this._source;\n    }\n\n    /**\n     * Data source\n     * @param {SpeedyPipelineNodeImagePortalSink|null} node\n     */\n    set source(node)\n    {\n        if(node !== null && !(node instanceof SpeedyPipelineNodeImagePortalSink))\n            throw new IllegalArgumentError(`Incompatible source for ${this.fullName}`);\n\n        this._source = node;\n    }\n\n    /**\n     * Run the specific task of this node\n     * @param {SpeedyGPU} gpu\n     * @returns {void|SpeedyPromise<void>}\n     */\n    _run(gpu)\n    {\n        if(this._source == null)\n            throw new IllegalOperationError(`${this.fullName} has no source`);\n\n        this.output().swrite(this._source.image, this._source.format);\n    }\n}\n","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * pyramid.js\n * Generate pyramid\n */\n\nimport { SpeedyPipelineNode } from '../../pipeline-node';\nimport { SpeedyPipelineMessageType, SpeedyPipelineMessageWithImage } from '../../pipeline-message';\nimport { InputPort, OutputPort } from '../../pipeline-portbuilder';\nimport { SpeedyGPU } from '../../../../gpu/speedy-gpu';\nimport { SpeedyTexture } from '../../../../gpu/speedy-texture';\nimport { Utils } from '../../../../utils/utils';\nimport { PYRAMID_MAX_LEVELS } from '../../../../utils/globals';\nimport { ImageFormat } from '../../../../utils/types';\nimport { SpeedyPromise } from '../../../../utils/speedy-promise';\n\n// Constants\nconst MAX_LEVELS = PYRAMID_MAX_LEVELS; //14; // supposing image size <= 8K = 2^13 (downto 1)\nconst MAX_TEXTURES = 2 * MAX_LEVELS; //MAX_LEVELS;\n\n/**\n * Generate pyramid\n */\nexport class SpeedyPipelineNodeImagePyramid extends SpeedyPipelineNode\n{\n    /**\n     * Constructor\n     * @param {string} [name] name of the node\n     */\n    constructor(name = undefined)\n    {\n        super(name, MAX_TEXTURES + 1, [\n            InputPort().expects(SpeedyPipelineMessageType.Image),\n            OutputPort().expects(SpeedyPipelineMessageType.Image),\n        ]);\n    }\n\n    /**\n     * Run the specific task of this node\n     * @param {SpeedyGPU} gpu\n     * @returns {void|SpeedyPromise<void>}\n     */\n    _run(gpu)\n    {\n        const { image, format } = /** @type {SpeedyPipelineMessageWithImage} */ ( this.input().read() );\n        const outputTexture = this._tex[0];\n        const pyramids = gpu.programs.pyramids;\n        let width = image.width, height = image.height;\n\n        // number of mipmap levels according to the OpenGL ES 3.0 spec (sec 3.8.10.4)\n        const mipLevels = 1 + Math.floor(Math.log2(Math.max(width, height)));\n\n        // get work textures\n        const mip = new Array(MAX_TEXTURES + 1);\n        for(let i = MAX_TEXTURES; i >= 1; i--)\n            mip[i-1] = this._tex[i];\n\n        // get a copy of the input image\n        mip[0].resize(width, height);\n        image.copyTo(mip[0]);\n\n        // generate gaussian pyramid\n        const numLevels = Math.min(mipLevels, MAX_LEVELS);\n        for(let level = 1; level < numLevels; level++) {\n            // use max(1, floor(size / 2^lod)), in accordance to\n            // the OpenGL ES 3.0 spec sec 3.8.10.4 (Mipmapping)\n            const halfWidth = Math.max(1, width >>> 1);\n            const halfHeight = Math.max(1, height >>> 1);\n\n            // reduce operation\n            const tmp = (level - 1) + MAX_LEVELS;\n            (pyramids.smoothX.outputs(width, height, mip[tmp]))(mip[level-1]);\n            (pyramids.smoothY.outputs(width, height, mip[level-1]))(mip[tmp]);\n            (pyramids.downsample2.outputs(halfWidth, halfHeight, mip[level]))(mip[level-1]);\n            /*\n            (pyramids.reduce.outputs(width, height, mip[tmp]))(mip[level-1]);\n            (pyramids.downsample2.outputs(halfWidth, halfHeight, mip[level]))(mip[tmp]);\n            */\n\n            // flush\n            gpu.gl.flush();\n\n            // next level\n            width = halfWidth;\n            height = halfHeight;\n\n            /*\n            // debug: view pyramid\n            const view = mip[level-1];\n            const canvas = gpu.renderToCanvas(view);\n            if(!window._ww) document.body.appendChild(canvas);\n            window._ww = 1;\n            */\n        }\n\n        // copy to output & set mipmap\n        outputTexture.resize(image.width, image.height);\n        outputTexture.clear();\n        image.copyTo(outputTexture);\n        outputTexture.generateMipmaps(mip.slice(0, numLevels));\n\n        // done!\n        this.output().swrite(outputTexture, format);\n    }\n}\n","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * image-output.js\n * Gets an image out of a pipeline\n */\n\nimport { SpeedyPipelineNode, SpeedyPipelineSinkNode } from '../../pipeline-node';\nimport { SpeedyPipelineMessageType, SpeedyPipelineMessageWithImage } from '../../pipeline-message';\nimport { InputPort, OutputPort } from '../../pipeline-portbuilder';\nimport { SpeedyGPU } from '../../../../gpu/speedy-gpu';\nimport { SpeedyTexture } from '../../../../gpu/speedy-texture';\nimport { SpeedyMedia } from '../../../speedy-media';\nimport { SpeedyMediaSource } from '../../../speedy-media-source';\nimport { Utils } from '../../../../utils/utils';\nimport { ImageFormat } from '../../../../utils/types';\nimport { SpeedyPromise } from '../../../../utils/speedy-promise';\n\n/**\n * Gets an image out of a pipeline\n */\nexport class SpeedyPipelineNodeImageSink extends SpeedyPipelineSinkNode\n{\n    /**\n     * Constructor\n     * @param {string} [name] name of the node\n     */\n    constructor(name = 'image')\n    {\n        super(name, 0, [\n            InputPort().expects(SpeedyPipelineMessageType.Image)\n        ]);\n\n        /** @type {ImageBitmap} output bitmap */\n        this._bitmap = null;\n\n        /** @type {ImageFormat} output format */\n        this._format = ImageFormat.RGBA;\n    }\n\n    /**\n     * Export data from this node to the user\n     * @returns {SpeedyPromise<SpeedyMedia>}\n     */\n    export()\n    {\n        Utils.assert(this._bitmap != null);\n        return SpeedyMedia.load(this._bitmap, { format: this._format }, false);\n    }\n\n    /**\n     * Run the specific task of this node\n     * @param {SpeedyGPU} gpu\n     * @returns {void|SpeedyPromise<void>}\n     */\n    _run(gpu)\n    {\n        const { image, format } = /** @type {SpeedyPipelineMessageWithImage} */ ( this.input().read() );\n\n        return new SpeedyPromise(resolve => {\n            const canvas = gpu.renderToCanvas(image);\n            createImageBitmap(canvas, 0, canvas.height - image.height, image.width, image.height).then(bitmap => {\n                this._bitmap = bitmap;\n                this._format = format;\n                resolve();\n            });\n        });\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * image-input.js\n * Gets an image into a pipeline\n */\n\nimport { SpeedyPipelineNode, SpeedyPipelineSourceNode } from '../../pipeline-node';\nimport { SpeedyPipelineMessageType, SpeedyPipelineMessageWithImage } from '../../pipeline-message';\nimport { InputPort, OutputPort } from '../../pipeline-portbuilder';\nimport { SpeedyGPU } from '../../../../gpu/speedy-gpu';\nimport { SpeedyTexture } from '../../../../gpu/speedy-texture';\nimport { SpeedyMedia } from '../../../speedy-media';\nimport { Utils } from '../../../../utils/utils';\nimport { ImageFormat } from '../../../../utils/types';\nimport { IllegalArgumentError, IllegalOperationError } from '../../../../utils/errors';\nimport { SpeedyPromise } from '../../../../utils/speedy-promise';\n\n// Constants\nconst UPLOAD_BUFFER_SIZE = 2; // how many textures we allocate for uploading data\n\n/**\n * Gets an image into a pipeline\n */\nexport class SpeedyPipelineNodeImageSource extends SpeedyPipelineSourceNode\n{\n    /**\n     * Constructor\n     * @param {string} [name] name of the node\n     */\n    constructor(name = undefined)\n    {\n        super(name, UPLOAD_BUFFER_SIZE, [\n            OutputPort().expects(SpeedyPipelineMessageType.Image)\n        ]);\n\n        /** @type {SpeedyMedia|null} source media */\n        this._media = null;\n\n        /** @type {number} texture index */\n        this._textureIndex = 0;\n    }\n\n    /**\n     * Source media\n     * @returns {SpeedyMedia|null}\n     */\n    get media()\n    {\n        return this._media;\n    }\n\n    /**\n     * Source media\n     * @param {SpeedyMedia|null} media\n     */\n    set media(media)\n    {\n        if(media !== null && !(media instanceof SpeedyMedia))\n            throw new IllegalArgumentError(`Not a SpeedyMedia: ${media}`);\n\n        this._media = media;\n    }\n\n    /**\n     * Run the specific task of this node\n     * @param {SpeedyGPU} gpu\n     * @returns {void|SpeedyPromise<void>}\n     */\n    _run(gpu)\n    {\n        if(this._media == null)\n            throw new IllegalOperationError(`Did you forget to set the media of ${this.fullName}?`);\n\n        // use round-robin to mitigate WebGL's implicit synchronization\n        // and maybe minimize texture upload times\n        this._textureIndex = (this._textureIndex + 1) % this._tex.length;\n\n        // upload texture\n        const outputTexture = this._tex[this._textureIndex];\n        gpu.upload(this._media._source, outputTexture);\n        this.output().swrite(outputTexture, this._media._format);\n    }\n}\n","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * border-clipper.js\n * Keypoint Border Clipper\n */\n\nimport { SpeedyPipelineNode } from '../../pipeline-node';\nimport { SpeedyPipelineNodeKeypointDetector } from './detectors/detector';\nimport { SpeedyPipelineMessageType, SpeedyPipelineMessageWithKeypoints } from '../../pipeline-message';\nimport { InputPort, OutputPort } from '../../pipeline-portbuilder';\nimport { SpeedyGPU } from '../../../../gpu/speedy-gpu';\nimport { SpeedySize } from '../../../speedy-size';\nimport { SpeedyVector2 } from '../../../speedy-vector';\nimport { SpeedyTexture } from '../../../../gpu/speedy-texture';\nimport { Utils } from '../../../../utils/utils';\nimport { IllegalOperationError } from '../../../../utils/errors';\nimport { MAX_ENCODER_CAPACITY } from '../../../../utils/globals';\nimport { SpeedyPromise } from '../../../../utils/speedy-promise';\n\n\n/**\n * The Border Clipper removes all keypoints within a border of the edges of an image\n */\nexport class SpeedyPipelineNodeKeypointBorderClipper extends SpeedyPipelineNode\n{\n    /**\n     * Constructor\n     * @param {string} [name] name of the node\n     */\n    constructor(name = undefined)\n    {\n        super(name, 5, [\n            InputPort().expects(SpeedyPipelineMessageType.Keypoints),\n            OutputPort().expects(SpeedyPipelineMessageType.Keypoints)\n        ]);\n\n        /** @type {SpeedySize} image size, in pixels */\n        this._imageSize = new SpeedySize(0,0);\n\n        /** @type {SpeedyVector2} border size, in pixels */\n        this._borderSize = new SpeedyVector2(0,0);\n    }\n\n    /**\n     * Image size, in pixels\n     * @returns {SpeedySize}\n     */\n    get imageSize()\n    {\n        return this._imageSize;\n    }\n\n    /**\n     * Image size, in pixels\n     * @param {SpeedySize} imageSize\n     */\n    set imageSize(imageSize)\n    {\n        this._imageSize = imageSize;\n    }\n\n    /**\n     * Border size, in pixels\n     * @returns {SpeedyVector2}\n     */\n    get borderSize()\n    {\n        return this._borderSize;\n    }\n\n    /**\n     * Border size, in pixels\n     * @param {SpeedyVector2} borderSize\n     */\n    set borderSize(borderSize)\n    {\n        this._borderSize = borderSize;\n    }\n\n    /**\n     * Run the specific task of this node\n     * @param {SpeedyGPU} gpu\n     * @returns {void|SpeedyPromise<void>}\n     */\n    _run(gpu)\n    {\n        const { encodedKeypoints, descriptorSize, extraSize, encoderLength } = /** @type {SpeedyPipelineMessageWithKeypoints} */ ( this.input().read() );\n        const keypoints = gpu.programs.keypoints;\n        const imageSize = this._imageSize;\n        const borderSize = this._borderSize;\n        const imageWidth = imageSize.width, imageHeight = imageSize.height;\n        const borderLeft = borderSize.x, borderRight = borderSize.x;\n        const borderTop = borderSize.y, borderBottom = borderSize.y;\n        const tex = this._tex;\n\n        // validate\n        if(imageWidth == 0 || imageHeight == 0)\n            throw new IllegalOperationError(`BorderClipper: did you forget to set the image size?`);\n\n        // find the capacity of the keypoint stream\n        const capacity = SpeedyPipelineNodeKeypointDetector.encoderCapacity(descriptorSize, extraSize, encoderLength);\n        const mixEncoderLength = Math.max(1, Math.ceil(Math.sqrt(capacity)));\n\n        // prepare programs\n        keypoints.clipBorder.outputs(encoderLength, encoderLength, tex[0]);\n        keypoints.mixKeypointsInit.outputs(mixEncoderLength, mixEncoderLength, tex[1]);\n        keypoints.mixKeypointsSort.outputs(mixEncoderLength, mixEncoderLength, tex[2], tex[3]);\n        keypoints.mixKeypointsApply.outputs(encoderLength, encoderLength, tex[4]);\n\n        // clip keypoints\n        let clippedKeypoints = keypoints.clipBorder(\n            imageWidth, imageHeight,\n            borderTop, borderRight, borderBottom, borderLeft,\n            encodedKeypoints, descriptorSize, extraSize, encoderLength\n        );\n\n        // sort keypoints\n        let sortedKeypoints = keypoints.mixKeypointsInit(\n            clippedKeypoints, descriptorSize, extraSize, encoderLength, capacity\n        );\n\n        for(let b = 1; b < capacity; b *= 2)\n            sortedKeypoints = keypoints.mixKeypointsSort(sortedKeypoints, b);\n\n        clippedKeypoints = keypoints.mixKeypointsApply(\n            sortedKeypoints, clippedKeypoints, descriptorSize, extraSize, encoderLength\n        );\n\n        /*\n        // debug: view keypoints\n        keypoints.mixKeypointsView.outputs(mixEncoderLength, mixEncoderLength, tex[1]);\n        this._visualize(gpu, keypoints.mixKeypointsView(sortedKeypoints));\n        */\n\n        // done!\n        this.output().swrite(clippedKeypoints, descriptorSize, extraSize, encoderLength);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * buffer.js\n * Keypoint Buffer\n */\n\nimport { SpeedyPipelineNode } from '../../pipeline-node';\nimport { SpeedyPipelineNodeKeypointDetector } from './detectors/detector';\nimport { SpeedyPipelineMessageType, SpeedyPipelineMessageWithKeypoints } from '../../pipeline-message';\nimport { InputPort, OutputPort } from '../../pipeline-portbuilder';\nimport { SpeedyGPU } from '../../../../gpu/speedy-gpu';\nimport { SpeedyTexture } from '../../../../gpu/speedy-texture';\nimport { Utils } from '../../../../utils/utils';\nimport { SpeedyPromise } from '../../../../utils/speedy-promise';\n\n\n\n/**\n * Keypoint Buffer: a node with memory.\n * At time t, it outputs the keypoints received at time t-1\n */\nexport class SpeedyPipelineNodeKeypointBuffer extends SpeedyPipelineNode\n{\n    /**\n     * Constructor\n     * @param {string} [name] name of the node\n     */\n    constructor(name = undefined)\n    {\n        super(name, 2, [\n            InputPort().expects(SpeedyPipelineMessageType.Keypoints),\n            OutputPort().expects(SpeedyPipelineMessageType.Keypoints)\n        ]);\n\n        /** @type {number} current page: 0 or 1 */\n        this._pageIndex = 0;\n\n        /** @type {boolean} first run? */\n        this._initialized = false;\n\n        /** @type {number} previous descriptor size, in bytes */\n        this._previousDescriptorSize = 0;\n\n        /** @type {number} previous extra size, in bytes */\n        this._previousExtraSize = 0;\n\n        /** @type {number} previous encoder length */\n        this._previousEncoderLength = 0;\n\n        /** @type {boolean} frozen buffer? */\n        this._frozen = false;\n    }\n\n    /**\n     * A frozen buffer discards the input, effectively increasing the buffering time\n     * @returns {boolean}\n     */\n    get frozen()\n    {\n        return this._frozen;\n    }\n\n    /**\n     * A frozen buffer discards the input, effectively increasing the buffering time\n     * @param {boolean} value\n     */\n    set frozen(value)\n    {\n        this._frozen = Boolean(value);\n    }\n\n    /**\n     * Releases this node\n     * @param {SpeedyGPU} gpu\n     */\n    release(gpu)\n    {\n        this._initialized = false;\n        super.release(gpu);\n    }\n\n    /**\n     * Run the specific task of this node\n     * @param {SpeedyGPU} gpu\n     * @returns {void|SpeedyPromise<void>}\n     */\n    _run(gpu)\n    {\n        const { encodedKeypoints, descriptorSize, extraSize, encoderLength } = /** @type {SpeedyPipelineMessageWithKeypoints} */ ( this.input().read() );\n        const previousDescriptorSize = this._previousDescriptorSize;\n        const previousExtraSize = this._previousExtraSize;\n        const previousEncoderLength = this._previousEncoderLength;\n        const page = this._tex;\n        const previousInputTexture = page[1 - this._pageIndex];\n        const outputTexture = page[this._pageIndex];\n\n        // bufferize\n        if(!this._frozen || !this._initialized) {\n            // store input\n            this._previousDescriptorSize = descriptorSize;\n            this._previousExtraSize = extraSize;\n            this._previousEncoderLength = encoderLength;\n            previousInputTexture.resize(encoderLength, encoderLength);\n            encodedKeypoints.copyTo(previousInputTexture);\n\n            // page flipping\n            this._pageIndex = 1 - this._pageIndex;\n        }\n\n        // first run?\n        if(!this._initialized) {\n            this._initialized = true;\n            this.output().swrite(previousInputTexture, descriptorSize, extraSize, encoderLength);\n            return;\n        }\n\n        // done!\n        this.output().swrite(outputTexture, previousDescriptorSize, previousExtraSize, previousEncoderLength);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * clipper.js\n * Keypoint clipper\n */\n\nimport { SpeedyPipelineNode } from '../../pipeline-node';\nimport { SpeedyPipelineNodeKeypointDetector } from './detectors/detector';\nimport { SpeedyPipelineMessageType, SpeedyPipelineMessageWithKeypoints } from '../../pipeline-message';\nimport { InputPort, OutputPort } from '../../pipeline-portbuilder';\nimport { SpeedyGPU } from '../../../../gpu/speedy-gpu';\nimport { SpeedyTexture } from '../../../../gpu/speedy-texture';\nimport { Utils } from '../../../../utils/utils';\nimport { MAX_ENCODER_CAPACITY } from '../../../../utils/globals';\nimport { SpeedyPromise } from '../../../../utils/speedy-promise';\n\n\n// Constants\nconst LOG2_STRIDE = 5;\nconst MAX_SIZE = MAX_ENCODER_CAPACITY;\n\n\n\n/**\n * Keypoint clipper: filters the best keypoints from a stream\n */\nexport class SpeedyPipelineNodeKeypointClipper extends SpeedyPipelineNode\n{\n    /**\n     * Constructor\n     * @param {string} [name] name of the node\n     */\n    constructor(name = undefined)\n    {\n        super(name, 4, [\n            InputPort().expects(SpeedyPipelineMessageType.Keypoints),\n            OutputPort().expects(SpeedyPipelineMessageType.Keypoints)\n        ]);\n\n        /** @type {number} the maximum number of keypoints in the output */\n        this._size = MAX_SIZE;\n    }\n\n    /**\n     * The maximum number of keypoints in the output\n     * @returns {number}\n     */\n    get size()\n    {\n        return this._size;\n    }\n\n    /**\n     * The maximum number of keypoints in the output\n     * @param {number} size\n     */\n    set size(size)\n    {\n        this._size = Math.max(0, Math.min(size | 0, MAX_SIZE));\n    }\n\n    /**\n     * Run the specific task of this node\n     * @param {SpeedyGPU} gpu\n     * @returns {void|SpeedyPromise<void>}\n     */\n    _run(gpu)\n    {\n        const { encodedKeypoints, descriptorSize, extraSize, encoderLength } = /** @type {SpeedyPipelineMessageWithKeypoints} */ ( this.input().read() );\n        const keypoints = gpu.programs.keypoints;\n        const clipValue = this._size;\n        const tex = this._tex;\n        const outputTexture = this._tex[3];\n\n        // find the minimum power of 2 pot such that pot >= capacity\n        const capacity = SpeedyPipelineNodeKeypointDetector.encoderCapacity(descriptorSize, extraSize, encoderLength);\n        //const pot = 1 << (Math.ceil(Math.log2(capacity)) | 0);\n\n        // find the dimensions of the sorting shaders\n        const stride = 1 << LOG2_STRIDE; // must be a power of 2\n        //const height = Math.max(1, pot >>> LOG2_STRIDE); // this is also a power of 2\n        const height = Math.ceil(capacity / stride); // more economical, maybe not a power of 2\n        const numberOfPixels = stride * height;\n\n        // find the dimensions of the output texture\n        const newCapacity = Math.min(capacity, clipValue);\n        const newEncoderLength = SpeedyPipelineNodeKeypointDetector.encoderLength(newCapacity, descriptorSize, extraSize);\n\n        // generate permutation of keypoints\n        keypoints.sortCreatePermutation.outputs(stride, height, tex[0]);\n        let permutation = keypoints.sortCreatePermutation(encodedKeypoints, descriptorSize, extraSize, encoderLength);\n\n        // sort permutation\n        const numPasses = Math.ceil(Math.log2(numberOfPixels));\n        keypoints.sortMergePermutation.outputs(stride, height, tex[1], tex[2]);\n        for(let i = 1; i <= numPasses; i++) {\n            const blockSize = 1 << i; // 2, 4, 8...\n            const dblLog2BlockSize = i << 1; // 2 * log2(blockSize)\n            permutation = keypoints.sortMergePermutation(permutation, blockSize, dblLog2BlockSize);\n        }\n\n        // apply permutation\n        keypoints.sortApplyPermutation.outputs(newEncoderLength, newEncoderLength, outputTexture);\n        keypoints.sortApplyPermutation(permutation, newCapacity, encodedKeypoints, descriptorSize, extraSize);\n\n        /*\n        // debug (read the contents of the permutation)\n        const pixels = this._inspect(gpu, permutation), debug = [];\n        for(let i = 0; i < pixels.length; i += 4) {\n            let id = pixels[i] | (pixels[i+1] << 8);\n            let score = pixels[i+2] / 255.0;\n            let valid = pixels[i+3] / 255.0;\n            debug.push([ id, valid, score, ].join(', '));\n        }\n        console.log(debug);\n        */\n\n        // done!\n        this.output().swrite(outputTexture, descriptorSize, extraSize, newEncoderLength);\n    }\n}\n","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * descriptor.js\n * Abstract keypoint descriptor\n */\n\nimport { SpeedyPipelineNode } from '../../../pipeline-node';\nimport { SpeedyPipelinePortBuilder } from '../../../pipeline-portbuilder';\nimport { SpeedyGPU } from '../../../../../gpu/speedy-gpu';\nimport { SpeedyTexture, SpeedyDrawableTexture } from '../../../../../gpu/speedy-texture';\nimport { SpeedyPipelineNodeKeypointDetector } from '../detectors/detector';\nimport { Utils } from '../../../../../utils/utils';\n\n/**\n * Abstract keypoint descriptor\n * @abstract\n */\nexport class SpeedyPipelineNodeKeypointDescriptor extends SpeedyPipelineNode\n{\n    /**\n     * Constructor\n     * @param {string} [name] name of the node\n     * @param {number} [texCount] number of work textures\n     * @param {SpeedyPipelinePortBuilder[]} [portBuilders] port builders\n     */\n    constructor(name = undefined, texCount = 0, portBuilders = undefined)\n    {\n        super(name, texCount + 1, portBuilders);\n    }\n\n    /**\n     * \n     * Allocate space for keypoint descriptors\n     * @param {SpeedyGPU} gpu\n     * @param {number} inputDescriptorSize should be 0\n     * @param {number} inputExtraSize must be non-negative\n     * @param {number} outputDescriptorSize in bytes, must be a multiple of 4\n     * @param {number} outputExtraSize must be inputExtraSize\n     * @param {SpeedyTexture} inputEncodedKeypoints input with no descriptors\n     * @returns {SpeedyDrawableTexture} encodedKeypoints\n     */\n    _allocateDescriptors(gpu, inputDescriptorSize, inputExtraSize, outputDescriptorSize, outputExtraSize, inputEncodedKeypoints)\n    {\n        Utils.assert(inputDescriptorSize >= 0 && inputExtraSize >= 0);\n        Utils.assert(outputDescriptorSize >= 0 && outputDescriptorSize % 4 === 0 && outputExtraSize === inputExtraSize);\n\n        const inputEncoderLength = inputEncodedKeypoints.width;\n        const inputEncoderCapacity = SpeedyPipelineNodeKeypointDetector.encoderCapacity(inputDescriptorSize, inputExtraSize, inputEncoderLength);\n        const outputEncoderCapacity = inputEncoderCapacity;\n        const outputEncoderLength = SpeedyPipelineNodeKeypointDetector.encoderLength(outputEncoderCapacity, outputDescriptorSize, outputExtraSize);\n\n        const tex = this._tex[this._tex.length - 1];\n        return (gpu.programs.keypoints.allocateDescriptors\n            .outputs(outputEncoderLength, outputEncoderLength, tex)\n        )(inputEncodedKeypoints, inputDescriptorSize, inputExtraSize, inputEncoderLength, outputDescriptorSize, outputExtraSize, outputEncoderLength);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * orb.js\n * ORB descriptors\n */\n\nimport { SpeedyPipelineNode } from '../../../pipeline-node';\nimport { SpeedyPipelineMessageType, SpeedyPipelineMessageWithImage, SpeedyPipelineMessageWithKeypoints } from '../../../pipeline-message';\nimport { InputPort, OutputPort } from '../../../pipeline-portbuilder';\nimport { SpeedyGPU } from '../../../../../gpu/speedy-gpu';\nimport { SpeedyTexture, SpeedyDrawableTexture } from '../../../../../gpu/speedy-texture';\nimport { ImageFormat } from '../../../../../utils/types';\nimport { Utils } from '../../../../../utils/utils';\nimport { SpeedyPromise } from '../../../../../utils/speedy-promise';\nimport { SpeedyPipelineNodeKeypointDetector } from '../detectors/detector';\nimport { SpeedyPipelineNodeKeypointDescriptor } from './descriptor';\n\n// Constants\nconst DESCRIPTOR_SIZE = 32; // 256 bits\n\n/**\n * ORB descriptors\n */\nexport class SpeedyPipelineNodeORBKeypointDescriptor extends SpeedyPipelineNodeKeypointDescriptor\n{\n    /**\n     * Constructor\n     * @param {string} [name] name of the node\n     */\n    constructor(name = undefined)\n    {\n        super(name, 3, [\n            InputPort('image').expects(SpeedyPipelineMessageType.Image).satisfying(\n                ( /** @type {SpeedyPipelineMessageWithImage} */ msg ) =>\n                    msg.format === ImageFormat.GREY\n            ),\n            InputPort('keypoints').expects(SpeedyPipelineMessageType.Keypoints),\n            OutputPort().expects(SpeedyPipelineMessageType.Keypoints),\n        ]);\n    }\n\n    /**\n     * Run the specific task of this node\n     * @param {SpeedyGPU} gpu\n     * @returns {void|SpeedyPromise<void>}\n     */\n    _run(gpu)\n    {\n        const { encodedKeypoints, descriptorSize, extraSize, encoderLength } = /** @type {SpeedyPipelineMessageWithKeypoints} */ ( this.input('keypoints').read() );\n        const image = ( /** @type {SpeedyPipelineMessageWithImage} */ ( this.input('image').read() ) ).image;\n        const tex = this._tex;\n        const outputTexture = this._tex[2];\n\n        // compute orientation\n        const capacity = SpeedyPipelineNodeKeypointDetector.encoderCapacity(descriptorSize, extraSize, encoderLength);\n        const orientationEncoderLength = Math.max(1, Math.ceil(Math.sqrt(capacity))); // 1 pixel per keypoint\n        const encodedOrientations = (gpu.programs.keypoints.orbOrientation\n            .outputs(orientationEncoderLength, orientationEncoderLength, tex[0])\n        )(image, encodedKeypoints, descriptorSize, extraSize, encoderLength);\n        const orientedKeypoints = (gpu.programs.keypoints.transferOrientation\n            .outputs(encoderLength, encoderLength, tex[1])\n        )(encodedOrientations, encodedKeypoints, descriptorSize, extraSize, encoderLength);\n\n        // allocate space\n        const encodedKps = this._allocateDescriptors(gpu, descriptorSize, extraSize, DESCRIPTOR_SIZE, extraSize, orientedKeypoints);\n        const newEncoderLength = encodedKps.width;\n\n        // compute descriptors (it's a good idea to blur the image)\n        const describedKeypoints = (gpu.programs.keypoints.orbDescriptor\n            .outputs(newEncoderLength, newEncoderLength, outputTexture)\n        )(image, encodedKps, extraSize, newEncoderLength);\n\n        // done!\n        this.output().swrite(describedKeypoints, DESCRIPTOR_SIZE, extraSize, newEncoderLength);\n    }\n}\n","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * detector.js\n * Abstract keypoint detectors\n */\n\nimport { SpeedyPipelineNode } from '../../../pipeline-node';\nimport { SpeedyPipelineMessageType, SpeedyPipelineMessageWithKeypoints } from '../../../pipeline-message';\nimport { SpeedyPipelinePortBuilder } from '../../../pipeline-portbuilder';\nimport { SpeedyGPU } from '../../../../../gpu/speedy-gpu';\nimport { SpeedyTexture, SpeedyDrawableTexture } from '../../../../../gpu/speedy-texture';\nimport { Utils } from '../../../../../utils/utils';\nimport { SpeedyPromise } from '../../../../../utils/speedy-promise';\nimport { MIN_KEYPOINT_SIZE, MIN_ENCODER_LENGTH, DEFAULT_ENCODER_CAPACITY, MAX_ENCODER_CAPACITY } from '../../../../../utils/globals';\n\n// Constants\nconst MAX_CAPACITY = MAX_ENCODER_CAPACITY; // maximum capacity of the encoder (up to this many keypoints can be stored)\nconst DEFAULT_CAPACITY = DEFAULT_ENCODER_CAPACITY; // default capacity of the encoder\nconst DEFAULT_SCALE_FACTOR = 1.4142135623730951; // sqrt(2)\nconst NUMBER_OF_RGBA16_TEXTURES = 2;\n\n// legacy constants\nconst NUMBER_OF_INTERNAL_TEXTURES = 0; //5; // number of internal textures used to encode the keypoints\nconst ENCODER_PASSES = 4; // number of passes of the keypoint encoder: directly impacts performance\nconst LONG_SKIP_OFFSET_PASSES = 2; // number of passes of the long skip offsets shader\n\n/**\n * Abstract keypoint detector\n * @abstract\n */\nexport class SpeedyPipelineNodeKeypointDetector extends SpeedyPipelineNode\n{\n    /**\n     * Constructor\n     * @param {string} [name] name of the node\n     * @param {number} [texCount] number of work textures\n     * @param {SpeedyPipelinePortBuilder[]} [portBuilders] port builders\n     */\n    constructor(name = undefined, texCount = 0, portBuilders = undefined)\n    {\n        super(name, texCount + NUMBER_OF_INTERNAL_TEXTURES, portBuilders);\n\n        /** @type {number} encoder capacity */\n        this._capacity = DEFAULT_CAPACITY; // must not be greater than MAX_ENCODER_CAPACITY\n\n        /** @type {GLint} auxiliary storage */\n        this._oldWrapS = 0;\n\n        /** @type {SpeedyDrawableTexture[]} textures with 8-bytes per pixel */\n        this._tex16 = new Array(NUMBER_OF_RGBA16_TEXTURES).fill(null);\n    }\n\n    /**\n     * Initialize this node\n     * @param {SpeedyGPU} gpu\n     */\n    init(gpu)\n    {\n        // initialize\n        super.init(gpu);\n\n        // encodeKeypointSkipOffsets() relies on this\n        this._oldWrapS = this._setupSpecialTexture(gpu.gl.TEXTURE_WRAP_S, gpu.gl.REPEAT);\n\n        // allocate RGBA16 textures\n        this._allocateTex16(gpu);\n        gpu.subscribe(this._allocateTex16, this, gpu);\n    }\n\n    /**\n     * Release this node\n     * @param {SpeedyGPU} gpu\n     */\n    release(gpu)\n    {\n        // deallocate RGBA16 textures\n        gpu.unsubscribe(this._allocateTex16, this);\n        this._deallocateTex16(gpu);\n\n        // we need to restore the texture parameter because textures come from a pool!\n        this._setupSpecialTexture(gpu.gl.TEXTURE_WRAP_S, this._oldWrapS);\n\n        // release\n        super.release(gpu);\n    }\n\n    /**\n     * Set a parameter of the special texture\n     * @param {GLenum} pname\n     * @param {GLint} param new value\n     * @returns {GLint} old value of param\n     */\n    _setupSpecialTexture(pname, param)\n    {\n        if(NUMBER_OF_INTERNAL_TEXTURES == 0)\n            return;\n\n        // legacy code\n        const texture = this._tex[this._tex.length - 1];\n        const gl = texture.gl;\n\n        gl.bindTexture(gl.TEXTURE_2D, texture.glTexture);\n        const oldval = gl.getTexParameter(gl.TEXTURE_2D, pname);\n        gl.texParameteri(gl.TEXTURE_2D, pname, param);\n        gl.bindTexture(gl.TEXTURE_2D, null);\n\n        return oldval;\n    }\n\n    /**\n     * We can encode up to this many keypoints. If you find a\n     * tight bound for this, download times will be faster.\n     * @returns {number}\n     */\n    get capacity()\n    {\n        return this._capacity;\n    }\n\n    /**\n     * We can encode up to this many keypoints. If you find a\n     * tight bound for this, download times will be faster.\n     * @param {number} capacity\n     */\n    set capacity(capacity)\n    {\n        this._capacity = Math.min(Math.max(0, capacity | 0), MAX_CAPACITY);\n    }\n\n    /**\n     * Create a tiny texture with encoded keypoints out of\n     * an encoded corners texture\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyTexture} corners input\n     * @param {SpeedyDrawableTexture} encodedKeypoints output\n     * @param {number} [descriptorSize] in bytes\n     * @param {number} [extraSize] in bytes\n     * @returns {SpeedyDrawableTexture} encodedKeypoints\n     */\n    _encodeKeypoints(gpu, corners, encodedKeypoints, descriptorSize = 0, extraSize = 0)\n    {\n        const encoderCapacity = this._capacity;\n        const encoderLength = SpeedyPipelineNodeKeypointDetector.encoderLength(encoderCapacity, descriptorSize, extraSize);\n        const width = 1 << (Math.ceil(Math.log2(corners.width * corners.height)) >>> 1); // power of two\n        const height = Math.ceil(corners.width * corners.height / width); // probabilistic approach in Parallel Ale Sort 2D\n        //const width = corners.width, height = corners.height; // independent texture reads approach in Parallel Ale Sort 2D\n        const maxSize = Math.max(width, height);\n        const keypoints = gpu.programs.keypoints;\n\n        // prepare programs\n        keypoints.initLookupTable.outputs(width, height, this._tex16[1]);\n        keypoints.sortLookupTable.outputs(width, height, this._tex16[0], this._tex16[1]);\n        keypoints.encodeKeypoints.outputs(encoderLength, encoderLength, encodedKeypoints);\n\n        // compute lookup table\n        let lookupTable = keypoints.initLookupTable(corners);\n        for(let b = 1; b < maxSize; b *= 2)\n            lookupTable = keypoints.sortLookupTable(lookupTable, b, width, height);\n\n        /*\n        // debug: view texture\n        const lookupView = (keypoints.viewLookupTable.outputs(\n            width, height, this._tex[0]\n        ))(lookupTable);\n        const canvas = gpu.renderToCanvas(lookupView);\n        if(!this._ww) document.body.appendChild(canvas);\n        this._ww = 1;\n        */\n\n        // encode keypoints\n        return keypoints.encodeKeypoints(corners, lookupTable, width, descriptorSize, extraSize, encoderLength, encoderCapacity);\n    }\n\n    _encodeKeypointsOLD(gpu, corners, encodedKeypoints, descriptorSize = 0, extraSize = 0)\n    {\n        const capacity = this._capacity;\n        const encoderLength = SpeedyPipelineNodeKeypointDetector.encoderLength(capacity, descriptorSize, extraSize);\n        const width = corners.width, height = corners.height;\n        const imageSize = [ width, height ];\n        const tex = this._tex.slice(this._tex.length - NUMBER_OF_INTERNAL_TEXTURES); // array of internal textures\n        const keypoints = gpu.programs.keypoints;\n        const specialTexture = tex.pop(); // gl.TEXTURE_WRAP_S is set to gl.REPEAT\n\n        // prepare programs\n        keypoints.encodeKeypointSkipOffsets.outputs(width, height, tex[0]);\n        keypoints.encodeKeypointLongSkipOffsets.outputs(width, height, tex[1], tex[0]);\n        keypoints.encodeKeypointPositions.outputs(encoderLength, encoderLength, tex[2], tex[3]);\n        keypoints.encodeKeypointProperties.outputs(encoderLength, encoderLength, encodedKeypoints);\n\n        // copy the input corners to a special texture\n        // that is needed by encodeKeypointSkipOffsets()\n        corners = (gpu.programs.utils.copy\n            .outputs(width, height, specialTexture)\n        )(corners);\n\n        // encode skip offsets\n        let offsets = keypoints.encodeKeypointSkipOffsets(corners, imageSize);\n        for(let i = 0; i < LONG_SKIP_OFFSET_PASSES; i++) { // to boost performance\n            // the maximum skip offset of pass p=1,2,3... is 7 * (1+m)^p,\n            // where m = MAX_ITERATIONS of encodeKeypointLongSkipOffsets()\n            offsets = keypoints.encodeKeypointLongSkipOffsets(offsets, imageSize); // **bottleneck**\n        }\n\n        /*\n        // debug: view corners\n        let cornerview = offsets;\n        const canvas = gpu.renderToCanvas(cornerview);\n        if(!window._ww) document.body.appendChild(canvas);\n        window._ww = 1;\n        */\n\n        // encode keypoint positions\n        let encodedKps = tex[3].clear();\n        for(let j = 0; j < ENCODER_PASSES; j++)\n            encodedKps = keypoints.encodeKeypointPositions(offsets, imageSize, j, ENCODER_PASSES, capacity, encodedKps, descriptorSize, extraSize, encoderLength);\n\n        // encode keypoint properties\n        return keypoints.encodeKeypointProperties(corners, encodedKps, descriptorSize, extraSize, encoderLength);\n    }\n\n    /**\n     * Create a tiny texture with zero encoded keypoints\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyDrawableTexture} encodedKeypoints output texture\n     * @param {number} [descriptorSize] in bytes\n     * @param {number} [extraSize] in bytes\n     * @returns {SpeedyDrawableTexture} encodedKeypoints\n     */\n    _encodeZeroKeypoints(gpu, encodedKeypoints, descriptorSize = 0, extraSize = 0)\n    {\n        const capacity = 0;\n        const encoderLength = SpeedyPipelineNodeKeypointDetector.encoderLength(capacity, descriptorSize, extraSize);\n        const keypoints = gpu.programs.keypoints;\n\n        keypoints.encodeNullKeypoints.outputs(encoderLength, encoderLength, encodedKeypoints);\n        return keypoints.encodeNullKeypoints();\n    }\n\n    /**\n     * Allocate RGBA16 textures\n     * @param {SpeedyGPU} gpu\n     */\n    _allocateTex16(gpu)\n    {\n        const gl = gpu.gl;\n\n        // RGBA16UI is color renderable according to the OpenGL ES 3 spec\n        for(let i = 0; i < this._tex16.length; i++)\n            this._tex16[i] = new SpeedyDrawableTexture(gl, 1, 1, gl.RGBA_INTEGER, gl.RGBA16UI, gl.UNSIGNED_SHORT, gl.NEAREST, gl.CLAMP_TO_EDGE);\n    }\n\n    /**\n     * Deallocate RGBA16 textures\n     * @param {SpeedyGPU} gpu\n     */\n    _deallocateTex16(gpu)\n    {\n        for(let i = 0; i < this._tex16.length; i++)\n            this._tex16[i] = this._tex16[i].release();\n    }\n\n    /**\n     * Compute the length of the keypoint encoder, given its capacity\n     * @param {number} encoderCapacity how many keypoints can we fit?\n     * @param {number} descriptorSize in bytes\n     * @param {number} extraSize in bytes\n     */\n    static encoderLength(encoderCapacity, descriptorSize, extraSize)\n    {\n        const pixelsPerKeypoint = Math.ceil((MIN_KEYPOINT_SIZE + descriptorSize + extraSize) / 4);\n        const numberOfPixels = encoderCapacity * pixelsPerKeypoint;\n\n        return Math.max(MIN_ENCODER_LENGTH, Math.ceil(Math.sqrt(numberOfPixels)));\n    }\n\n    /**\n     * The maximum number of keypoints we can store using\n     * a particular configuration of a keypoint encoder\n     * @param {number} descriptorSize in bytes\n     * @param {number} extraSize in bytes\n     * @param {number} encoderLength\n     */\n    static encoderCapacity(descriptorSize, extraSize, encoderLength)\n    {\n        const pixelsPerKeypoint = Math.ceil((MIN_KEYPOINT_SIZE + descriptorSize + extraSize) / 4);\n        const numberOfPixels = encoderLength * encoderLength;\n\n        return Math.floor(numberOfPixels / pixelsPerKeypoint);\n    }\n}\n\n/**\n * Abstract scale-space keypoint detector\n * @abstract\n */\nexport class SpeedyPipelineNodeMultiscaleKeypointDetector extends SpeedyPipelineNodeKeypointDetector\n{\n    /**\n     * Constructor\n     * @param {string} [name] name of the node\n     * @param {number} [texCount] number of work textures\n     * @param {SpeedyPipelinePortBuilder[]} [portBuilders] port builders\n     */\n    constructor(name = undefined, texCount = undefined, portBuilders = undefined)\n    {\n        super(name, texCount, portBuilders);\n\n        /** @type {number} number of pyramid levels */\n        this._levels = 1;\n\n        /** @type {number} scale factor between two pyramid levels */\n        this._scaleFactor = DEFAULT_SCALE_FACTOR;\n    }\n\n    /**\n     * Number of pyramid levels\n     * @returns {number}\n     */\n    get levels()\n    {\n        return this._levels;\n    }\n\n    /**\n     * Number of pyramid levels\n     * @param {number} levels\n     */\n    set levels(levels)\n    {\n        this._levels = Math.max(1, levels | 0);\n    }\n\n    /**\n     * Scale factor between two pyramid levels\n     * @returns {number}\n     */\n    get scaleFactor()\n    {\n        return this._scaleFactor;\n    }\n\n    /**\n     * Scale factor between two pyramid levels\n     * @param {number} scaleFactor should be greater than 1\n     */\n    set scaleFactor(scaleFactor)\n    {\n        this._scaleFactor = Math.max(1.0, Math.min(+scaleFactor, 2.0));\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * fast.js\n * FAST corner detector\n */\n\nimport { SpeedyPipelineNodeMultiscaleKeypointDetector } from './detector';\nimport { SpeedyPipelineMessageType, SpeedyPipelineMessageWithKeypoints, SpeedyPipelineMessageWithImage } from '../../../pipeline-message';\nimport { InputPort, OutputPort } from '../../../pipeline-portbuilder';\nimport { SpeedyGPU } from '../../../../../gpu/speedy-gpu';\nimport { SpeedyTexture } from '../../../../../gpu/speedy-texture';\nimport { ImageFormat } from '../../../../../utils/types';\nimport { Utils } from '../../../../../utils/utils';\nimport { IllegalOperationError } from '../../../../../utils/errors';\nimport { SpeedyPromise } from '../../../../../utils/speedy-promise';\nimport { MIN_KEYPOINT_SIZE, PYRAMID_MAX_LEVELS } from '../../../../../utils/globals';\n\n// Constants\nconst DEFAULT_THRESHOLD = 20;\n\n\n\n/**\n * FAST corner detector\n */\nexport class SpeedyPipelineNodeFASTKeypointDetector extends SpeedyPipelineNodeMultiscaleKeypointDetector\n{\n    /**\n     * Constructor\n     * @param {string} [name] name of the node\n     */\n    constructor(name = undefined)\n    {\n        super(name, 5, [\n            InputPort().expects(SpeedyPipelineMessageType.Image).satisfying(\n                ( /** @type {SpeedyPipelineMessageWithImage} */ msg ) =>\n                    msg.format === ImageFormat.GREY\n            ),\n            OutputPort().expects(SpeedyPipelineMessageType.Keypoints),\n        ]);\n\n        /** @type {number} FAST threshold in [0,255] */\n        this._threshold = DEFAULT_THRESHOLD;\n    }\n\n    /**\n     * FAST threshold in [0,255]\n     * @returns {number}\n     */\n    get threshold()\n    {\n        return this._threshold;\n    }\n\n    /**\n     * FAST threshold in [0,255]\n     * @param {number} threshold\n     */\n    set threshold(threshold)\n    {\n        this._threshold = Math.max(0, Math.min(threshold | 0, 255));\n    }\n\n    /**\n     * Run the specific task of this node\n     * @param {SpeedyGPU} gpu\n     * @returns {void|SpeedyPromise<void>}\n     */\n    _run(gpu)\n    {\n        const { image, format } = /** @type {SpeedyPipelineMessageWithImage} */ ( this.input().read() );\n        const width = image.width, height = image.height;\n        const tex = this._tex;\n        const capacity = this._capacity;\n        const threshold = this._threshold;\n        const lodStep = Math.log2(this.scaleFactor);\n        const levels = this.levels;\n\n        // validate pyramid\n        if(!(levels == 1 || image.hasMipmaps()))\n            throw new IllegalOperationError(`Expected a pyramid in ${this.fullName}`);\n\n        // skip if the capacity is zero\n        if(capacity == 0) {\n            const encodedKeypoints = this._encodeZeroKeypoints(gpu, tex[4]);\n            const encoderLength = encodedKeypoints.width;\n            this.output().swrite(encodedKeypoints, 0, 0, encoderLength);\n            return;\n        }\n\n        // FAST\n        gpu.programs.keypoints.fast9_16.outputs(width, height, tex[0], tex[1]);\n        gpu.programs.keypoints.nonmaxSpace.outputs(width, height, tex[2]);\n        let corners = tex[1].clear();\n        let numPasses = Math.max(1, Math.min(levels, (PYRAMID_MAX_LEVELS / lodStep) | 0));\n        for(let lod = lodStep * (numPasses - 1); numPasses-- > 0; lod -= lodStep) {\n            corners = gpu.programs.keypoints.fast9_16(corners, image, lod, threshold);\n            //corners = gpu.programs.keypoints.nonmaxSpace(corners); // see below*\n        }\n\n        // Same-scale non-maximum suppression\n        // *nicer results inside the loop; faster outside\n        // Hard to notice a difference when using FAST\n        corners = gpu.programs.keypoints.nonmaxSpace(corners);\n\n        // Multi-scale non-maximum suppression\n        // (doesn't seem to remove many keypoints)\n        if(levels > 1) {\n            corners = (gpu.programs.keypoints.nonmaxScaleSimple\n                .outputs(width, height, tex[1])\n            )(corners, image, lodStep);\n        }\n\n        // encode keypoints\n        let encodedKeypoints = this._encodeKeypoints(gpu, corners, tex[3]);\n        const encoderLength = encodedKeypoints.width;\n\n        // scale refinement\n        if(levels > 1) {\n            encodedKeypoints = (gpu.programs.keypoints.refineScaleFAST916\n                .outputs(encoderLength, encoderLength, tex[4])\n            )(image, lodStep, encodedKeypoints, 0, 0, encoderLength, threshold);\n        }\n\n        // done!\n        this.output().swrite(encodedKeypoints, 0, 0, encoderLength);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * harris.js\n * Harris corner detector\n */\n\nimport { SpeedyPipelineNodeMultiscaleKeypointDetector } from './detector';\nimport { SpeedyPipelineMessageType, SpeedyPipelineMessageWithKeypoints, SpeedyPipelineMessageWithImage } from '../../../pipeline-message';\nimport { InputPort, OutputPort } from '../../../pipeline-portbuilder';\nimport { SpeedyGPU } from '../../../../../gpu/speedy-gpu';\nimport { SpeedyTexture } from '../../../../../gpu/speedy-texture';\nimport { ImageFormat } from '../../../../../utils/types';\nimport { SpeedySize } from '../../../../speedy-size';\nimport { Utils } from '../../../../../utils/utils';\nimport { IllegalOperationError, IllegalArgumentError } from '../../../../../utils/errors';\nimport { SpeedyPromise } from '../../../../../utils/speedy-promise';\nimport { PYRAMID_MAX_LEVELS } from '../../../../../utils/globals';\n\n/** Window size helper */\nconst HARRIS = Object.freeze({\n    1: 'harris1',\n    3: 'harris3',\n    5: 'harris5',\n    7: 'harris7',\n});\n\n/**\n * Harris corner detector\n */\nexport class SpeedyPipelineNodeHarrisKeypointDetector extends SpeedyPipelineNodeMultiscaleKeypointDetector\n{\n    /**\n     * Constructor\n     * @param {string} [name] name of the node\n     */\n    constructor(name = undefined)\n    {\n        super(name, 6, [\n            InputPort().expects(SpeedyPipelineMessageType.Image).satisfying(\n                ( /** @type {SpeedyPipelineMessageWithImage} */ msg ) =>\n                    msg.format === ImageFormat.GREY\n            ),\n            OutputPort().expects(SpeedyPipelineMessageType.Keypoints),\n        ]);\n\n        /** @type {SpeedySize} neighborhood size */\n        this._windowSize = new SpeedySize(3, 3);\n\n        /** @type {number} min corner quality in [0,1] */\n        this._quality = 0.1;\n    }\n\n    /**\n     * Minimum corner quality in [0,1] - this is a fraction of\n     * the largest min. eigenvalue of the autocorrelation matrix\n     * over the entire image\n     * @returns {number}\n     */\n    get quality()\n    {\n        return this._quality;\n    }\n\n    /**\n     * Minimum corner quality in [0,1]\n     * @param {number} quality\n     */\n    set quality(quality)\n    {\n        this._quality = Math.max(0.0, Math.min(+quality, 1.0));\n    }\n\n    /**\n     * Neighborhood size\n     * @returns {SpeedySize}\n     */\n    get windowSize()\n    {\n        return this._windowSize;\n    }\n\n    /**\n     * Neighborhood size\n     * @param {SpeedySize} windowSize\n     */\n    set windowSize(windowSize)\n    {\n        const d = windowSize.width;\n        if(!((d == windowSize.height) && (d == 1 || d == 3 || d == 5 || d == 7)))\n            throw new IllegalArgumentError(`Invalid window: ${windowSize}. Acceptable sizes: 1x1, 3x3, 5x5, 7x7`);\n\n        this._windowSize = windowSize;\n    }\n\n    /**\n     * Run the specific task of this node\n     * @param {SpeedyGPU} gpu\n     * @returns {void|SpeedyPromise<void>}\n     */\n    _run(gpu)\n    {\n        const { image, format } = /** @type {SpeedyPipelineMessageWithImage} */ ( this.input().read() );\n        const width = image.width, height = image.height;\n        const capacity = this._capacity;\n        const quality = this._quality;\n        const windowSize = this._windowSize.width;\n        const levels = this.levels;\n        const lodStep = Math.log2(this.scaleFactor);\n        const intFactor = levels > 1 ? this.scaleFactor : 1;\n        const harris = gpu.programs.keypoints[HARRIS[windowSize]];\n        const tex = this._tex;\n\n        // validate pyramid\n        if(!(levels == 1 || image.hasMipmaps()))\n            throw new IllegalOperationError(`Expected a pyramid in ${this.fullName}`);\n\n        // skip if the capacity is zero\n        if(capacity == 0) {\n            const encodedKeypoints = this._encodeZeroKeypoints(gpu, tex[5]);\n            const encoderLength = encodedKeypoints.width;\n            this.output().swrite(encodedKeypoints, 0, 0, encoderLength);\n            return;\n        }\n\n        // compute corner response map\n        harris.outputs(width, height, tex[0], tex[1]);\n        gpu.programs.utils.sobelDerivatives.outputs(width, height, tex[2]);\n        gpu.programs.keypoints.nonmaxSpace.outputs(width, height, tex[3]);\n        let corners = tex[1].clear();\n        let numPasses = Math.max(1, Math.min(levels, (PYRAMID_MAX_LEVELS / lodStep) | 0));\n        for(let lod = lodStep * (numPasses - 1); numPasses-- > 0; lod -= lodStep) {\n            const gaussian = Utils.gaussianKernel(intFactor * (1 + lod), windowSize);\n            const derivatives = gpu.programs.utils.sobelDerivatives(image, lod);\n            corners = harris(corners, image, derivatives, lod, lodStep, gaussian);\n            corners = gpu.programs.keypoints.nonmaxSpace(corners); // see below*\n        }\n\n        // Same-scale non-maximum suppression\n        // *performs better inside the loop\n        //corners = gpu.programs.keypoints.nonmaxSpace(corners);\n\n        // Multi-scale non-maximum suppression\n        // (doesn't seem to remove many keypoints)\n        if(levels > 1) {\n            const laplacian = (gpu.programs.keypoints.laplacian\n                .outputs(width, height, tex[0])\n            )(corners, image, lodStep, 0);\n\n            corners = (gpu.programs.keypoints.nonmaxScale\n                .outputs(width, height, tex[2])\n            )(corners, image, laplacian, lodStep);\n        }\n\n        // find the maximum corner response over the entire image\n        gpu.programs.keypoints.harrisScoreFindMax.outputs(width, height, tex[0], tex[1]);\n        numPasses = Math.ceil(Math.log2(Math.max(width, height)));\n        let maxScore = corners;\n        for(let j = 0; j < numPasses; j++)\n            maxScore = gpu.programs.keypoints.harrisScoreFindMax(maxScore, j);\n\n        // discard corners below a quality level\n        corners = (gpu.programs.keypoints.harrisScoreCutoff\n            .outputs(width, height, maxScore == tex[0] ? tex[1] : tex[0])\n        )(corners, maxScore, quality);\n\n        // encode keypoints\n        let encodedKeypoints = this._encodeKeypoints(gpu, corners, tex[4]);\n        const encoderLength = encodedKeypoints.width;\n\n        // scale refinement\n        if(levels > 1) {\n            encodedKeypoints = (gpu.programs.keypoints.refineScaleLoG\n                .outputs(encoderLength, encoderLength, tex[5])\n            )(image, lodStep, encodedKeypoints, 0, 0, encoderLength);\n        }\n\n        // done!\n        this.output().swrite(encodedKeypoints, 0, 0, encoderLength);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * distance-filter.js\n * Given a set of pairs of keypoints, discard all pairs whose distance is\n * above a user-defined threshold. Useful for bidirectional optical-flow.\n */\n\nimport { SpeedyPipelineNode } from '../../pipeline-node';\nimport { SpeedyPipelineMessageType, SpeedyPipelineMessageWithKeypoints } from '../../pipeline-message';\nimport { InputPort, OutputPort } from '../../pipeline-portbuilder';\nimport { SpeedyGPU } from '../../../../gpu/speedy-gpu';\nimport { SpeedyTexture } from '../../../../gpu/speedy-texture';\nimport { Utils } from '../../../../utils/utils';\nimport { SpeedyPromise } from '../../../../utils/speedy-promise';\nimport { SpeedyMatrix } from '../../../speedy-matrix';\nimport { IllegalArgumentError, IllegalOperationError } from '../../../../utils/errors';\nimport { MAX_TEXTURE_LENGTH } from '../../../../utils/globals';\n\n\n/**\n * Given a set of pairs of keypoints, discard all pairs whose distance is\n * above a user-defined threshold. Useful for bidirectional optical-flow.\n * \n * The pairs of keypoints are provided as two separate sets, \"in\" and\n * \"reference\". Keypoints that are kept will have their data extracted\n * from the \"in\" set.\n */\nexport class SpeedyPipelineNodeKeypointDistanceFilter extends SpeedyPipelineNode\n{\n    /**\n     * Constructor\n     * @param {string} [name] name of the node\n     */\n    constructor(name = undefined)\n    {\n        super(name, 1, [\n            InputPort('in').expects(SpeedyPipelineMessageType.Keypoints),\n            InputPort('reference').expects(SpeedyPipelineMessageType.Keypoints),\n            OutputPort().expects(SpeedyPipelineMessageType.Keypoints)\n        ]);\n\n        /** @type {number} maximum accepted distance */\n        this._threshold = MAX_TEXTURE_LENGTH + 1;\n    }\n\n    /**\n     * Maximum accepted distance\n     * @returns {number}\n     */\n    get threshold()\n    {\n        return this._threshold;\n    }\n\n    /**\n     * Maximum accepted distance\n     * @param {number} value\n     */\n    set threshold(value)\n    {\n        this._threshold = Math.max(0, +value);\n    }\n\n    /**\n     * Run the specific task of this node\n     * @param {SpeedyGPU} gpu\n     * @returns {void|SpeedyPromise<void>}\n     */\n    _run(gpu)\n    {\n        const set0 = /** @type {SpeedyPipelineMessageWithKeypoints} */ ( this.input('in').read() );\n        const set1 = /** @type {SpeedyPipelineMessageWithKeypoints} */ ( this.input('reference').read() );\n        const threshold = this._threshold;\n\n        // validate shapes\n        if(set0.descriptorSize != set1.descriptorSize || set0.extraSize != set1.extraSize)\n            throw new IllegalOperationError(`The distance filter requires two compatible shapes of keypoint streams`);\n\n        // calculate the shape of the output\n        const outputTexture = this._tex[0];\n        const encoderLength = Math.max(set0.encoderLength, set1.encoderLength);\n        const descriptorSize = set0.descriptorSize;\n        const extraSize = set0.extraSize;\n\n        // apply the distance filter\n        (gpu.programs.keypoints.distanceFilter\n            .outputs(encoderLength, encoderLength, outputTexture)\n        )(set0.encodedKeypoints, set0.encoderLength, set1.encodedKeypoints, set1.encoderLength, descriptorSize, extraSize, encoderLength, threshold);\n\n        // done!\n        this.output().swrite(outputTexture, descriptorSize, extraSize, encoderLength);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * hamming-distance-filter.js\n * Given a set of pairs of keypoints, discard all pairs whose hamming\n * distance (of descriptor) is above a user-defined threshold\n */\n\nimport { SpeedyPipelineNode } from '../../pipeline-node';\nimport { SpeedyPipelineMessageType, SpeedyPipelineMessageWithKeypoints } from '../../pipeline-message';\nimport { InputPort, OutputPort } from '../../pipeline-portbuilder';\nimport { SpeedyGPU } from '../../../../gpu/speedy-gpu';\nimport { SpeedyTexture } from '../../../../gpu/speedy-texture';\nimport { Utils } from '../../../../utils/utils';\nimport { SpeedyPromise } from '../../../../utils/speedy-promise';\nimport { SpeedyMatrix } from '../../../speedy-matrix';\nimport { IllegalArgumentError, IllegalOperationError, NotSupportedError } from '../../../../utils/errors';\nimport { MAX_DESCRIPTOR_SIZE } from '../../../../utils/globals';\n\n/** @type {Object<number,string>} Program names */\nconst PROGRAM_NAME = {\n    32: 'hammingDistanceFilter32',\n    64: 'hammingDistanceFilter64',\n};\n\n\n/**\n * Given a set of pairs of keypoints, discard all pairs whose hamming\n * distance (of descriptor) is above a user-defined threshold\n * \n * The pairs of keypoints are provided as two separate sets, \"in\" and\n * \"reference\". Keypoints that are kept will have their data extracted\n * from the \"in\" set.\n */\nexport class SpeedyPipelineNodeKeypointHammingDistanceFilter extends SpeedyPipelineNode\n{\n    /**\n     * Constructor\n     * @param {string} [name] name of the node\n     */\n    constructor(name = undefined)\n    {\n        super(name, 1, [\n            InputPort('in').expects(SpeedyPipelineMessageType.Keypoints).satisfying(\n                ( /** @type {SpeedyPipelineMessageWithKeypoints} */ msg ) =>\n                    msg.descriptorSize > 0\n            ),\n            InputPort('reference').expects(SpeedyPipelineMessageType.Keypoints).satisfying(\n                ( /** @type {SpeedyPipelineMessageWithKeypoints} */ msg ) =>\n                    msg.descriptorSize > 0\n            ),\n            OutputPort().expects(SpeedyPipelineMessageType.Keypoints)\n        ]);\n\n        /** @type {number} distance threshold, an integer */\n        this._threshold = MAX_DESCRIPTOR_SIZE * 8; // convert from bytes to bits\n    }\n\n    /**\n     * Distance threshold, an integer\n     * @returns {number}\n     */\n    get threshold()\n    {\n        return this._threshold;\n    }\n\n    /**\n     * Distance threshold, an integer\n     * @param {number} value\n     */\n    set threshold(value)\n    {\n        this._threshold = Math.max(0, value | 0);\n    }\n\n    /**\n     * Run the specific task of this node\n     * @param {SpeedyGPU} gpu\n     * @returns {void|SpeedyPromise<void>}\n     */\n    _run(gpu)\n    {\n        const set0 = /** @type {SpeedyPipelineMessageWithKeypoints} */ ( this.input('in').read() );\n        const set1 = /** @type {SpeedyPipelineMessageWithKeypoints} */ ( this.input('reference').read() );\n        const threshold = this._threshold;\n\n        // validate shapes\n        if(set0.descriptorSize != set1.descriptorSize || set0.extraSize != set1.extraSize)\n            throw new IllegalOperationError(`The Hamming distance filter requires two compatible shapes of keypoint streams`);\n\n        // validate descriptor size\n        if(!Object.prototype.hasOwnProperty.call(PROGRAM_NAME, set0.descriptorSize))\n            throw new NotSupportedError(`Hamming distance filter - invalid descriptor size: ${set0.descriptorSize}`);\n\n        // calculate the shape of the output\n        const outputTexture = this._tex[0];\n        const encoderLength = Math.max(set0.encoderLength, set1.encoderLength);\n        const descriptorSize = set0.descriptorSize;\n        const extraSize = set0.extraSize;\n\n        // apply the distance filter\n        const program = PROGRAM_NAME[set0.descriptorSize];\n        (gpu.programs.keypoints[program]\n            .outputs(encoderLength, encoderLength, outputTexture)\n        )(set0.encodedKeypoints, set0.encoderLength, set1.encodedKeypoints, set1.encoderLength, descriptorSize, extraSize, encoderLength, threshold);\n\n        // done!\n        this.output().swrite(outputTexture, descriptorSize, extraSize, encoderLength);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * bf-knn.js\n * Brute Force KNN Keypoint Matcher\n */\n\nimport { SpeedyPipelineNode } from '../../../pipeline-node';\nimport { SpeedyPipelineMessageType, SpeedyPipelineMessageWithKeypoints } from '../../../pipeline-message';\nimport { InputPort, OutputPort } from '../../../pipeline-portbuilder';\nimport { SpeedyPipelineNodeKeypointDetector } from '../detectors/detector';\nimport { SpeedyGPU } from '../../../../../gpu/speedy-gpu';\nimport { SpeedyTexture, SpeedyDrawableTexture } from '../../../../../gpu/speedy-texture';\nimport { Utils } from '../../../../../utils/utils';\nimport { IllegalArgumentError, NotSupportedError } from '../../../../../utils/errors';\nimport { SpeedyPromise } from '../../../../../utils/speedy-promise';\n\n/** @type {Object<number,string>} program name indexed by descriptor size */\nconst PROGRAM_NAME = {\n    32: 'bfMatcher32',\n    64: 'bfMatcher64',\n};\n\n/**\n * Brute Force KNN Keypoint Matcher. Make sure to use a Keypoint Clipper before\n * invoking this (use a database of 50 keypoints or so - your mileage may vary)\n */\nexport class SpeedyPipelineNodeBruteForceKNNKeypointMatcher extends SpeedyPipelineNode\n{\n    /**\n     * Constructor\n     * @param {string} [name] name of the node\n     */\n    constructor(name = undefined)\n    {\n        super(name, 6, [\n            InputPort('keypoints').expects(SpeedyPipelineMessageType.Keypoints).satisfying(\n                ( /** @type {SpeedyPipelineMessageWithKeypoints} */ msg ) =>\n                    msg.descriptorSize > 0\n            ),\n            InputPort('database').expects(SpeedyPipelineMessageType.Keypoints).satisfying(\n                ( /** @type {SpeedyPipelineMessageWithKeypoints} */ msg ) =>\n                    msg.descriptorSize > 0\n            ),\n            OutputPort().expects(SpeedyPipelineMessageType.KeypointMatches),\n        ]);\n\n        /** @type {number} number of matches per keypoint (the \"k\" of knn) */\n        this._matchesPerKeypoint = 1;\n    }\n\n    /**\n     * Number of matches per keypoint\n     * @returns {number}\n     */\n    get k()\n    {\n        return this._matchesPerKeypoint;\n    }\n\n    /**\n     * Number of matches per keypoint\n     * @param {number} value\n     */\n    set k(value)\n    {\n        this._matchesPerKeypoint = Math.max(1, value | 0);\n    }\n\n    /**\n     * Run the specific task of this node\n     * @param {SpeedyGPU} gpu\n     * @returns {void|SpeedyPromise<void>}\n     */\n    _run(gpu)\n    {\n        const { encodedKeypoints, descriptorSize, extraSize, encoderLength } = /** @type {SpeedyPipelineMessageWithKeypoints} */ ( this.input('keypoints').read() );\n        const database = /** @type {SpeedyPipelineMessageWithKeypoints} */ ( this.input('database').read() );\n        const candidatesA = this._tex[0];\n        const candidatesB = this._tex[1];\n        const candidatesC = this._tex[2];\n        const encodedFiltersA = this._tex[3];\n        const encodedMatchesA = this._tex[4];\n        const encodedMatchesB = this._tex[5];\n        const matchesPerKeypoint = this._matchesPerKeypoint;\n        const keypoints = gpu.programs.keypoints;\n\n        // validate parameters\n        if(descriptorSize !== database.descriptorSize)\n            throw new IllegalArgumentError(`Incompatible descriptors in ${this.fullName}`);\n        else if(!Object.prototype.hasOwnProperty.call(PROGRAM_NAME, descriptorSize))\n            throw new NotSupportedError(`Unsupported descriptor size (${descriptorSize}) in ${this.fullName}`);\n\n        // prepare the brute force matching\n        const bfMatcher = keypoints[PROGRAM_NAME[descriptorSize]];\n        const capacity = SpeedyPipelineNodeKeypointDetector.encoderCapacity(descriptorSize, extraSize, encoderLength);\n        const dbCapacity = SpeedyPipelineNodeKeypointDetector.encoderCapacity(database.descriptorSize, database.extraSize, database.encoderLength);\n        const numberOfKeypointsPerPass = bfMatcher.definedConstant('NUMBER_OF_KEYPOINTS_PER_PASS');\n        const numberOfPasses = Math.ceil(dbCapacity / numberOfKeypointsPerPass);\n        const partialMatcherLength = Math.max(1, Math.ceil(Math.sqrt(capacity)));\n        const matcherLength = Math.max(1, Math.ceil(Math.sqrt(capacity * matchesPerKeypoint)));\n        keypoints.bfMatcherTransfer.outputs(matcherLength, matcherLength, encodedMatchesA, encodedMatchesB);\n        keypoints.bfMatcherInitCandidates.outputs(partialMatcherLength, partialMatcherLength, candidatesC);\n        keypoints.bfMatcherInitFilters.outputs(partialMatcherLength, partialMatcherLength, encodedFiltersA);\n        bfMatcher.outputs(partialMatcherLength, partialMatcherLength, candidatesA, candidatesB);\n\n        // match keypoints\n        let encodedMatches = encodedMatchesB.clear(); // will hold all best matches\n        let encodedFilters = keypoints.bfMatcherInitFilters();\n        for(let k = 0; k < matchesPerKeypoint; k++) {\n            let encodedPartialMatches = keypoints.bfMatcherInitCandidates(); // hold the (k+1)-th best matches\n\n            // find the (k+1)-th best match\n            for(let passId = 0; passId < numberOfPasses; passId++) {\n                encodedPartialMatches = bfMatcher(\n                    encodedPartialMatches, encodedFilters, partialMatcherLength,\n                    database.encodedKeypoints, database.descriptorSize, database.extraSize, database.encoderLength,\n                    encodedKeypoints, descriptorSize, extraSize, encoderLength,\n                    passId\n                );\n                gpu.gl.flush();\n            }\n\n            // copy the (k+1)-th best match to the filter\n            if(matchesPerKeypoint > 1)\n                encodedPartialMatches.copyTo(encodedFilters);\n\n            // aggregate matches\n            encodedMatches = keypoints.bfMatcherTransfer(\n                encodedMatches, encodedPartialMatches, matchesPerKeypoint, k\n            );\n        }\n\n        // done!\n        this.output().swrite(encodedMatches, matchesPerKeypoint);\n    }\n}\n","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * lsh-knn.js\n * K approximate nearest neighbors matcher\n */\n\nimport { SpeedyPipelineNode } from '../../../pipeline-node';\nimport { SpeedyPipelineMessageType, SpeedyPipelineMessageWithKeypoints, SpeedyPipelineMessageWithLSHTables } from '../../../pipeline-message';\nimport { InputPort, OutputPort } from '../../../pipeline-portbuilder';\nimport { SpeedyPipelineNodeKeypointDetector } from '../detectors/detector';\nimport { SpeedyGPU } from '../../../../../gpu/speedy-gpu';\nimport { SpeedyLSH, LSH_ACCEPTABLE_DESCRIPTOR_SIZES, LSH_ACCEPTABLE_HASH_SIZES } from '../../../../../gpu/speedy-lsh';\nimport { SpeedyTexture, SpeedyDrawableTexture } from '../../../../../gpu/speedy-texture';\nimport { Utils } from '../../../../../utils/utils';\nimport { IllegalArgumentError } from '../../../../../utils/errors';\nimport { SpeedyPromise } from '../../../../../utils/speedy-promise';\n\n/** @typedef {'fastest' | 'default' | 'demanding'} LSHKNNQualityLevel quality of the approximate matching */\n\n/** @type {number} how many neighbors to search for, by default */\nconst DEFAULT_K = 1;\n\n/** @type {LSHKNNQualityLevel} default quality level */\nconst DEFAULT_QUALITY = 'default';\n\n/** @type {{ [key in LSHKNNQualityLevel]: number }} maps quality level to bit swaps */\nconst NUMBER_OF_BIT_SWAPS = {\n    'fastest': 0,\n    'default': 1,\n    'demanding': 2,\n};\n\n/** @type {object} program names indexed as LSH_KNN[descriptorSize][hashSize][level] */\nconst LSH_KNN = (fd => LSH_ACCEPTABLE_DESCRIPTOR_SIZES.reduce((o,d) => ((o[d] = fd(d)), o), {}))(\n    d => ((fh => LSH_ACCEPTABLE_HASH_SIZES.reduce((o,h) => ((o[h] = fh(h)), o), {}))(\n        h => ((fl => [0,1,2].reduce((o,l) => ((o[l] = fl(l)), o), {}))(\n            l => `lshKnn${d}h${h}lv${l}`\n        ))\n    ))\n);\n\n\n\n/**\n * K approximate nearest neighbors matcher\n */\nexport class SpeedyPipelineNodeLSHKNNMatcher extends SpeedyPipelineNode\n{\n    /**\n     * Constructor\n     * @param {string} [name] name of the node\n     */\n    constructor(name = undefined)\n    {\n        super(name, 6, [\n            InputPort('keypoints').expects(SpeedyPipelineMessageType.Keypoints).satisfying(\n                ( /** @type {SpeedyPipelineMessageWithKeypoints} */ msg ) =>\n                    msg.descriptorSize > 0\n            ),\n            InputPort('lsh').expects(SpeedyPipelineMessageType.LSHTables),\n            OutputPort().expects(SpeedyPipelineMessageType.KeypointMatches),\n        ]);\n\n        /** @type {number} how many neighbors do you want? */\n        this._k = DEFAULT_K;\n\n        /** @type {LSHKNNQualityLevel} quality of the matching */\n        this._quality = DEFAULT_QUALITY;\n    }\n\n    /**\n     * How many neighbors do you want?\n     * @returns {number}\n     */\n    get k()\n    {\n        return this._k;\n    }\n\n    /**\n     * How many neighbors do you want?\n     * @param {number} k number of neighbors\n     */\n    set k(k)\n    {\n        this._k = Math.max(1, k | 0);\n    }\n\n    /**\n     * Quality of the matching\n     * @returns {LSHKNNQualityLevel}\n     */\n    get quality()\n    {\n        return this._quality;\n    }\n\n    /**\n     * Quality of the matching\n     * @param {LSHKNNQualityLevel} quality\n     */\n    set quality(quality)\n    {\n        if(!Object.prototype.hasOwnProperty.call(NUMBER_OF_BIT_SWAPS, quality))\n            throw new IllegalArgumentError(`Invalid quality level: \"${quality}\"`);\n\n        this._quality = quality;\n    }\n\n    /**\n     * Run the specific task of this node\n     * @param {SpeedyGPU} gpu\n     * @returns {void|SpeedyPromise<void>}\n     */\n    _run(gpu)\n    {\n        const { encodedKeypoints, descriptorSize, extraSize, encoderLength } = /** @type {SpeedyPipelineMessageWithKeypoints} */ ( this.input('keypoints').read() );\n        /** @type {SpeedyLSH} */ const lsh = this.input('lsh').read().lsh;\n        const keypoints = gpu.programs.keypoints;\n        const tables = lsh.tables;\n        const descriptorDB = lsh.descriptorDB;\n        const tablesStride = tables.width;\n        const descriptorDBStride = descriptorDB.width;\n        const tableCount = lsh.tableCount;\n        const hashSize = lsh.hashSize;\n        const bucketCapacity = lsh.bucketCapacity;\n        const bucketsPerTable = lsh.bucketsPerTable;\n        const sequences = lsh.sequences;\n        const candidatesA = this._tex[0];\n        const candidatesB = this._tex[1];\n        const candidatesC = this._tex[2];\n        const filters = this._tex[3];\n        const transferA = this._tex[4];\n        const transferB = this._tex[5];\n        const level = NUMBER_OF_BIT_SWAPS[this._quality];\n        const matchesPerKeypoint = this._k;\n\n        // validate parameters\n        if(descriptorSize !== lsh.descriptorSize)\n            throw new IllegalArgumentError(`Can't match different types of descriptors in ${this.fullName}`);\n\n        Utils.assert(LSH_KNN[descriptorSize] != undefined);\n        Utils.assert(LSH_KNN[descriptorSize][hashSize] != undefined);\n        Utils.assert(LSH_KNN[descriptorSize][hashSize][level] != undefined);\n\n        // configure the output texture\n        const capacity = SpeedyPipelineNodeKeypointDetector.encoderCapacity(descriptorSize, extraSize, encoderLength);\n        const matcherLength = Math.max(1, Math.ceil(Math.sqrt(capacity * matchesPerKeypoint)));\n        let encodedMatches = transferB;\n        keypoints.lshKnnTransfer.outputs(matcherLength, matcherLength, transferA, transferB);\n\n        // prepare the LSH matching\n        const kthMatcherLength = Math.max(1, Math.ceil(Math.sqrt(capacity)));\n        keypoints.lshKnnInitCandidates.outputs(kthMatcherLength, kthMatcherLength, candidatesA);\n        keypoints.lshKnnInitFilters.outputs(kthMatcherLength, kthMatcherLength, filters);\n\n        const lshKnn = keypoints[LSH_KNN[descriptorSize][hashSize][level]];\n        lshKnn.outputs(kthMatcherLength, kthMatcherLength, candidatesB, candidatesC);\n        lshKnn.setUBO('LSHSequences', sequences);\n\n        // match keypoints\n        encodedMatches.clear();\n        keypoints.lshKnnInitFilters();\n        for(let i = 0; i < matchesPerKeypoint; i++) {\n            // find the (i+1)-th best match\n            let candidates = keypoints.lshKnnInitCandidates();\n            for(let tableIndex = 0; tableIndex < tableCount; tableIndex++) {\n                candidates = lshKnn(candidates, filters, kthMatcherLength, tables, descriptorDB, tableIndex, bucketCapacity, bucketsPerTable, tablesStride, descriptorDBStride, encodedKeypoints, descriptorSize, extraSize, encoderLength);\n                gpu.gl.flush();\n            }\n            candidates.copyTo(filters);\n\n            // transfer matches to an encoded matches texture\n            encodedMatches = keypoints.lshKnnTransfer(encodedMatches, candidates, matchesPerKeypoint, i);\n        }\n\n        // done\n        this.output().swrite(encodedMatches, matchesPerKeypoint);\n\n        /*\n        // debug\n        let data = this._inspect32(filters), debug = [];\n        for(let i = 0; i < data.length; i++) {\n            const bits = MATCH_INDEX_BITS;\n            const mask = (1 << bits) - 1;\n            const u32 = data[i];\n            const index = u32 & mask, distance = u32 >>> bits;\n            //debug.push('|'+[ u32 ].toString());\n            debug.push('|'+[ index, distance ].toString());\n        }\n        console.log(debug.join(','));\n        */\n    }\n}\n","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * lsh-static-tables.js\n * Static LSH tables\n */\n\nimport { SpeedyPipelineNode, SpeedyPipelineSourceNode } from '../../../pipeline-node';\nimport { SpeedyPipelineMessageType, SpeedyPipelineMessageWithKeypoints } from '../../../pipeline-message';\nimport { InputPort, OutputPort } from '../../../pipeline-portbuilder';\nimport { SpeedyKeypoint } from '../../../../speedy-keypoint';\nimport { SpeedyKeypointDescriptor } from '../../../../speedy-keypoint-descriptor';\nimport { SpeedyGPU } from '../../../../../gpu/speedy-gpu';\nimport { SpeedyTexture, SpeedyDrawableTexture } from '../../../../../gpu/speedy-texture';\nimport { IllegalArgumentError, IllegalOperationError } from '../../../../../utils/errors';\nimport { Utils } from '../../../../../utils/utils';\nimport { SpeedyPromise } from '../../../../../utils/speedy-promise';\nimport {\n    SpeedyLSH,\n    LSH_DEFAULT_HASH_SIZE, LSH_DEFAULT_NUMBER_OF_TABLES,\n    LSH_ACCEPTABLE_HASH_SIZES, LSH_ACCEPTABLE_NUMBER_OF_TABLES\n} from '../../../../../gpu/speedy-lsh';\n\n\n\n/**\n * Static LSH tables\n */\nexport class SpeedyPipelineNodeStaticLSHTables extends SpeedyPipelineSourceNode\n{\n    /**\n     * Constructor\n     * @param {string} [name] name of the node\n     */\n    constructor(name = undefined)\n    {\n        super(name, 2, [\n            OutputPort().expects(SpeedyPipelineMessageType.LSHTables)\n        ]);\n\n        /** @type {SpeedyKeypoint[]} \"training\" keypoints */\n        this._keypoints = [];\n\n        /** @type {SpeedyKeypoint[]} internal copy of the \"training\" keypoints */\n        this._keypointsCopy = [];\n\n        /** @type {number} number of tables in the LSH data structure */\n        this._numberOfTables = LSH_DEFAULT_NUMBER_OF_TABLES;\n\n        /** @type {number} number of bits of a hash */\n        this._hashSize = LSH_DEFAULT_HASH_SIZE;\n\n        /** @type {SpeedyLSH|null} LSH data structure */\n        this._lsh = null;\n    }\n\n    /**\n     * \"Training\" keypoints\n     * @returns {SpeedyKeypoint[]}\n     */\n    get keypoints()\n    {\n        return this._keypoints;\n    }\n\n    /**\n     * \"Training\" keypoints\n     * @param {SpeedyKeypoint[]} keypoints\n     */\n    set keypoints(keypoints)\n    {\n        if(!Array.isArray(keypoints) || keypoints.find(keypoint => !(keypoint instanceof SpeedyKeypoint)))\n            throw new IllegalArgumentError(`Static LSH tables: an invalid set of keypoints has been provided`);\n\n        if(this._keypoints !== keypoints) {\n            this._keypoints = keypoints; // update internal pointer\n            this._keypointsCopy = keypoints.slice(0); // clone the array, so it won't be modified externally\n            this._lsh = null; // (re)train the model\n        }\n    }\n\n    /**\n     * Number of tables in the LSH data structure\n     * @returns {number}\n     */\n    get numberOfTables()\n    {\n        return this._numberOfTables;\n    }\n\n    /**\n     * Number of tables in the LSH data structure\n     * @param {number} n\n     */\n    set numberOfTables(n)\n    {\n        if(!LSH_ACCEPTABLE_NUMBER_OF_TABLES.includes(n))\n            throw new IllegalArgumentError(`Invalid number of tables: ${n}. Acceptable values: ${LSH_ACCEPTABLE_NUMBER_OF_TABLES.join(', ')}`);\n\n        if(n !== this._numberOfTables) {\n            this._numberOfTables = n | 0;\n            this._lsh = null; // need to retrain the model\n        }\n    }\n\n    /**\n     * Number of bits of a hash\n     * @returns {number}\n     */\n    get hashSize()\n    {\n        return this._hashSize;\n    }\n\n    /**\n     * Number of bits of a hash\n     * @param {number} h\n     */\n    set hashSize(h)\n    {\n        if(!LSH_ACCEPTABLE_HASH_SIZES.includes(h))\n            throw new IllegalArgumentError(`Invalid hash size: ${h}. Acceptable values: ${LSH_ACCEPTABLE_HASH_SIZES.join(', ')}`);\n\n        if(h !== this._hashSize) {\n            this._hashSize = h | 0;\n            this._lsh = null; // need to retrain the model\n        }\n    }\n\n    /**\n     * Run the specific task of this node\n     * @param {SpeedyGPU} gpu\n     * @returns {void|SpeedyPromise<void>}\n     */\n    _run(gpu)\n    {\n        // Need to train the model?\n        if(this._lsh == null) {\n            // internal work textures are only available after initialization,\n            // i.e., after calling this._init()\n            this._lsh = this._train();\n        }\n\n        // Pass it forward\n        this.output().swrite(this._lsh);\n    }\n\n    /**\n     * Train the model\n     * @returns {SpeedyLSH}\n     */\n    _train()\n    {\n        const keypoints = this._keypointsCopy;\n        const numberOfTables = this._numberOfTables;\n        const hashSize = this._hashSize;\n\n        if(keypoints.find(keypoint => keypoint.descriptor == null))\n            throw new IllegalOperationError(`Static LSH tables: can't train the model with no keypoint descriptors!`);\n\n        const descriptors = keypoints.map(keypoint => keypoint.descriptor.data);\n        const lshTables = this._tex[0];\n        const descriptorDB = this._tex[1];\n\n        return new SpeedyLSH(lshTables, descriptorDB, descriptors, numberOfTables, hashSize);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * mixer.js\n * Keypoint Mixer\n */\n\nimport { SpeedyPipelineNode } from '../../pipeline-node';\nimport { SpeedyPipelineNodeKeypointDetector } from './detectors/detector';\nimport { SpeedyPipelineMessageType, SpeedyPipelineMessageWithKeypoints } from '../../pipeline-message';\nimport { InputPort, OutputPort } from '../../pipeline-portbuilder';\nimport { SpeedyGPU } from '../../../../gpu/speedy-gpu';\nimport { SpeedyTexture } from '../../../../gpu/speedy-texture';\nimport { Utils } from '../../../../utils/utils';\nimport { IllegalOperationError } from '../../../../utils/errors';\nimport { MAX_ENCODER_CAPACITY } from '../../../../utils/globals';\nimport { SpeedyPromise } from '../../../../utils/speedy-promise';\n\n/**\n * Keypoint Mixer: merges two sets of keypoints\n */\nexport class SpeedyPipelineNodeKeypointMixer extends SpeedyPipelineNode\n{\n    /**\n     * Constructor\n     * @param {string} [name] name of the node\n     */\n    constructor(name = undefined)\n    {\n        super(name, 5, [\n            InputPort('in0').expects(SpeedyPipelineMessageType.Keypoints),\n            InputPort('in1').expects(SpeedyPipelineMessageType.Keypoints),\n            OutputPort().expects(SpeedyPipelineMessageType.Keypoints)\n        ]);\n    }\n\n    /**\n     * Run the specific task of this node\n     * @param {SpeedyGPU} gpu\n     * @returns {void|SpeedyPromise<void>}\n     */\n    _run(gpu)\n    {\n        const kps0 = /** @type {SpeedyPipelineMessageWithKeypoints} */ ( this.input('in0').read() );\n        const kps1 = /** @type {SpeedyPipelineMessageWithKeypoints} */ ( this.input('in1').read() );\n        const descriptorSize = kps0.descriptorSize;\n        const extraSize = kps0.extraSize;\n        const keypoints = gpu.programs.keypoints;\n        const tex = this._tex;\n\n        // ensure that the format of kps0 equals the format of kps1\n        if(!(kps0.descriptorSize === kps1.descriptorSize && kps0.extraSize === kps0.extraSize))\n            throw new IllegalOperationError(`Can't merge two sets of keypoints that have different formats`);\n\n        // find the capacity of kps0 + kps1\n        const cap0 = SpeedyPipelineNodeKeypointDetector.encoderCapacity(kps0.descriptorSize, kps0.extraSize, kps0.encoderLength);\n        const cap1 = SpeedyPipelineNodeKeypointDetector.encoderCapacity(kps1.descriptorSize, kps1.extraSize, kps1.encoderLength);\n        const capacity = cap0 + cap1;\n\n        // find the dimensions of the output texture\n        const encoderLength = SpeedyPipelineNodeKeypointDetector.encoderLength(capacity, descriptorSize, extraSize);\n        const mixEncoderLength = Math.max(1, Math.ceil(Math.sqrt(capacity)));\n\n        // prepare programs\n        keypoints.mixKeypointsPreInit.outputs(encoderLength, encoderLength, tex[0]);\n        keypoints.mixKeypointsInit.outputs(mixEncoderLength, mixEncoderLength, tex[1]);\n        keypoints.mixKeypointsSort.outputs(mixEncoderLength, mixEncoderLength, tex[2], tex[3]);\n        keypoints.mixKeypointsApply.outputs(encoderLength, encoderLength, tex[4]);\n\n        // mix keypoints\n        let mixedKeypoints = keypoints.mixKeypointsPreInit(\n            kps0.encodedKeypoints, kps1.encodedKeypoints,\n            kps0.encoderLength, kps1.encoderLength,\n            cap0, cap1,\n            descriptorSize,\n            extraSize,\n            encoderLength\n        );\n\n        let sortedKeypoints = keypoints.mixKeypointsInit(\n            mixedKeypoints, descriptorSize, extraSize, encoderLength, capacity\n        );\n\n        for(let b = 1; b < capacity; b *= 2)\n            sortedKeypoints = keypoints.mixKeypointsSort(sortedKeypoints, b);\n\n        mixedKeypoints = keypoints.mixKeypointsApply(\n            sortedKeypoints, mixedKeypoints, descriptorSize, extraSize, encoderLength\n        );\n\n        /*\n        // debug: view keypoints\n        keypoints.mixKeypointsView.outputs(mixEncoderLength, mixEncoderLength, tex[1]);\n        this._visualize(gpu, keypoints.mixKeypointsView(sortedKeypoints));\n        */\n\n        this.output().swrite(mixedKeypoints, descriptorSize, extraSize, encoderLength);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * multiplexer.js\n * Keypoint multiplexer\n */\n\nimport { SpeedyPipelineNode, SpeedyPipelineSourceNode } from '../../pipeline-node';\nimport { SpeedyPipelineMessageType } from '../../pipeline-message';\nimport { InputPort, OutputPort } from '../../pipeline-portbuilder';\nimport { SpeedyGPU } from '../../../../gpu/speedy-gpu';\nimport { SpeedyTexture } from '../../../../gpu/speedy-texture';\nimport { SpeedyMedia } from '../../../speedy-media';\nimport { Utils } from '../../../../utils/utils';\nimport { IllegalArgumentError } from '../../../../utils/errors';\nimport { SpeedyPromise } from '../../../../utils/speedy-promise';\n\n/** @type {string[]} the names of the input ports indexed by their number */\nconst INPUT_PORT = [ 'in0', 'in1' ];\n\n/**\n * Keypoint multiplexer\n */\nexport class SpeedyPipelineNodeKeypointMultiplexer extends SpeedyPipelineNode\n{\n    /**\n     * Constructor\n     * @param {string} [name] name of the node\n     */\n    constructor(name = undefined)\n    {\n        super(name, 0, [\n            ...(INPUT_PORT.map(portName => InputPort(portName).expects(SpeedyPipelineMessageType.Keypoints))),\n            OutputPort().expects(SpeedyPipelineMessageType.Keypoints),\n        ]);\n\n        /** @type {number} which port should be linked to the output? */\n        this._port = 0;\n    }\n\n    /**\n     * The number of the port that should be linked to the output\n     * @returns {number}\n     */\n    get port()\n    {\n        return this._port;\n    }\n\n    /**\n     * The number of the port that should be linked to the output\n     * @param {number} port\n     */\n    set port(port)\n    {\n        if(port < 0 || port >= INPUT_PORT.length)\n            throw new IllegalArgumentError(`Invalid port: ${port}`);\n\n        this._port = port | 0;\n    }\n\n    /**\n     * Run the specific task of this node\n     * @param {SpeedyGPU} gpu\n     * @returns {void|SpeedyPromise<void>}\n     */\n    _run(gpu)\n    {\n        const message = this.input(INPUT_PORT[this._port]).read();\n\n        this.output().write(message);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * portal.js\n * Keypoint Portals\n */\n\nimport { SpeedyPipelineNode, SpeedyPipelineSourceNode } from '../../pipeline-node';\nimport { SpeedyPipelineMessageType, SpeedyPipelineMessageWithKeypoints } from '../../pipeline-message';\nimport { SpeedyPipelineNodeKeypointDetector } from './detectors/detector';\nimport { InputPort, OutputPort } from '../../pipeline-portbuilder';\nimport { SpeedyGPU } from '../../../../gpu/speedy-gpu';\nimport { SpeedyTexture } from '../../../../gpu/speedy-texture';\nimport { Utils } from '../../../../utils/utils';\nimport { IllegalOperationError, IllegalArgumentError } from '../../../../utils/errors';\nimport { SpeedyPromise } from '../../../../utils/speedy-promise';\n\n\n\n/**\n * A sink of a Keypoint Portal\n * This is not a pipeline sink - it doesn't export any data!\n */\nexport class SpeedyPipelineNodeKeypointPortalSink extends SpeedyPipelineNode\n{\n    /**\n     * Constructor\n     * @param {string} [name] name of the node\n     */\n    constructor(name = undefined)\n    {\n        super(name, 1, [\n            InputPort().expects(SpeedyPipelineMessageType.Keypoints),\n        ]);\n\n        /** @type {number} descriptor size, in bytes */\n        this._descriptorSize = 0;\n\n        /** @type {number} extra size, in bytes */\n        this._extraSize = 0;\n\n        /** @type {number} extra size */\n        this._encoderLength = 0;\n\n        /** @type {boolean} is this node initialized? */\n        this._initialized = false;\n    }\n\n    /**\n     * Encoded keypoints\n     * @returns {SpeedyTexture}\n     */\n    get encodedKeypoints()\n    {\n        if(!this._initialized)\n            throw new IllegalOperationError(`Portal error: ${this.fullName} holds no data`);\n\n        return this._tex[0];\n    }\n\n    /**\n     * Descriptor size, in bytes\n     * @returns {number}\n     */\n    get descriptorSize()\n    {\n        if(!this._initialized)\n            throw new IllegalOperationError(`Portal error: ${this.fullName} holds no data`);\n\n        return this._descriptorSize;\n    }\n\n    /**\n     * Extra size, in bytes\n     * @returns {number}\n     */\n    get extraSize()\n    {\n        if(!this._initialized)\n            throw new IllegalOperationError(`Portal error: ${this.fullName} holds no data`);\n\n        return this._extraSize;\n    }\n\n    /**\n     * Encoder length\n     * @returns {number}\n     */\n    get encoderLength()\n    {\n        if(!this._initialized)\n            throw new IllegalOperationError(`Portal error: ${this.fullName} holds no data`);\n\n        return this._encoderLength;\n    }\n\n    /**\n     * Initializes this node\n     * @param {SpeedyGPU} gpu\n     */\n    init(gpu)\n    {\n        super.init(gpu);\n\n        const encoderLength = SpeedyPipelineNodeKeypointDetector.encoderLength(0, 0, 0);\n        this._tex[0].resize(encoderLength, encoderLength).clearToColor(1,1,1,1); // initial texture\n        this._descriptorSize = this._extraSize = 0;\n        this._encoderLength = encoderLength;\n\n        this._initialized = true;\n    }\n\n    /**\n     * Releases this node\n     * @param {SpeedyGPU} gpu\n     */\n    release(gpu)\n    {\n        this._initialized = false;\n        super.release(gpu);\n    }\n\n    /**\n     * Run the specific task of this node\n     * @param {SpeedyGPU} gpu\n     * @returns {void|SpeedyPromise<void>}\n     */\n    _run(gpu)\n    {\n        const { encodedKeypoints, descriptorSize, extraSize, encoderLength } = /** @type {SpeedyPipelineMessageWithKeypoints} */ ( this.input().read() );\n        const tex = this._tex[0];\n\n        // copy input\n        tex.resize(encodedKeypoints.width, encodedKeypoints.height);\n        encodedKeypoints.copyTo(tex);\n        this._descriptorSize = descriptorSize;\n        this._extraSize = extraSize;\n        this._encoderLength = encoderLength;\n    }\n}\n\n\n\n/**\n * A source of a Keypoint Portal\n */\nexport class SpeedyPipelineNodeKeypointPortalSource extends SpeedyPipelineSourceNode\n{\n    /**\n     * Constructor\n     * @param {string} [name] name of the node\n     */\n    constructor(name = undefined)\n    {\n        super(name, 0, [\n            OutputPort().expects(SpeedyPipelineMessageType.Keypoints),\n        ]);\n\n        /** @type {SpeedyPipelineNodeKeypointPortalSink|null} portal sink */\n        this._source = null;\n    }\n\n    /**\n     * Data source\n     * @returns {SpeedyPipelineNodeKeypointPortalSink|null}\n     */\n    get source()\n    {\n        return this._source;\n    }\n\n    /**\n     * Data source\n     * @param {SpeedyPipelineNodeKeypointPortalSink|null} node\n     */\n    set source(node)\n    {\n        if(node !== null && !(node instanceof SpeedyPipelineNodeKeypointPortalSink))\n            throw new IllegalArgumentError(`Incompatible source for ${this.fullName}`);\n\n        this._source = node;\n    }\n\n    /**\n     * Run the specific task of this node\n     * @param {SpeedyGPU} gpu\n     * @returns {void|SpeedyPromise<void>}\n     */\n    _run(gpu)\n    {\n        if(this._source == null)\n            throw new IllegalOperationError(`${this.fullName} has no source`);\n\n        this.output().swrite(this._source.encodedKeypoints, this._source.descriptorSize, this._source.extraSize, this._source.encoderLength);\n    }\n}\n","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * shuffler.js\n * Keypoint Shuffler\n */\n\nimport { SpeedyPipelineNode } from '../../pipeline-node';\nimport { SpeedyPipelineNodeKeypointDetector } from './detectors/detector';\nimport { SpeedyPipelineMessageType, SpeedyPipelineMessageWithKeypoints } from '../../pipeline-message';\nimport { InputPort, OutputPort } from '../../pipeline-portbuilder';\nimport { SpeedyGPU } from '../../../../gpu/speedy-gpu';\nimport { Utils } from '../../../../utils/utils';\nimport { SpeedyPromise } from '../../../../utils/speedy-promise';\n\n\n/**\n * The Keypoint Shuffler shuffles a list of keypoints\n */\nexport class SpeedyPipelineNodeKeypointShuffler extends SpeedyPipelineNode\n{\n    /**\n     * Constructor\n     * @param {string} [name] name of the node\n     */\n    constructor(name = undefined)\n    {\n        super(name, 6, [\n            InputPort().expects(SpeedyPipelineMessageType.Keypoints),\n            OutputPort().expects(SpeedyPipelineMessageType.Keypoints)\n        ]);\n\n        /** @type {number} maximum number of keypoints */\n        this._maxKeypoints = Number.NaN;\n    }\n\n    /**\n     * Maximum number of keypoints (optional)\n     * @returns {number}\n     */\n    get maxKeypoints()\n    {\n        return this._maxKeypoints;\n    }\n\n    /**\n     * Maximum number of keypoints (optional)\n     * @param {number} value\n     */\n    set maxKeypoints(value)\n    {\n        if(!Number.isNaN(value))\n            this._maxKeypoints = Math.max(0, value | 0);\n        else\n            this._maxKeypoints = Number.NaN;\n    }\n\n    /**\n     * Run the specific task of this node\n     * @param {SpeedyGPU} gpu\n     * @returns {void|SpeedyPromise<void>}\n     */\n    _run(gpu)\n    {\n        let { encodedKeypoints, descriptorSize, extraSize, encoderLength } = /** @type {SpeedyPipelineMessageWithKeypoints} */ ( this.input().read() );\n        const capacity = SpeedyPipelineNodeKeypointDetector.encoderCapacity(descriptorSize, extraSize, encoderLength);\n        const maxKeypoints = this._maxKeypoints;\n\n        // shuffle the keypoints (including nulls)\n        const permutationMaxLength = gpu.programs.keypoints.shuffle.definedConstant('PERMUTATION_MAXLEN');\n        const permutationLength = Math.min(permutationMaxLength, capacity);\n        const permutation = this._generatePermutation(permutationLength, permutationMaxLength);\n        encodedKeypoints = (gpu.programs.keypoints.shuffle\n            .setUBO('Permutation', permutation)\n            .outputs(encoderLength, encoderLength, this._tex[0])\n        )(encodedKeypoints, descriptorSize, extraSize, encoderLength);\n\n        // sort the keypoints\n        gpu.programs.keypoints.mixKeypointsInit.outputs(encoderLength, encoderLength, this._tex[1]);\n        gpu.programs.keypoints.mixKeypointsSort.outputs(encoderLength, encoderLength, this._tex[2], this._tex[3]);\n        gpu.programs.keypoints.mixKeypointsApply.outputs(encoderLength, encoderLength, this._tex[4]);\n\n        let sortedKeypoints = gpu.programs.keypoints.mixKeypointsInit(\n            encodedKeypoints, descriptorSize, extraSize, encoderLength, capacity\n        );\n\n        for(let b = 1; b < capacity; b *= 2)\n            sortedKeypoints = gpu.programs.keypoints.mixKeypointsSort(sortedKeypoints, b);\n\n        encodedKeypoints = gpu.programs.keypoints.mixKeypointsApply(\n            sortedKeypoints, encodedKeypoints, descriptorSize, extraSize, encoderLength\n        );\n\n        // clip the output?\n        if(!Number.isNaN(maxKeypoints) && maxKeypoints < capacity) {\n            const newEncoderLength = SpeedyPipelineNodeKeypointDetector.encoderLength(maxKeypoints, descriptorSize, extraSize);\n            encodedKeypoints = (gpu.programs.keypoints.clip\n                .outputs(newEncoderLength, newEncoderLength, this._tex[5])\n            )(encodedKeypoints, descriptorSize, extraSize, encoderLength, maxKeypoints);\n            encoderLength = newEncoderLength;\n        }\n\n        // done!\n        this.output().swrite(encodedKeypoints, descriptorSize, extraSize, encoderLength);\n    }\n\n    /**\n     * Generate a permutation p of { 0, 1, ..., n-1 } such that p(p(x)) = x for all x\n     * @param {number} n positive integer\n     * @param {number} [bufsize] size of the output array\n     * @returns {Int32Array} permutation\n     */\n    _generatePermutation(n, bufsize = n)\n    {\n        const array = new Int32Array(bufsize);\n        const p = array.subarray(0, n).fill(-1);\n        const q = Utils.shuffle(Utils.range(n));\n\n        for(let i = 0, j = 0; i < n; i++) {\n            if(p[i] < 0) {\n                do { p[i] = q[j++]; } while(p[i] < i);\n                p[p[i]] = i;\n            }\n        }\n\n        return array; // padded with zeros\n    }\n}\n","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * sink.js\n * Gets keypoints out of the pipeline\n */\n\nimport { SpeedyPipelineNode, SpeedyPipelineSinkNode } from '../../pipeline-node';\nimport { SpeedyPipelineNodeKeypointDetector } from './detectors/detector';\nimport { SpeedyPipelineMessageType, SpeedyPipelineMessageWithKeypoints, SpeedyPipelineMessageWith2DVectors, SpeedyPipelineMessageWithKeypointMatches } from '../../pipeline-message';\nimport { InputPort, OutputPort } from '../../pipeline-portbuilder';\nimport { SpeedyGPU } from '../../../../gpu/speedy-gpu';\nimport { SpeedyTextureReader } from '../../../../gpu/speedy-texture-reader';\nimport { SpeedyTexture, SpeedyDrawableTexture } from '../../../../gpu/speedy-texture';\nimport { SpeedyMedia } from '../../../speedy-media';\nimport { Utils } from '../../../../utils/utils';\nimport { ImageFormat } from '../../../../utils/types';\nimport { IllegalOperationError, IllegalArgumentError, AbstractMethodError } from '../../../../utils/errors';\nimport { SpeedyPromise } from '../../../../utils/speedy-promise';\nimport { SpeedyKeypoint, SpeedyTrackedKeypoint, SpeedyMatchedKeypoint } from '../../../speedy-keypoint';\nimport { SpeedyKeypointDescriptor } from '../../../speedy-keypoint-descriptor';\nimport { SpeedyKeypointMatch } from '../../../speedy-keypoint-match';\nimport { SpeedyVector2 } from '../../../speedy-vector';\nimport {\n    MIN_KEYPOINT_SIZE,\n    FIX_RESOLUTION,\n    LOG2_PYRAMID_MAX_SCALE, PYRAMID_MAX_LEVELS,\n    MATCH_INDEX_BITS, MATCH_INDEX_MASK,\n} from '../../../../utils/globals';\n\n/** next power of 2 */\nconst nextPot = x => x > 1 ? 1 << Math.ceil(Math.log2(x)) : 1;\n\n/** empty array of bytes */\nconst ZERO_BYTES = new Uint8Array([]);\n\n\n/**\n * Gets keypoints out of the pipeline\n * @template {SpeedyKeypoint} T\n * @abstract\n */\nclass SpeedyPipelineNodeAbstractKeypointSink extends SpeedyPipelineSinkNode\n{\n    /**\n     * Constructor\n     * @param {string} [name] name of the node\n     * @param {number} [texCount]\n     * @param {SpeedyPipelinePortBuilder[]} [portBuilders]\n     */\n    constructor(name = 'keypoints', texCount = 0, portBuilders = [])\n    {\n        super(name, texCount + 2, portBuilders);\n\n        /** @type {Array<T|null>} keypoints (output) */\n        this._keypoints = [];\n\n        /** @type {SpeedyTextureReader} texture reader */\n        this._textureReader = new SpeedyTextureReader();\n\n        /** @type {number} page flipping index */\n        this._page = 0;\n\n        /** @type {boolean} accelerate GPU-CPU transfers */\n        this._turbo = false;\n\n        /** @type {boolean} should discarded keypoints be exported as null or dropped altogether? */\n        this._includeDiscarded = false;\n    }\n\n    /**\n     * Accelerate GPU-CPU transfers\n     * @returns {boolean}\n     */\n    get turbo()\n    {\n        return this._turbo;\n    }\n\n    /**\n     * Accelerate GPU-CPU transfers\n     * @param {boolean} value\n     */\n    set turbo(value)\n    {\n        this._turbo = Boolean(value);\n    }\n\n    /**\n     * Should discarded keypoints be exported as null or dropped altogether?\n     * @returns {boolean}\n     */\n    get includeDiscarded()\n    {\n        return this._includeDiscarded;\n    }\n\n    /**\n     * Should discarded keypoints be exported as null or dropped altogether?\n     * @param {boolean} value\n     */\n    set includeDiscarded(value)\n    {\n        this._includeDiscarded = Boolean(value);\n    }\n\n    /**\n     * Initializes this node\n     * @param {SpeedyGPU} gpu\n     */\n    init(gpu)\n    {\n        super.init(gpu);\n        this._textureReader.init(gpu);\n    }\n\n    /**\n     * Releases this node\n     * @param {SpeedyGPU} gpu\n     */\n    release(gpu)\n    {\n        this._textureReader.release(gpu);\n        super.release(gpu);\n    }\n\n    /**\n     * Export data from this node to the user\n     * @returns {SpeedyPromise<Array<T|null>>}\n     */\n    export()\n    {\n        return SpeedyPromise.resolve(this._keypoints);\n    }\n\n    /**\n     * Run the specific task of this node\n     * @param {SpeedyGPU} gpu\n     * @returns {void|SpeedyPromise<void>}\n     */\n    _run(gpu)\n    {\n        const { encodedKeypoints, descriptorSize, extraSize, encoderLength } = /** @type {SpeedyPipelineMessageWithKeypoints} */ ( this.input().read() );\n        return this._download(gpu, encodedKeypoints, descriptorSize, extraSize, encoderLength);\n    }\n\n    /**\n     * Download and decode keypoints from the GPU\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyDrawableTexture} encodedKeypoints\n     * @param {number} descriptorSize\n     * @param {number} extraSize\n     * @param {number} encoderLength\n     * @returns {SpeedyPromise<void>}\n     */\n    _download(gpu, encodedKeypoints, descriptorSize, extraSize, encoderLength)\n    {\n        const useBufferedDownloads = this._turbo;\n\n        /*\n\n        I have found experimentally that, in Firefox, readPixelsAsync()\n        performs MUCH better if the width of the target texture is a power\n        of two. I have no idea why this is the case, nor if it's related to\n        some interaction with the GL drivers, somehow. This seems to make no\n        difference on Chrome, however. In any case, let's convert the input\n        texture to POT.\n\n        */\n        const encoderWidth = nextPot(encoderLength);\n        //const encoderHeight = nextPot(Math.ceil(encoderLength * encoderLength / encoderWidth));\n        const encoderHeight = Math.ceil(encoderLength * encoderLength / encoderWidth);\n        //const encoderWidth=encoderLength,encoderHeight=encoderLength;\n\n        // copy the set of keypoints to an internal texture\n        const copiedTexture = this._tex[(this._tex.length - 1) - this._page];\n        (gpu.programs.utils.copyKeypoints\n            .outputs(encoderWidth, encoderHeight, copiedTexture)\n        )(encodedKeypoints);\n\n        // flip page\n        this._page = 1 - this._page;\n\n        // download the internal texture\n        return this._textureReader.readPixelsAsync(copiedTexture, 0, 0, copiedTexture.width, copiedTexture.height, useBufferedDownloads).then(pixels => {\n\n            // decode the keypoints and store them in this._keypoints\n            this._keypoints = this._decode(pixels, descriptorSize, extraSize, encoderWidth, encoderHeight);\n\n        });\n    }\n\n    /**\n     * Decode a sequence of keypoints, given a flattened image of encoded pixels\n     * @param {Uint8Array} pixels pixels in the [r,g,b,a,...] format\n     * @param {number} descriptorSize in bytes\n     * @param {number} extraSize in bytes\n     * @param {number} encoderWidth\n     * @param {number} encoderHeight\n     * @returns {Array<T|null>} keypoints\n     */\n    _decode(pixels, descriptorSize, extraSize, encoderWidth, encoderHeight)\n    {\n        const bytesPerKeypoint = MIN_KEYPOINT_SIZE + descriptorSize + extraSize;\n        const m = LOG2_PYRAMID_MAX_SCALE, h = PYRAMID_MAX_LEVELS;\n        const piOver255 = Math.PI / 255.0;\n        const keypoints = /** @type {Array<T|null>} */ ( [] );\n        const includeDiscarded = this._includeDiscarded;\n        let descriptorBytes = ZERO_BYTES, extraBytes = ZERO_BYTES;\n        let x, y, z, w, lod, rotation, score;\n        let keypoint;\n\n        // validate\n        if(descriptorSize % 4 != 0 || extraSize % 4 != 0)\n            throw new IllegalArgumentError(`Invalid descriptorSize (${descriptorSize}) / extraSize (${extraSize})`);\n\n        // how many bytes should we read?\n        const e2 = encoderWidth * encoderHeight * 4;\n        const size = pixels.byteLength;\n        if(size != e2)\n            Utils.warning(`Expected ${e2} bytes when decoding a set of keypoints, found ${size}`);\n\n        // copy the data (we use shared buffers when receiving pixels[])\n        if(descriptorSize + extraSize > 0)\n            pixels = new Uint8Array(pixels);\n\n        // for each encoded keypoint\n        for(let i = 0; i < size; i += bytesPerKeypoint) {\n            // extract encoded header\n            x = (pixels[i+1] << 8) | pixels[i];\n            y = (pixels[i+3] << 8) | pixels[i+2];\n            z = (pixels[i+5] << 8) | pixels[i+4];\n            w = (pixels[i+7] << 8) | pixels[i+6];\n\n            // the keypoint is \"null\": we have reached the end of the list\n            if(x == 0xFFFF && y == 0xFFFF)\n                break;\n\n            // the header is zero: discard the keypoint\n            if(x + y + z + w == 0) {\n                if(includeDiscarded)\n                    keypoints.push(null);\n                continue;\n            }\n\n            // extract extra & descriptor bytes\n            if(extraSize > 0) {\n                extraBytes = pixels.subarray(8 + i, 8 + i + extraSize);\n                if(extraBytes.byteLength < extraSize) {\n                    Utils.warning(`KeypointSink: expected ${extraSize} extra bytes when decoding the ${i/bytesPerKeypoint}-th keypoint, found ${extraBytes.byteLength} instead`);\n                    continue; // something is off here; discard\n                }\n            }\n            if(descriptorSize > 0) {\n                descriptorBytes = pixels.subarray(8 + i + extraSize, 8 + i + extraSize + descriptorSize);\n                if(descriptorBytes.byteLength < descriptorSize) {\n                    Utils.warning(`KeypointSink: expected ${descriptorSize} descriptor bytes when decoding the ${i/bytesPerKeypoint}-th keypoint, found ${descriptorBytes.byteLength} instead`);\n                    continue; // something is off here; discard\n                }\n            }\n\n            // decode position: convert from fixed-point\n            x /= FIX_RESOLUTION;\n            y /= FIX_RESOLUTION;\n\n            // decode level-of-detail\n            lod = (pixels[i+4] < 255) ? -m + ((m + h) * pixels[i+4]) / 255.0 : 0.0;\n\n            // decode orientation\n            rotation = (2 * pixels[i+5] - 255) * piOver255;\n\n            // decode score\n            score = Utils.decodeFloat16(w);\n\n            // create keypoint\n            keypoint = this._createKeypoint(x, y, lod, rotation, score, descriptorBytes, extraBytes);\n\n            // register keypoint\n            keypoints.push(keypoint);\n        }\n\n        // done!\n        return keypoints;\n    }\n\n    /**\n     * Instantiate a new keypoint\n     * @param {number} x\n     * @param {number} y\n     * @param {number} lod\n     * @param {number} rotation\n     * @param {number} score\n     * @param {Uint8Array} descriptorBytes\n     * @param {Uint8Array} extraBytes\n     * @returns {T}\n     */\n    _createKeypoint(x, y, lod, rotation, score, descriptorBytes, extraBytes)\n    {\n        throw new AbstractMethodError();\n    }\n\n    /**\n     * Allocate extra soace\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyDrawableTexture} output output texture\n     * @param {SpeedyTexture} inputEncodedKeypoints input with no extra space\n     * @param {number} inputDescriptorSize in bytes, must be positive\n     * @param {number} inputExtraSize must be 0\n     * @param {number} outputDescriptorSize must be inputDescriptorSize\n     * @param {number} outputExtraSize in bytes, must be positive and a multiple of 4\n     * @returns {SpeedyDrawableTexture} encodedKeypoints with extra space\n     */\n    _allocateExtra(gpu, output, inputEncodedKeypoints, inputDescriptorSize, inputExtraSize, outputDescriptorSize, outputExtraSize)\n    {\n        Utils.assert(inputExtraSize === 0);\n        Utils.assert(outputDescriptorSize === inputDescriptorSize && outputExtraSize > 0 && outputExtraSize % 4 === 0);\n\n        const inputEncoderLength = inputEncodedKeypoints.width;\n        const inputEncoderCapacity = SpeedyPipelineNodeKeypointDetector.encoderCapacity(inputDescriptorSize, inputExtraSize, inputEncoderLength);\n        const outputEncoderCapacity = inputEncoderCapacity;\n        const outputEncoderLength = SpeedyPipelineNodeKeypointDetector.encoderLength(outputEncoderCapacity, outputDescriptorSize, outputExtraSize);\n\n        return (gpu.programs.keypoints.allocateExtra\n            .outputs(outputEncoderLength, outputEncoderLength, output)\n        )(inputEncodedKeypoints, inputDescriptorSize, inputExtraSize, inputEncoderLength, outputDescriptorSize, outputExtraSize, outputEncoderLength);\n    }\n}\n\n/**\n * Gets standard keypoints out of the pipeline\n * @extends {SpeedyPipelineNodeAbstractKeypointSink<SpeedyKeypoint>}\n */\nexport class SpeedyPipelineNodeKeypointSink extends SpeedyPipelineNodeAbstractKeypointSink\n{\n    /**\n     * Constructor\n     * @param {string} [name] name of the node\n     */\n    constructor(name = 'keypoints')\n    {\n        super(name, 0, [\n            InputPort().expects(SpeedyPipelineMessageType.Keypoints)\n        ]);\n    }\n\n    /**\n     * Instantiate a new keypoint\n     * @param {number} x\n     * @param {number} y\n     * @param {number} lod\n     * @param {number} rotation\n     * @param {number} score\n     * @param {Uint8Array} descriptorBytes\n     * @param {Uint8Array} extraBytes\n     * @returns {SpeedyKeypoint}\n     */\n    _createKeypoint(x, y, lod, rotation, score, descriptorBytes, extraBytes)\n    {\n        const descriptorSize = descriptorBytes.byteLength;\n\n        // read descriptor, if any\n        const descriptor = descriptorSize > 0 ? new SpeedyKeypointDescriptor(descriptorBytes) : null;\n\n        // create keypoint\n        return new SpeedyKeypoint(x, y, lod, rotation, score, descriptor);\n    }\n}\n\n/**\n * Gets tracked keypoints out of the pipeline\n * @extends {SpeedyPipelineNodeAbstractKeypointSink<SpeedyTrackedKeypoint>}\n */\nexport class SpeedyPipelineNodeTrackedKeypointSink extends SpeedyPipelineNodeAbstractKeypointSink\n{\n    /**\n     * Constructor\n     * @param {string} [name] name of the node\n     */\n    constructor(name = 'keypoints')\n    {\n        super(name, 2, [\n            InputPort().expects(SpeedyPipelineMessageType.Keypoints).satisfying(\n                ( /** @type {SpeedyPipelineMessageWithKeypoints} */ msg ) =>\n                    msg.extraSize == 0\n            ),\n            InputPort('flow').expects(SpeedyPipelineMessageType.Vector2)\n        ]);\n    }\n\n    /**\n     * Run the specific task of this node\n     * @param {SpeedyGPU} gpu\n     * @returns {void|SpeedyPromise<void>}\n     */\n    _run(gpu)\n    {\n        const { encodedKeypoints, descriptorSize, extraSize, encoderLength } = /** @type {SpeedyPipelineMessageWithKeypoints} */ ( this.input().read() );\n        const { vectors } = /** @type {SpeedyPipelineMessageWith2DVectors} */ ( this.input('flow').read() );\n\n        // allocate extra space\n        const newDescriptorSize = descriptorSize;\n        const newExtraSize = 4; // 1 pixel per flow vector per keypoint\n        const encodedKeypointsWithExtraSpace = this._allocateExtra(gpu, this._tex[0], encodedKeypoints, descriptorSize, extraSize, newDescriptorSize, newExtraSize);\n\n        // attach flow vectors\n        const newEncoderLength = encodedKeypointsWithExtraSpace.width;\n        const newEncodedKeypoints = (gpu.programs.keypoints.transferToExtra\n            .outputs(newEncoderLength, newEncoderLength, this._tex[1])\n        )(vectors, vectors.width, encodedKeypointsWithExtraSpace, newDescriptorSize, newExtraSize, newEncoderLength);\n\n        // done!\n        return this._download(gpu, newEncodedKeypoints, newDescriptorSize, newExtraSize, newEncoderLength);\n    }\n\n    /**\n     * Instantiate a new keypoint\n     * @param {number} x\n     * @param {number} y\n     * @param {number} lod\n     * @param {number} rotation\n     * @param {number} score\n     * @param {Uint8Array} descriptorBytes\n     * @param {Uint8Array} extraBytes\n     * @returns {SpeedyTrackedKeypoint}\n     */\n    _createKeypoint(x, y, lod, rotation, score, descriptorBytes, extraBytes)\n    {\n        const descriptorSize = descriptorBytes.byteLength;\n        const extraSize = extraBytes.byteLength;\n\n        // read descriptor, if any\n        const descriptor = descriptorSize > 0 ? new SpeedyKeypointDescriptor(descriptorBytes) : null;\n\n        // read flow vector\n        const fx = Utils.decodeFloat16((extraBytes[1] << 8) | extraBytes[0]);\n        const fy = Utils.decodeFloat16((extraBytes[3] << 8) | extraBytes[2]);\n        const flow = new SpeedyVector2(fx, fy);\n\n        // create keypoint\n        return new SpeedyTrackedKeypoint(x, y, lod, rotation, score, descriptor, flow);\n    }\n}\n\n/**\n * Gets matched keypoints out of the pipeline\n * @extends SpeedyPipelineNodeAbstractKeypointSink<SpeedyMatchedKeypoint>\n */\nexport class SpeedyPipelineNodeMatchedKeypointSink extends SpeedyPipelineNodeAbstractKeypointSink\n{\n    /**\n     * Constructor\n     * @param {string} [name] name of the node\n     */\n    constructor(name = 'keypoints')\n     {\n        super(name, 2, [\n            InputPort().expects(SpeedyPipelineMessageType.Keypoints).satisfying(\n                ( /** @type {SpeedyPipelineMessageWithKeypoints} */ msg ) =>\n                    msg.extraSize == 0\n            ),\n            InputPort('matches').expects(SpeedyPipelineMessageType.KeypointMatches)\n        ]);\n    }\n\n    /**\n     * Run the specific task of this node\n     * @param {SpeedyGPU} gpu\n     * @returns {void|SpeedyPromise<void>}\n     */\n    _run(gpu)\n    {\n        const { encodedKeypoints, descriptorSize, extraSize, encoderLength } = /** @type {SpeedyPipelineMessageWithKeypoints} */ ( this.input().read() );\n        const { encodedMatches, matchesPerKeypoint } = /** @type {SpeedyPipelineMessageWithKeypointMatches} */ ( this.input('matches').read() );\n\n        // allocate space for the matches\n        const newDescriptorSize = descriptorSize;\n        const newExtraSize = matchesPerKeypoint * 4; // 4 bytes per pixel\n        const encodedKeypointsWithExtraSpace = this._allocateExtra(gpu, this._tex[0], encodedKeypoints, descriptorSize, extraSize, newDescriptorSize, newExtraSize);\n\n        // transfer matches to a new texture\n        const newEncoderLength = encodedKeypointsWithExtraSpace.width;\n        const newEncodedKeypoints = (gpu.programs.keypoints.transferToExtra\n            .outputs(newEncoderLength, newEncoderLength, this._tex[1])\n        )(encodedMatches, encodedMatches.width, encodedKeypointsWithExtraSpace, newDescriptorSize, newExtraSize, newEncoderLength);\n\n        // done!\n        return this._download(gpu, newEncodedKeypoints, newDescriptorSize, newExtraSize, newEncoderLength);\n    }\n\n    /**\n     * Instantiate a new keypoint\n     * @param {number} x\n     * @param {number} y\n     * @param {number} lod\n     * @param {number} rotation\n     * @param {number} score\n     * @param {Uint8Array} descriptorBytes\n     * @param {Uint8Array} extraBytes\n     * @returns {SpeedyMatchedKeypoint}\n     */\n    _createKeypoint(x, y, lod, rotation, score, descriptorBytes, extraBytes)\n    {\n        const descriptorSize = descriptorBytes.byteLength;\n        const extraSize = extraBytes.byteLength;\n\n        // read descriptor, if any\n        const descriptor = descriptorSize > 0 ? new SpeedyKeypointDescriptor(descriptorBytes) : null;\n\n        // decode matches\n        const matchesPerKeypoint = extraSize / 4;\n        const matches = /** @type {SpeedyKeypointMatch[]} */ ( new Array(matchesPerKeypoint) );\n        for(let matchIndex = 0; matchIndex < matchesPerKeypoint; matchIndex++) {\n            const base = matchIndex * 4;\n            const u32 = extraBytes[base] | (extraBytes[base+1] << 8) | (extraBytes[base+2] << 16) | (extraBytes[base+3] << 24);\n            const match = new SpeedyKeypointMatch(u32 & MATCH_INDEX_MASK, u32 >>> MATCH_INDEX_BITS);\n\n            matches[matchIndex] = match;\n        }\n\n        // done!\n        return new SpeedyMatchedKeypoint(x, y, lod, rotation, score, descriptor, matches);\n    }\n}\n","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * source.js\n * Gets keypoints into the pipeline\n */\n\nimport { SpeedyPipelineNode, SpeedyPipelineSourceNode } from '../../pipeline-node';\nimport { SpeedyPipelineNodeKeypointDetector } from './detectors/detector';\nimport { SpeedyPipelineMessageType, SpeedyPipelineMessageWithKeypoints } from '../../pipeline-message';\nimport { OutputPort } from '../../pipeline-portbuilder';\nimport { SpeedyGPU } from '../../../../gpu/speedy-gpu';\nimport { SpeedyTexture } from '../../../../gpu/speedy-texture';\nimport { Utils } from '../../../../utils/utils';\nimport { IllegalArgumentError } from '../../../../utils/errors';\nimport { SpeedyPromise } from '../../../../utils/speedy-promise';\nimport { SpeedyKeypoint } from '../../../speedy-keypoint';\nimport { DEFAULT_ENCODER_CAPACITY, MAX_ENCODER_CAPACITY } from '../../../../utils/globals';\n\n// Constants\nconst UBO_MAX_BYTES = 16384; // UBOs can hold at least 16KB of data: gl.MAX_UNIFORM_BLOCK_SIZE >= 16384 according to the GL ES 3 reference\nconst BUFFER_SIZE = 1024; // how many keypoints we can upload in one pass of the shader (as defined in the shader program)\nconst SIZEOF_VEC4 = Float32Array.BYTES_PER_ELEMENT * 4; // 16 bytes\n\n/**\n * Gets keypoints into the pipeline\n */\nexport class SpeedyPipelineNodeKeypointSource extends SpeedyPipelineSourceNode\n{\n    /**\n     * Constructor\n     * @param {string} [name] name of the node\n     */\n    constructor(name = undefined)\n    {\n        super(name, 2, [\n            OutputPort().expects(SpeedyPipelineMessageType.Keypoints)\n        ]);\n\n        /** @type {SpeedyKeypoint[]} keypoints to be uploaded to the GPU */\n        this._keypoints = [];\n\n        /** @type {Float32Array} upload buffer (UBO) */\n        this._buffer = SpeedyPipelineNodeKeypointSource._createUploadBuffer(BUFFER_SIZE);\n\n        /** @type {number} maximum number of keypoints */\n        this._capacity = DEFAULT_ENCODER_CAPACITY;\n    }\n\n    /**\n     * Keypoints to be uploaded\n     * @returns {SpeedyKeypoint[]}\n     */\n    get keypoints()\n    {\n        return this._keypoints;\n    }\n\n    /**\n     * Keypoints to be uploaded\n     * @param {SpeedyKeypoint[]} keypoints\n     */\n    set keypoints(keypoints)\n    {\n        if(!Array.isArray(keypoints))\n            throw new IllegalArgumentError(`Not an array of keypoints`);\n\n        this._keypoints = keypoints;\n    }\n\n    /**\n     * The maximum number of keypoints we'll accept.\n     * This should be a tight bound for better performance.\n     * @returns {number}\n     */\n    get capacity()\n    {\n        return this._capacity;\n    }\n\n    /**\n     * The maximum number of keypoints we'll accept.\n     * This should be a tight bound for better performance.\n     * @param {number} capacity\n     */\n    set capacity(capacity)\n    {\n        this._capacity = Math.min(Math.max(0, capacity | 0), MAX_ENCODER_CAPACITY);\n    }\n\n    /**\n     * Run the specific task of this node\n     * @param {SpeedyGPU} gpu\n     * @returns {void|SpeedyPromise<void>}\n     */\n    _run(gpu)\n    {\n        // Orientation, descriptors and extra bytes will be lost\n        const descriptorSize = 0, extraSize = 0;\n        const keypoints = this._keypoints;\n        const maxKeypoints = this._capacity;\n        const numKeypoints = Math.min(keypoints.length, maxKeypoints);\n        const numPasses = Math.max(1, Math.ceil(numKeypoints / BUFFER_SIZE));\n        const buffer = this._buffer;\n        const uploadKeypoints = gpu.programs.keypoints.uploadKeypoints;\n        const encoderLength = SpeedyPipelineNodeKeypointDetector.encoderLength(maxKeypoints, descriptorSize, extraSize); // we're using maxKeypoints to avoid constant texture resize (slow on Firefox)\n\n        uploadKeypoints.outputs(encoderLength, encoderLength, this._tex[0], this._tex[1]);\n\n        let startIndex = 0, encodedKeypoints = uploadKeypoints.clear();\n        for(let i = 0; i < numPasses; i++) {\n            const n = Math.min(BUFFER_SIZE, numKeypoints - startIndex);\n            const endIndex = startIndex + n;\n\n            uploadKeypoints.setUBO('KeypointBuffer', SpeedyPipelineNodeKeypointSource._fillUploadBuffer(buffer, keypoints, startIndex, endIndex));\n            encodedKeypoints = uploadKeypoints(encodedKeypoints, startIndex, endIndex, descriptorSize, extraSize, encoderLength);\n\n            startIndex = endIndex;\n        }\n\n        this.output().swrite(encodedKeypoints, descriptorSize, extraSize, encoderLength);\n    }\n\n    /**\n     * Create an upload buffer\n     * @param {number} bufferSize number of keypoints\n     * @returns {Float32Array}\n     */\n    static _createUploadBuffer(bufferSize)\n    {\n        const internalBuffer = new ArrayBuffer(SIZEOF_VEC4 * bufferSize);\n\n        Utils.assert(internalBuffer.byteLength <= UBO_MAX_BYTES);\n\n        return new Float32Array(internalBuffer);\n    }\n\n    /**\n     * Fill upload buffer with keypoint data\n     * @param {Float32Array} buffer\n     * @param {SpeedyKeypoint[]} keypoints \n     * @param {number} start index, inclusive\n     * @param {number} end index, exclusive\n     * @returns {Float32Array} buffer\n     */\n    static _fillUploadBuffer(buffer, keypoints, start, end)\n    {\n        const n = end - start;\n        for(let i = 0; i < n; i++) {\n            const keypoint = keypoints[start + i];\n            const hasPos = keypoint.position !== undefined;\n            const j = i * 4;\n\n            // Format data as follows:\n            // vec4(xpos, ypos, lod, score)\n            buffer[j]   = +(hasPos ? keypoint.position.x : keypoint.x) || 0;\n            buffer[j+1] = +(hasPos ? keypoint.position.y : keypoint.y) || 0;\n            buffer[j+2] = +(keypoint.lod) || 0;\n            buffer[j+3] = +(keypoint.score) || 0;\n        }\n\n        // done!\n        return buffer;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * subpixel.js\n * Subpixel refinement of keypoint location\n */\n\nimport { SpeedyPipelineNode } from '../../pipeline-node';\nimport { SpeedyPipelineNodeKeypointDetector } from './detectors/detector';\nimport { SpeedyPipelineMessageType, SpeedyPipelineMessageWithKeypoints, SpeedyPipelineMessageWithImage } from '../../pipeline-message';\nimport { InputPort, OutputPort } from '../../pipeline-portbuilder';\nimport { SpeedyGPU } from '../../../../gpu/speedy-gpu';\nimport { SpeedyTexture } from '../../../../gpu/speedy-texture';\nimport { ImageFormat } from '../../../../utils/types';\nimport { Utils } from '../../../../utils/utils';\nimport { IllegalArgumentError } from '../../../../utils/errors';\nimport { SpeedyPromise } from '../../../../utils/speedy-promise';\n\n/** @typedef {\"quadratic1d\"|\"taylor2d\"|\"bicubic-upsample\"|\"bilinear-upsample\"} SubpixelRefinementMethod */\n\n/** @const {Object<SubpixelRefinementMethod,string>} method name to program name */\nconst METHOD2PROGRAM = Object.freeze({\n    'quadratic1d': 'subpixelQuadratic1d',\n    'taylor2d': 'subpixelTaylor2d',\n    'bicubic-upsample': 'subpixelBicubic',\n    'bilinear-upsample': 'subpixelBilinear',\n});\n\n/**\n * Subpixel refinement of keypoint location\n */\nexport class SpeedyPipelineNodeKeypointSubpixelRefiner extends SpeedyPipelineNode\n{\n    /**\n     * Constructor\n     * @param {string} [name] name of the node\n     */\n    constructor(name = undefined)\n    {\n        super(name, 2, [\n            InputPort('image').expects(SpeedyPipelineMessageType.Image).satisfying(\n                ( /** @type {SpeedyPipelineMessageWithImage} */ msg ) =>\n                    msg.format === ImageFormat.GREY\n            ),\n            InputPort('keypoints').expects(SpeedyPipelineMessageType.Keypoints),\n            OutputPort().expects(SpeedyPipelineMessageType.Keypoints),\n            OutputPort('displacements').expects(SpeedyPipelineMessageType.Vector2),\n        ]);\n\n        /** @type {SubpixelRefinementMethod} subpixel refinement method */\n        this._method = 'quadratic1d';\n\n        /** @type {number} max iterations for the upsampling methods */\n        this._maxIterations = 6;\n\n        /** @type {number} convergence threshold for the upsampling methods */\n        this._epsilon = 0.1;\n    }\n\n    /**\n     * Subpixel refinement method\n     * @returns {SubpixelRefinementMethod}\n     */\n    get method()\n    {\n        return this._method;\n    }\n\n    /**\n     * Subpixel refinement method\n     * @param {SubpixelRefinementMethod} name\n     */\n    set method(name)\n    {\n        if(!Object.prototype.hasOwnProperty.call(METHOD2PROGRAM, name))\n            throw new IllegalArgumentError(`Invalid method: \"${name}\"`);\n\n        this._method = name;\n    }\n\n    /**\n     * Max. iterations for the upsampling methods\n     * @returns {number}\n     */\n    get maxIterations()\n    {\n        return this._maxIterations;\n    }\n\n    /**\n     * Max. iterations for the upsampling methods\n     * @param {number} value\n     */\n    set maxIterations(value)\n    {\n        this._maxIterations = Math.max(0, +value);\n    }\n\n    /**\n     * Convergence threshold for the upsampling methods\n     * @returns {number}\n     */\n    get epsilon()\n    {\n        return this._epsilon;\n    }\n\n    /**\n     * Convergence threshold for the upsampling methods\n     * @param {number} value\n     */\n    set epsilon(value)\n    {\n        this._epsilon = Math.max(0, +value);\n    }\n\n    /**\n     * Run the specific task of this node\n     * @param {SpeedyGPU} gpu\n     * @returns {void|SpeedyPromise<void>}\n     */\n    _run(gpu)\n    {\n        const { encodedKeypoints, descriptorSize, extraSize, encoderLength } = /** @type {SpeedyPipelineMessageWithKeypoints} */ ( this.input('keypoints').read() );\n        const { image, format } = /** @type {SpeedyPipelineMessageWithImage} */ ( this.input('image').read() );\n        const tex = this._tex;\n        const program = METHOD2PROGRAM[this._method];\n        const maxIterations = this._maxIterations;\n        const epsilon = this._epsilon;\n\n        // note: if you detected the keypoints using a pyramid,\n        //       you need to pass that pyramid as input!\n\n        // we'll compute the offsets for each keypoint\n        const capacity = SpeedyPipelineNodeKeypointDetector.encoderCapacity(descriptorSize, extraSize, encoderLength);\n        const offsetEncoderLength = Math.max(1, Math.ceil(Math.sqrt(capacity))); // 1 pixel per refinement offset\n        const offsets = (gpu.programs.keypoints[program]\n            .outputs(offsetEncoderLength, offsetEncoderLength, tex[0])\n        )(image, encodedKeypoints, descriptorSize, extraSize, encoderLength, maxIterations, epsilon);\n\n        // apply the offsets to the keypoints\n        const refinedKeypoints = (gpu.programs.keypoints.transferFlow\n            .outputs(encoderLength, encoderLength, tex[1])\n        )(offsets, encodedKeypoints, descriptorSize, extraSize, encoderLength);\n\n        // done!\n        this.output().swrite(refinedKeypoints, descriptorSize, extraSize, encoderLength);\n        this.output('displacements').swrite(offsets);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * lk.js\n * LK optical-flow\n */\n\nimport { SpeedyPipelineNode } from '../../../pipeline-node';\nimport { SpeedyPipelineNodeKeypointDetector } from '../detectors/detector';\nimport { SpeedyPipelineMessageType, SpeedyPipelineMessageWithKeypoints, SpeedyPipelineMessageWithImage } from '../../../pipeline-message';\nimport { InputPort, OutputPort } from '../../../pipeline-portbuilder';\nimport { SpeedyGPU } from '../../../../../gpu/speedy-gpu';\nimport { SpeedyTexture } from '../../../../../gpu/speedy-texture';\nimport { ImageFormat } from '../../../../../utils/types';\nimport { SpeedySize } from '../../../../speedy-size';\nimport { Utils } from '../../../../../utils/utils';\nimport { IllegalOperationError, NotSupportedError } from '../../../../../utils/errors';\nimport { SpeedyPromise } from '../../../../../utils/speedy-promise';\nimport { MIN_KEYPOINT_SIZE, PYRAMID_MAX_LEVELS } from '../../../../../utils/globals';\n\n// Constants\nconst DEFAULT_WINDOW_SIZE = new SpeedySize(11, 11); // nice on mobile?\nconst DEFAULT_DEPTH = Math.min(3, PYRAMID_MAX_LEVELS);\nconst DEFAULT_NUMBER_OF_ITERATIONS = 30;\nconst DEFAULT_DISCARD_THRESHOLD = 0.0001;\nconst DEFAULT_EPSILON = 0.01;\nconst LK_PROGRAM = {\n    3: 'lk3',\n    5: 'lk5',\n    7: 'lk7',\n    9: 'lk9',\n    11: 'lk11',\n    13: 'lk13',\n    15: 'lk15',\n    17: 'lk17',\n    19: 'lk19',\n    21: 'lk21',\n};\n\n\n/**\n * LK optical-flow\n */\nexport class SpeedyPipelineNodeLKKeypointTracker extends SpeedyPipelineNode\n{\n    /**\n     * Constructor\n     * @param {string} [name] name of the node\n     */\n    constructor(name = undefined)\n    {\n        super(name, 3, [\n            InputPort('previousImage').expects(SpeedyPipelineMessageType.Image).satisfying(\n                ( /** @type {SpeedyPipelineMessageWithImage} */ msg ) =>\n                    msg.format === ImageFormat.GREY\n            ),\n            InputPort('nextImage').expects(SpeedyPipelineMessageType.Image).satisfying(\n                ( /** @type {SpeedyPipelineMessageWithImage} */ msg ) =>\n                    msg.format === ImageFormat.GREY\n            ),\n            InputPort('previousKeypoints').expects(SpeedyPipelineMessageType.Keypoints),\n            OutputPort().expects(SpeedyPipelineMessageType.Keypoints),\n            OutputPort('flow').expects(SpeedyPipelineMessageType.Vector2),\n        ]);\n\n        /** @type {SpeedySize} window size */\n        this._windowSize = DEFAULT_WINDOW_SIZE;\n\n        /** @type {number} number of pyramid levels to use */\n        this._levels = DEFAULT_DEPTH;\n\n        /** @type {number} minimum acceptable corner response */\n        this._discardThreshold = DEFAULT_DISCARD_THRESHOLD;\n\n        /** @type {number} number of iterations per pyramid level (termination criteria) */\n        this._numberOfIterations = DEFAULT_NUMBER_OF_ITERATIONS;\n\n        /** @type {number} minimum increment per iteration (termination criteria) */\n        this._epsilon = DEFAULT_EPSILON;\n    }\n\n    /**\n     * Window size (use odd numbers)\n     * @returns {SpeedySize}\n     */\n    get windowSize()\n    {\n        return this._windowSize;\n    }\n\n    /**\n     * Window size (use odd numbers)\n     * @param {SpeedySize} windowSize must be a square window\n     */\n    set windowSize(windowSize)\n    {\n        if(windowSize.width != windowSize.height) {\n            throw new NotSupportedError(`LK: window ${this._windowSize.toString()} is not square!`);\n        }\n        else if(!Object.prototype.hasOwnProperty.call(LK_PROGRAM, windowSize.width)) {\n            const SUPPORTED_WINDOWS = Object.keys(LK_PROGRAM).sort((a,b) => a-b).map(k => k+'x'+k).join(', ');\n            throw new NotSupportedError(`LK: window of size ${this._windowSize.toString()} is not supported! Supported sizes: ${SUPPORTED_WINDOWS}`);\n        }\n\n        this._windowSize = windowSize;\n    }\n\n    /**\n     * Number of pyramid levels to use\n     * @returns {number}\n     */\n    get levels()\n    {\n        return this._levels;\n    }\n\n    /**\n     * Number of pyramid levels to use\n     * @param {number} levels\n     */\n    set levels(levels)\n    {\n        Utils.assert(levels >= 1 && levels <= PYRAMID_MAX_LEVELS);\n        this._levels = levels | 0;\n    }\n\n    /**\n     * Get the discard threshold, used to discard \"bad\" keypoints\n     * @returns {number}\n     */\n    get discardThreshold()\n    {\n        return this._discardThreshold;\n    }\n\n    /**\n     * Set the discard threshold, used to discard \"bad\" keypoints\n     * @param {number} value typically 10^(-4) - increase to discard more\n     */\n    set discardThreshold(value)\n    {\n        Utils.assert(value >= 0);\n        this._discardThreshold = +value;\n    }\n\n    /**\n     * Get the maximum number of iterations of the pyramidal LK algorithm\n     * @returns {number}\n     */\n    get numberOfIterations()\n    {\n        return this._numberOfIterations;\n    }\n\n    /**\n     * Set the maximum number of iterations of the pyramidal LK algorithm\n     * @param {number} value\n     */\n    set numberOfIterations(value)\n    {\n        Utils.assert(value >= 1);\n        this._numberOfIterations = value | 0;\n    }\n\n    /**\n     * Get the accuracy threshold, used to stop LK iterations\n     * @returns {number}\n     */\n    get epsilon()\n    {\n        return this._epsilon;\n    }\n\n    /**\n     * Get the accuracy threshold, used to stop LK iterations\n     * @param {number} value typically 0.01\n     */\n    set epsilon(value)\n    {\n        Utils.assert(value >= 0);\n        this._epsilon = +value;\n    }\n\n    /**\n     * Run the specific task of this node\n     * @param {SpeedyGPU} gpu\n     * @returns {void|SpeedyPromise<void>}\n     */\n    _run(gpu)\n    {\n        const { encodedKeypoints, descriptorSize, extraSize, encoderLength } = /** @type {SpeedyPipelineMessageWithKeypoints} */ ( this.input('previousKeypoints').read() );\n        const previousImage = ( /** @type {SpeedyPipelineMessageWithImage} */ ( this.input('previousImage').read() )).image;\n        const nextImage = ( /** @type {SpeedyPipelineMessageWithImage} */ ( this.input('nextImage').read() )).image;\n        const previousKeypoints = encodedKeypoints;\n        const levels = this._levels;\n        const windowSize = this._windowSize;\n        const wsize = windowSize.width; // square window\n        const numberOfIterations = this._numberOfIterations;\n        const discardThreshold = this._discardThreshold;\n        const epsilon = this._epsilon;\n        const keypoints = gpu.programs.keypoints;\n        const tex = this._tex;\n\n        // do we need a pyramid?\n        if(!(levels == 1 || (previousImage.hasMipmaps() && nextImage.hasMipmaps())))\n            throw new IllegalOperationError(`LK: a pyramid is required if levels > 1`);\n        else if(previousImage.width !== nextImage.width || previousImage.height !== nextImage.height)\n            throw new IllegalOperationError(`LK: can't use input images of different size`);\n\n        // select the appropriate program\n        const lk = keypoints[LK_PROGRAM[wsize]];\n\n        // find the dimensions of the flow texture (1 pixel per flow vector)\n        const numKeypoints = SpeedyPipelineNodeKeypointDetector.encoderCapacity(descriptorSize, extraSize, encoderLength);\n        const lkEncoderLength = Math.max(1, Math.ceil(Math.sqrt(numKeypoints)));\n        lk.outputs(lkEncoderLength, lkEncoderLength, tex[0], tex[1]);\n\n        // compute optical-flow\n        let flow = lk.clear();\n        for(let lod = levels - 1; lod >= 0; lod--)\n            flow = lk(flow, previousKeypoints, nextImage, previousImage, lod, levels, numberOfIterations, discardThreshold, epsilon, descriptorSize, extraSize, encoderLength);\n\n        // transfer optical-flow to nextKeypoints\n        keypoints.transferFlow.outputs(encoderLength, encoderLength, tex[2]);\n        const nextKeypoints = keypoints.transferFlow(flow, previousKeypoints, descriptorSize, extraSize, encoderLength);\n\n        // done!\n        this.output().swrite(nextKeypoints, descriptorSize, extraSize, encoderLength);\n        this.output('flow').swrite(flow);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * transformer.js\n * Apply a transformation matrix to a set of keypoints\n */\n\nimport { SpeedyPipelineNode } from '../../pipeline-node';\nimport { SpeedyPipelineMessageType, SpeedyPipelineMessageWithKeypoints } from '../../pipeline-message';\nimport { InputPort, OutputPort } from '../../pipeline-portbuilder';\nimport { SpeedyGPU } from '../../../../gpu/speedy-gpu';\nimport { SpeedyTexture } from '../../../../gpu/speedy-texture';\nimport { Utils } from '../../../../utils/utils';\nimport { SpeedyPromise } from '../../../../utils/speedy-promise';\nimport { SpeedyMatrix } from '../../../speedy-matrix';\nimport { IllegalArgumentError } from '../../../../utils/errors';\n\n\n/**\n * Apply a transformation matrix to a set of keypoints\n */\nexport class SpeedyPipelineNodeKeypointTransformer extends SpeedyPipelineNode\n{\n    /**\n     * Constructor\n     * @param {string} [name] name of the node\n     */\n    constructor(name = undefined)\n    {\n        super(name, 1, [\n            InputPort().expects(SpeedyPipelineMessageType.Keypoints),\n            OutputPort().expects(SpeedyPipelineMessageType.Keypoints)\n        ]);\n\n        /** @type {SpeedyMatrix} transformation matrix */\n        this._transform = SpeedyMatrix.Create(3, 3, [1, 0, 0, 0, 1, 0, 0, 0, 1]); // identity matrix\n    }\n\n    /**\n     * Transformation matrix\n     * @returns {SpeedyMatrix}\n     */\n    get transform()\n    {\n        return this._transform;\n    }\n\n    /**\n     * Transformation matrix. Must be 3x3\n     * @param {SpeedyMatrix} transform\n     */\n    set transform(transform)\n    {\n        if(!(transform.rows == 3 && transform.columns == 3))\n            throw new IllegalArgumentError(`Not a 3x3 transformation matrix: ${transform}`);\n\n        this._transform = transform;\n    }\n\n    /**\n     * Run the specific task of this node\n     * @param {SpeedyGPU} gpu\n     * @returns {void|SpeedyPromise<void>}\n     */\n    _run(gpu)\n    {\n        const { encodedKeypoints, descriptorSize, extraSize, encoderLength } = /** @type {SpeedyPipelineMessageWithKeypoints} */ ( this.input().read() );\n        const outputTexture = this._tex[0];\n        const homography = this._transform.read();\n\n        // apply homography\n        (gpu.programs.keypoints.applyHomography\n            .outputs(encodedKeypoints.width, encodedKeypoints.height, outputTexture)\n        )(homography, encodedKeypoints, descriptorSize, extraSize, encoderLength);\n\n        // done!\n        this.output().swrite(outputTexture, descriptorSize, extraSize, encoderLength);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * perspective-warp.js\n * Warp an image using a perspective transformation\n */\n\nimport { SpeedyPipelineNode } from '../../pipeline-node';\nimport { SpeedyPipelineMessageType, SpeedyPipelineMessageWithImage } from '../../pipeline-message';\nimport { InputPort, OutputPort } from '../../pipeline-portbuilder';\nimport { SpeedyGPU } from '../../../../gpu/speedy-gpu';\nimport { SpeedyTexture } from '../../../../gpu/speedy-texture';\nimport { Utils } from '../../../../utils/utils';\nimport { ImageFormat, PixelComponent, ColorComponentId } from '../../../../utils/types';\nimport { SpeedyPromise } from '../../../../utils/speedy-promise';\nimport { IllegalArgumentError } from '../../../../utils/errors';\nimport { SpeedyMatrix } from '../../../speedy-matrix';\n\n// Used when an invalid matrix is provided\nconst SINGULAR_MATRIX = [0,0,0,0,0,0,0,0,1];\n\n/**\n * Warp an image using a perspective transformation\n */\nexport class SpeedyPipelineNodePerspectiveWarp extends SpeedyPipelineNode\n{\n    /**\n     * Constructor\n     * @param {string} [name] name of the node\n     */\n    constructor(name = undefined)\n    {\n        super(name, 1, [\n            InputPort().expects(SpeedyPipelineMessageType.Image),\n            OutputPort().expects(SpeedyPipelineMessageType.Image),\n        ]);\n\n        /** @type {SpeedyMatrix} perspective transformation */\n        this._transform = SpeedyMatrix.Create(3, 3, [1, 0, 0, 0, 1, 0, 0, 0, 1]); // identity matrix\n    }\n\n    /**\n     * Perspective transform, a 3x3 homography matrix\n     * @returns {SpeedyMatrix}\n     */\n    get transform()\n    {\n        return this._transform;\n    }\n\n    /**\n     * Perspective transform, a 3x3 homography matrix\n     * @param {SpeedyMatrix} transform\n     */\n    set transform(transform)\n    {\n        if(!(transform.rows == 3 && transform.columns == 3))\n            throw new IllegalArgumentError(`Not a 3x3 transformation matrix: ${transform}`);\n\n        this._transform = transform;\n    }\n\n    /**\n     * Run the specific task of this node\n     * @param {SpeedyGPU} gpu\n     * @returns {void|SpeedyPromise<void>}\n     */\n    _run(gpu)\n    {\n        const { image, format } = /** @type {SpeedyPipelineMessageWithImage} */ ( this.input().read() );\n        const width = image.width, height = image.height;\n        const outputTexture = this._tex[0];\n        const homography = this._transform.read();\n        const inverseHomography = this._inverse3(homography);\n        const isValidHomography = !Number.isNaN(inverseHomography[0]);\n\n        gpu.programs.transforms.warpPerspective.outputs(width, height, outputTexture);\n        gpu.programs.transforms.warpPerspective(image, isValidHomography ? inverseHomography : SINGULAR_MATRIX);\n\n        this.output().swrite(outputTexture, format);\n    }\n\n    /**\n     * Compute the inverse of a 3x3 matrix IN-PLACE (do it fast!)\n     * @param {number[]} mat 3x3 matrix in column-major format\n     * @param {number} [eps] epsilon\n     * @returns {number[]} 3x3 inverse matrix in column-major format\n     */\n    _inverse3(mat, eps = 1e-6)\n    {\n        // read the entries of the matrix\n        const a11 = mat[0];\n        const a21 = mat[1];\n        const a31 = mat[2];\n        const a12 = mat[3];\n        const a22 = mat[4];\n        const a32 = mat[5];\n        const a13 = mat[6];\n        const a23 = mat[7];\n        const a33 = mat[8];\n\n        // compute cofactors\n        const b1 = a33 * a22 - a32 * a23; // b11\n        const b2 = a33 * a12 - a32 * a13; // b21\n        const b3 = a23 * a12 - a22 * a13; // b31\n\n        // compute the determinant\n        const det = a11 * b1 - a21 * b2 + a31 * b3;\n\n        // set up the inverse\n        if(!(Math.abs(det) < eps)) {\n            const d = 1.0 / det;\n            mat[0] = b1 * d;\n            mat[1] = -(a33 * a21 - a31 * a23) * d;\n            mat[2] = (a32 * a21 - a31 * a22) * d;\n            mat[3] = -b2 * d;\n            mat[4] = (a33 * a11 - a31 * a13) * d;\n            mat[5] = -(a32 * a11 - a31 * a12) * d;\n            mat[6] = b3 * d;\n            mat[7] = -(a23 * a11 - a21 * a13) * d;\n            mat[8] = (a22 * a11 - a21 * a12) * d;\n        }\n        else\n            mat.fill(Number.NaN, 0, 9);\n\n        // done!\n        return mat;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * resize.js\n * Resize image\n */\n\nimport { SpeedyPipelineNode } from '../../pipeline-node';\nimport { SpeedyPipelineMessageType, SpeedyPipelineMessageWithImage } from '../../pipeline-message';\nimport { InputPort, OutputPort } from '../../pipeline-portbuilder';\nimport { SpeedyGPU } from '../../../../gpu/speedy-gpu';\nimport { SpeedyTexture } from '../../../../gpu/speedy-texture';\nimport { Utils } from '../../../../utils/utils';\nimport { IllegalArgumentError } from '../../../../utils/errors';\nimport { ImageFormat } from '../../../../utils/types';\nimport { SpeedySize } from '../../../speedy-size';\nimport { SpeedyVector2 } from '../../../speedy-vector';\nimport { SpeedyPromise } from '../../../../utils/speedy-promise';\n\n/** @typedef {\"bilinear\"|\"nearest\"} SpeedyPipelineNodeResizeMethod */\n\n/**\n * Resize image\n */\nexport class SpeedyPipelineNodeResize extends SpeedyPipelineNode\n{\n    /**\n     * Constructor\n     * @param {string} [name] name of the node\n     */\n    constructor(name = undefined)\n    {\n        super(name, 1, [\n            InputPort().expects(SpeedyPipelineMessageType.Image),\n            OutputPort().expects(SpeedyPipelineMessageType.Image),\n        ]);\n\n        /** @type {SpeedySize} size of the output image, in pixels */\n        this._size = new SpeedySize(0, 0);\n\n        /** @type {SpeedyVector2} size of the output relative to the size of the input */\n        this._scale = new SpeedyVector2(1, 1);\n\n        /** @type {SpeedyPipelineNodeResizeMethod} interpolation method */\n        this._method = 'bilinear';\n    }\n\n    /**\n     * Size of the output image, in pixels (use 0 to use scale)\n     * @returns {SpeedySize}\n     */\n    get size()\n    {\n        return this._size;\n    }\n\n    /**\n     * Size of the output image, in pixels (use 0 to use scale)\n     * @param {SpeedySize} size\n     */\n    set size(size)\n    {\n        this._size = size;\n    }\n\n    /**\n     * Size of the output image relative to the size of the input image\n     * @returns {SpeedyVector2}\n     */\n    get scale()\n    {\n        return this._scale;\n    }\n\n    /**\n     * Size of the output image relative to the size of the input image\n     * @param {SpeedyVector2} scale\n     */\n    set scale(scale)\n    {\n        this._scale = scale;\n    }\n\n    /**\n     * Interpolation method\n     * @returns {SpeedyPipelineNodeResizeMethod}\n     */\n    get method()\n    {\n        return this._method;\n    }\n\n    /**\n     * Interpolation method\n     * @param {SpeedyPipelineNodeResizeMethod} method\n     */\n    set method(method)\n    {\n        if(method !== 'nearest' && method !== 'bilinear')\n            throw new IllegalArgumentError(`Invalid method method: \"${method}\"`);\n\n        this._method = method;\n    }\n\n    /**\n     * Run the specific task of this node\n     * @param {SpeedyGPU} gpu\n     * @returns {void|SpeedyPromise<void>}\n     */\n    _run(gpu)\n    {\n        const { image, format } = /** @type {SpeedyPipelineMessageWithImage} */ ( this.input().read() );\n        const width = image.width, height = image.height;\n        const outputTexture = this._tex[0];\n        const method = this._method;\n        const newWidth = this._size.width || Math.max(1, this._scale.x * width);\n        const newHeight = this._size.height || Math.max(1, this._scale.y * height);\n\n        if(method == 'bilinear') {\n            (gpu.programs.transforms.resizeBilinear\n                .outputs(newWidth, newHeight, outputTexture)\n            )(image);\n        }\n        else if(method == 'nearest') {\n            (gpu.programs.transforms.resizeNearest\n                .outputs(newWidth, newHeight, outputTexture)\n            )(image);\n        }\n\n        this.output().swrite(outputTexture, format);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * sink.js\n * Gets keypoints out of the pipeline\n */\n\nimport { SpeedyPipelineNode, SpeedyPipelineSinkNode } from '../../pipeline-node';\nimport { SpeedyPipelineMessageType, SpeedyPipelineMessageWith2DVectors } from '../../pipeline-message';\nimport { InputPort, OutputPort } from '../../pipeline-portbuilder';\nimport { SpeedyGPU } from '../../../../gpu/speedy-gpu';\nimport { SpeedyTextureReader } from '../../../../gpu/speedy-texture-reader';\nimport { SpeedyTexture } from '../../../../gpu/speedy-texture';\nimport { Utils } from '../../../../utils/utils';\nimport { SpeedyPromise } from '../../../../utils/speedy-promise';\nimport { SpeedyVector2 } from '../../../speedy-vector';\n\n// next power of 2\nconst nextPot = x => x > 1 ? 1 << Math.ceil(Math.log2(x)) : 1;\n\n\n/**\n * Gets 2D vectors out of the pipeline\n */\nexport class SpeedyPipelineNodeVector2Sink extends SpeedyPipelineSinkNode\n{\n    /**\n     * Constructor\n     * @param {string} [name] name of the node\n     */\n    constructor(name = 'vec2')\n    {\n        super(name, 2, [\n            InputPort().expects(SpeedyPipelineMessageType.Vector2)\n        ]);\n\n        /** @type {SpeedyVector2[]} 2D vectors (output) */\n        this._vectors = [];\n\n        /** @type {SpeedyTextureReader} texture reader */\n        this._textureReader = new SpeedyTextureReader();\n\n        /** @type {number} page flipping index */\n        this._page = 0;\n\n        /** @type {boolean} accelerate GPU-CPU transfers */\n        this._turbo = false;\n    }\n\n    /**\n     * Accelerate GPU-CPU transfers\n     * @returns {boolean}\n     */\n    get turbo()\n    {\n        return this._turbo;\n    }\n\n    /**\n     * Accelerate GPU-CPU transfers\n     * @param {boolean} value\n     */\n    set turbo(value)\n    {\n        this._turbo = Boolean(value);\n    }\n\n    /**\n     * Initializes this node\n     * @param {SpeedyGPU} gpu\n     */\n    init(gpu)\n    {\n        super.init(gpu);\n        this._textureReader.init(gpu);\n    }\n\n    /**\n     * Releases this node\n     * @param {SpeedyGPU} gpu\n     */\n    release(gpu)\n    {\n        this._textureReader.release(gpu);\n        super.release(gpu);\n    }\n\n    /**\n     * Export data from this node to the user\n     * @returns {SpeedyPromise<SpeedyVector2[]>}\n     */\n    export()\n    {\n        return SpeedyPromise.resolve(this._vectors);\n    }\n\n    /**\n     * Run the specific task of this node\n     * @param {SpeedyGPU} gpu\n     * @returns {void|SpeedyPromise<void>}\n     */\n    _run(gpu)\n    {\n        const { vectors } = /** @type {SpeedyPipelineMessageWith2DVectors} */ ( this.input().read() );\n        const useBufferedDownloads = this._turbo;\n        const encoderLength = vectors.width;\n\n        /*\n\n        I have found experimentally that, in Firefox, readPixelsAsync()\n        performs MUCH better if the width of the target texture is a power\n        of two. I have no idea why this is the case, nor if it's related to\n        some interaction with the GL drivers, somehow. This seems to make no\n        difference on Chrome, however. In any case, let's convert the input\n        texture to POT.\n\n        */\n        const encoderWidth = nextPot(encoderLength);\n        const encoderHeight = nextPot(Math.ceil(encoderLength * encoderLength / encoderWidth));\n        //const encoderHeight = (Math.ceil(encoderLength * encoderLength / encoderWidth));\n\n        // copy the set of vectors to an internal texture\n        const copiedTexture = this._tex[this._page];\n        (gpu.programs.utils.copy2DVectors\n            .outputs(encoderWidth, encoderHeight, copiedTexture)\n        )(vectors);\n\n        // flip page\n        this._page = 1 - this._page;\n\n        // download the internal texture\n        return this._textureReader.readPixelsAsync(copiedTexture, 0, 0, copiedTexture.width, copiedTexture.height, useBufferedDownloads).then(pixels => {\n            this._vectors = SpeedyPipelineNodeVector2Sink._decode(pixels, encoderWidth, encoderHeight);\n        });\n    }\n\n    /**\n     * Decode a sequence of vectors, given a flattened image of encoded pixels\n     * @param {Uint8Array} pixels pixels in the [r,g,b,a,...] format\n     * @param {number} encoderWidth\n     * @param {number} encoderHeight\n     * @returns {SpeedyVector2[]} vectors\n     */\n    static _decode(pixels, encoderWidth, encoderHeight)\n    {\n        const bytesPerVector = 4; // 1 pixel per vector\n        const vectors = [];\n        let hi = 0, lo = 0;\n        let x = 0, y = 0;\n\n        // how many bytes should we read?\n        const e2 = encoderWidth * encoderHeight * bytesPerVector;\n        const size = Math.min(pixels.length, e2);\n\n        // for each encoded vector\n        for(let i = 0; i < size; i += bytesPerVector) {\n            // extract 16-bit words\n            lo = (pixels[i+1] << 8) | pixels[i];\n            hi = (pixels[i+3] << 8) | pixels[i+2];\n\n            // the vector is \"null\": we have reached the end of the list\n            if(lo == 0xFFFF && hi == 0xFFFF)\n                break;\n\n            // the vector must be discarded\n            if(lo == 0xFF00 && hi == 0xFF00)\n                continue;\n\n            // decode floats\n            x = Utils.decodeFloat16(lo);\n            y = Utils.decodeFloat16(hi);\n\n            // register vector\n            vectors.push(new SpeedyVector2(x, y));\n        }\n\n        // done!\n        return vectors;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * pipeline-message.js\n * A message that is shared between nodes of a pipeline\n */\n\nimport { Utils } from '../../utils/utils';\nimport { ImageFormat } from '../../utils/types';\nimport { AbstractMethodError } from '../../utils/errors';\nimport { SpeedyTexture, SpeedyDrawableTexture } from '../../gpu/speedy-texture';\nimport { SpeedyLSH } from '../../gpu/speedy-lsh';\n\n/**\n * Types of messages\n * @enum {Symbol}\n */\nexport const SpeedyPipelineMessageType = Object.freeze({\n    Nothing: Symbol('Nothing'),\n    Image: Symbol('Image'),\n    Keypoints: Symbol('Keypoints'),\n    Vector2: Symbol('Vector2'),\n    LSHTables: Symbol('LSHTables'),\n    KeypointMatches: Symbol('KeypointMatches'),\n});\n\n/**\n * A message that is shared between nodes of a pipeline\n * @abstract\n */\nexport class SpeedyPipelineMessage\n{\n    /**\n     * Constructor\n     * @param {SpeedyPipelineMessageType} type message type\n     */\n    constructor(type)\n    {\n        /** @type {SpeedyPipelineMessageType} message type */\n        this._type = type;\n    }\n\n    /**\n     * Message type\n     * @returns {SpeedyPipelineMessageType}\n     */\n    get type()\n    {\n        return this._type;\n    }\n\n    /**\n     * Checks if the type of this message is equal to parameter type\n     * @param {SpeedyPipelineMessageType} type\n     * @returns {boolean}\n     */\n    hasType(type)\n    {\n        return this._type === type;\n    }\n\n    /**\n     * Is this an empty message?\n     * @returns {boolean}\n     */\n    isEmpty()\n    {\n        return this.hasType(SpeedyPipelineMessageType.Nothing);\n    }\n\n    /**\n     * Convert to string\n     * @returns {string}\n     */\n    toString()\n    {\n        const type = Object.keys(SpeedyPipelineMessageType).find(\n            type => SpeedyPipelineMessageType[type] === this.type\n        );\n\n        return `message of type ${type}`;\n    }\n\n    /**\n     * Set parameters\n     * @abstract\n     * @param  {...any} args\n     * @returns {SpeedyPipelineMessage} this message\n     */\n    set(...args)\n    {\n        throw new AbstractMethodError();\n    }\n\n    /**\n     * Create a message of the specified type\n     * @param {SpeedyPipelineMessageType} type\n     * @returns {SpeedyPipelineMessage}\n     */\n    static create(type)\n    {\n        return createMessage(type);\n    }\n}\n\n/**\n * An empty message carrying nothing\n */\nexport class SpeedyPipelineMessageWithNothing extends SpeedyPipelineMessage\n{\n    /**\n     * Constructor\n     */\n    constructor()\n    {\n        super(SpeedyPipelineMessageType.Nothing);\n    }\n\n    /**\n     * Set parameters\n     * @returns {SpeedyPipelineMessage} this message\n     */\n    set()\n    {\n        return this;\n    }\n}\n\n/**\n * A message transporting an image\n */\nexport class SpeedyPipelineMessageWithImage extends SpeedyPipelineMessage\n{\n    /**\n     * Constructor\n     */\n    constructor()\n    {\n        super(SpeedyPipelineMessageType.Image);\n\n        /** @type {SpeedyDrawableTexture} the image we carry */\n        this._image = null;\n\n        /** @type {ImageFormat} image format */\n        this._format = ImageFormat.RGBA;\n    }\n\n    /**\n     * Set parameters\n     * @param {SpeedyDrawableTexture} image the image we carry\n     * @param {ImageFormat} [format] image format\n     * @returns {SpeedyPipelineMessage} this message\n     */\n    set(image, format = ImageFormat.RGBA)\n    {\n        // set parameters\n        this._image = image;\n        this._format = format;\n\n        // done!\n        return this;\n    }\n\n    /**\n     * The image we carry\n     * @returns {SpeedyDrawableTexture}\n     */\n    get image()\n    {\n        return this._image;\n    }\n\n    /**\n     * Image format\n     * @returns {ImageFormat}\n     */\n    get format()\n    {\n        return this._format;\n    }\n}\n\n/**\n * A message transporting keypoints\n */\nexport class SpeedyPipelineMessageWithKeypoints extends SpeedyPipelineMessage\n{\n    /**\n     * Constructor\n     */\n    constructor()\n    {\n        super(SpeedyPipelineMessageType.Keypoints);\n\n        /** @type {SpeedyDrawableTexture} encoded keypoints */\n        this._encodedKeypoints = null;\n\n        /** @type {number} descriptor size in bytes */\n        this._descriptorSize = 0;\n\n        /** @type {number} extra size in bytes */\n        this._extraSize = 0;\n\n        /** @type {number} encoder length */\n        this._encoderLength = 1;\n    }\n\n    /**\n     * Set parameters\n     * @param {SpeedyDrawableTexture} encodedKeypoints encoded keypoints\n     * @param {number} descriptorSize in bytes\n     * @param {number} extraSize in bytes\n     * @param {number} encoderLength positive integer\n     * @returns {SpeedyPipelineMessage} this message\n     */\n    set(encodedKeypoints, descriptorSize, extraSize, encoderLength)\n    {\n        // set parameters\n        this._encodedKeypoints = encodedKeypoints;\n        this._descriptorSize = descriptorSize | 0;\n        this._extraSize = extraSize | 0;\n        this._encoderLength = encoderLength | 0;\n\n        // validate\n        Utils.assert(this._descriptorSize >= 0 && this._extraSize >= 0);\n        Utils.assert(this._encoderLength === this._encodedKeypoints.width, 'Invalid encoderLength');\n        Utils.assert(this._encodedKeypoints.width === this._encodedKeypoints.height, 'Invalid encodedKeypoints texture');\n\n        // done!\n        return this;\n    }\n\n    /**\n     * Encoded keypoints\n     * @returns {SpeedyDrawableTexture}\n     */\n    get encodedKeypoints()\n    {\n        return this._encodedKeypoints;\n    }\n\n    /**\n     * Descriptor size, in bytes\n     * @returns {number}\n     */\n    get descriptorSize()\n    {\n        return this._descriptorSize;\n    }\n\n    /**\n     * Extra size, in bytes\n     * @returns {number}\n     */\n    get extraSize()\n    {\n        return this._extraSize;\n    }\n\n    /**\n     * Encoder length\n     * @returns {number}\n     */\n    get encoderLength()\n    {\n        return this._encoderLength;\n    }\n}\n\n/*\n * A message transporting a set of 2D vectors\n */\nexport class SpeedyPipelineMessageWith2DVectors extends SpeedyPipelineMessage\n{\n    /**\n     * Constructor\n     */\n    constructor()\n    {\n        super(SpeedyPipelineMessageType.Vector2);\n\n        /** @type {SpeedyDrawableTexture} the set of vectors */\n        this._vectors = null;\n    }\n\n    /**\n     * Set parameters\n     * @param {SpeedyDrawableTexture} vectors the set of vectors\n     * @returns {SpeedyPipelineMessage} this message\n     */\n    set(vectors)\n    {\n        // set parameters\n        this._vectors = vectors;\n\n        // done!\n        return this;\n    }\n\n    /**\n     * The set of vectors\n     * @returns {SpeedyDrawableTexture}\n     */\n    get vectors()\n    {\n        return this._vectors;\n    }\n}\n\n/**\n * A message transporting LSH tables\n */\nexport class SpeedyPipelineMessageWithLSHTables extends SpeedyPipelineMessage\n{\n    /**\n     * Constructor\n     */\n    constructor()\n    {\n        super(SpeedyPipelineMessageType.LSHTables);\n\n        /** @type {SpeedyLSH} LSH data structure */\n        this._lsh = null;\n    }\n\n    /**\n     * Set parameters\n     * @param {SpeedyLSH} lsh\n     * @returns {SpeedyPipelineMessage} this message\n     */\n    set(lsh)\n    {\n        // set parameters\n        this._lsh = lsh;\n\n        // done!\n        return this;\n    }\n\n    /**\n     * LSH data structure\n     * @returns {SpeedyLSH}\n     */\n    get lsh()\n    {\n        return this._lsh;\n    }\n}\n\n/*\n * A message transporting a set of keypoint matches\n */\nexport class SpeedyPipelineMessageWithKeypointMatches extends SpeedyPipelineMessage\n{\n    /**\n     * Constructor\n     */\n    constructor()\n    {\n        super(SpeedyPipelineMessageType.KeypointMatches);\n\n        /** @type {SpeedyDrawableTexture} keypoint matches (note: 1 pixel encodes 1 match) */\n        this._encodedMatches = null;\n\n        /** @type {number} number of matches per keypoint */\n        this._matchesPerKeypoint = 1;\n    }\n\n    /**\n     * Set parameters\n     * @param {SpeedyDrawableTexture} encodedMatches\n     * @param {number} matchesPerKeypoint\n     * @returns {SpeedyPipelineMessage} this message\n     */\n    set(encodedMatches, matchesPerKeypoint)\n    {\n        // set parameters\n        this._encodedMatches = encodedMatches;\n        this._matchesPerKeypoint = matchesPerKeypoint | 0;\n\n        // validate\n        Utils.assert(this._matchesPerKeypoint > 0);\n\n        // done!\n        return this;\n    }\n\n    /**\n     * The matches\n     * @returns {SpeedyDrawableTexture}\n     */\n    get encodedMatches()\n    {\n        return this._encodedMatches;\n    }\n\n    /**\n     * Number of matches per keypoint\n     * @returns {number}\n     */\n    get matchesPerKeypoint()\n    {\n        return this._matchesPerKeypoint;\n    }\n}\n\n\n\n\n\n\n//\n// Utilities\n//\n\n\n\n/** Map message type to message class */\nconst MESSAGE_CLASS = Object.freeze({\n    [SpeedyPipelineMessageType.Nothing]: SpeedyPipelineMessageWithNothing,\n    [SpeedyPipelineMessageType.Image]: SpeedyPipelineMessageWithImage,\n    [SpeedyPipelineMessageType.Keypoints]: SpeedyPipelineMessageWithKeypoints,\n    [SpeedyPipelineMessageType.Vector2]: SpeedyPipelineMessageWith2DVectors,\n    [SpeedyPipelineMessageType.LSHTables]: SpeedyPipelineMessageWithLSHTables,\n    [SpeedyPipelineMessageType.KeypointMatches]: SpeedyPipelineMessageWithKeypointMatches,\n});\n\n/**\n * Create a message of the specified type\n * @param {SpeedyPipelineMessageType} type\n * @returns {SpeedyPipelineMessage}\n */\nfunction createMessage(type)\n{\n    //return Reflect.construct(MESSAGE_CLASS[type], []);\n    return new MESSAGE_CLASS[\n        // error TS2538: Type 'Symbol' cannot be used as an index type.\n        // heck, what the hack...\n        /** @type {any} */ ( type )\n    ];\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * pipeline-node.js\n * Node of a pipeline\n */\n\nimport { Utils } from '../../utils/utils';\nimport { LITTLE_ENDIAN } from '../../utils/globals';\nimport { SpeedyPromise } from '../../utils/speedy-promise';\nimport { AbstractMethodError, IllegalArgumentError } from '../../utils/errors';\nimport { SpeedyPipelinePort, SpeedyPipelineInputPort, SpeedyPipelineOutputPort } from './pipeline-port';\nimport { SpeedyPipelinePortBuilder } from './pipeline-portbuilder';\nimport { SpeedyGPU } from '../../gpu/speedy-gpu';\nimport { SpeedyTexture, SpeedyDrawableTexture } from '../../gpu/speedy-texture';\nimport { SpeedyTextureReader } from '../../gpu/speedy-texture-reader';\n\n/** @typedef {Object<string,SpeedyPipelineInputPort>} InputPortDictionary */\n/** @typedef {Object<string,SpeedyPipelineOutputPort>} OutputPortDictionary */\n\n/** Generate a random name for a node */\nconst generateRandomName = () => Math.random().toString(16).substr(2);\n\n/** Create an empty input port dictionary */\nconst createInputPortDictionary = () => /** @type {InputPortDictionary} */ ( Object.create(null) );\n\n/** Create an empty output port dictionary */\nconst createOutputPortDictionary = () => /** @type {OutputPortDictionary} */ ( Object.create(null) );\n\n/**\n * Map an array of input ports to an InputPortDictionary whose keys are their names\n * @param {SpeedyPipelineInputPort[]} ports\n * @returns {InputPortDictionary}\n */\nfunction InputPortDictionary(ports)\n{\n    return ports.reduce((dict, port) => ((dict[port.name] = port), dict), createInputPortDictionary());\n}\n\n/**\n * Map an array of output ports to an OutputPortDictionary whose keys are their names\n * @param {SpeedyPipelineOutputPort[]} ports\n * @returns {OutputPortDictionary}\n */\nfunction OutputPortDictionary(ports)\n{\n    return ports.reduce((dict, port) => ((dict[port.name] = port), dict), createOutputPortDictionary());\n}\n\n/** A flag used for debugging purposes */\nlet _texView = false;\n\n\n\n/**\n * Node of a pipeline\n * @abstract\n */\nexport class SpeedyPipelineNode\n{\n    /**\n     * Constructor\n     * @param {string} [name] the name of this node\n     * @param {number} [texCount] number of work textures\n     * @param {SpeedyPipelinePortBuilder[]} [portBuilders] port builders\n     */\n    constructor(name = generateRandomName(), texCount = 0, portBuilders = [])\n    {\n        /** @type {string} the name of this node */\n        this._name = String(name);\n\n        /** @type {SpeedyDrawableTexture[]} work texture(s) */\n        this._tex = (new Array(texCount)).fill(null);\n\n\n\n        // build the ports\n        const ports = portBuilders.map(builder => builder.build(this));\n        const inputPorts = /** @type {SpeedyPipelineInputPort[]} */ ( ports.filter(port => port.isInputPort()) );\n        const outputPorts = /** @type {SpeedyPipelineOutputPort[]} */ ( ports.filter(port => port.isOutputPort()) );\n\n        /** @type {InputPortDictionary} input ports */\n        this._inputPorts = InputPortDictionary(inputPorts);\n\n        /** @type {OutputPortDictionary} output ports */\n        this._outputPorts = OutputPortDictionary(outputPorts);\n\n\n\n        // validate\n        if(this._name.length == 0)\n            throw new IllegalArgumentError(`Invalid name \"${this._name}\" for node ${this.fullName}`);\n        else if(portBuilders.length == 0)\n            throw new IllegalArgumentError(`No ports have been found in node ${this.fullName}`);\n    }\n\n    /**\n     * The name of this node\n     * @returns {string}\n     */\n    get name()\n    {\n        return this._name;\n    }\n\n    /**\n     * Name and type of this node\n     * @returns {string}\n     */\n    get fullName()\n    {\n        return `${this.constructor.name}[${this.name}]`;\n    }\n\n    /**\n     * Find input port by name\n     * @param {string} [portName]\n     * @returns {SpeedyPipelineInputPort}\n     */\n    input(portName = SpeedyPipelineInputPort.DEFAULT_NAME)\n    {\n        if(portName in this._inputPorts)\n            return this._inputPorts[portName];\n\n        throw new IllegalArgumentError(`Can't find input port ${portName} in node ${this.fullName}`);\n    }\n\n    /**\n     * Find output port by name\n     * @param {string} [portName]\n     * @returns {SpeedyPipelineOutputPort}\n     */\n    output(portName = SpeedyPipelineOutputPort.DEFAULT_NAME)\n    {\n        if(portName in this._outputPorts)\n            return this._outputPorts[portName];\n\n        throw new IllegalArgumentError(`Can't find output port ${portName} in node ${this.fullName}`);\n    }\n\n    /**\n     * Get data from the input ports and execute\n     * the task that this node is supposed to!\n     * @param {SpeedyGPU} gpu\n     * @returns {void|SpeedyPromise<void>}\n     */\n    execute(gpu)\n    {\n        let portName;\n\n        // clear output ports\n        for(portName in this._outputPorts)\n            this._outputPorts[portName].clearMessage();\n\n        // let the input ports receive what is due\n        for(portName in this._inputPorts)\n            this._inputPorts[portName].pullMessage(this.fullName);\n\n        // run the task\n        const runTask = this._run(gpu);\n        if(typeof runTask === 'undefined') {\n            for(portName in this._outputPorts) // ensure that no output ports are empty\n                Utils.assert(this._outputPorts[portName].hasMessage(), `Did you forget to write data to the output port ${portName} of ${this.fullName}?`);\n\n            return undefined;\n        }\n        else return runTask.then(() => {\n            for(portName in this._outputPorts) // ensure that no output ports are empty\n                Utils.assert(this._outputPorts[portName].hasMessage(), `Did you forget to write data to the output port ${portName} of ${this.fullName}?`);\n        });\n    }\n\n    /**\n     * Run the specific task of this node\n     * @abstract\n     * @param {SpeedyGPU} gpu\n     * @returns {void|SpeedyPromise<void>}\n     */\n    _run(gpu)\n    {\n        throw new AbstractMethodError();\n    }\n\n    /**\n     * Initializes this node\n     * @param {SpeedyGPU} gpu\n     */\n    init(gpu)\n    {\n        gpu.subscribe(this._allocateWorkTextures, this, gpu);\n        this._allocateWorkTextures(gpu);\n    }\n\n    /**\n     * Releases this node\n     * @param {SpeedyGPU} gpu\n     */\n    release(gpu)\n    {\n        this._deallocateWorkTextures(gpu);\n        gpu.unsubscribe(this._allocateWorkTextures, this);\n    }\n\n    /**\n     * Clear all ports\n     */\n    clearPorts()\n    {\n        let portName;\n\n        for(portName in this._inputPorts)\n            this._inputPorts[portName].clearMessage();\n\n        for(portName in this._outputPorts)\n            this._outputPorts[portName].clearMessage();\n    }\n\n    /**\n     * Find all nodes that feed input to this node\n     * @returns {SpeedyPipelineNode[]}\n     */\n    inputNodes()\n    {\n        const nodes = [];\n\n        for(const portName in this._inputPorts) {\n            const port = this._inputPorts[portName];\n            if(port.incomingLink != null)\n                nodes.push(port.incomingLink.node);\n        }\n\n        return nodes;\n    }\n\n    /**\n     * Is this a source of the pipeline?\n     * @returns {boolean}\n     */\n    isSource()\n    {\n        return false;\n    }\n\n    /**\n     * Is this a sink of the pipeline?\n     * @returns {boolean}\n     */\n    isSink()\n    {\n        return false;\n\n        // note: a portal sink has no output ports, but it isn't a sink of the pipeline!\n        //return Object.keys(this._outputPorts).length == 0;\n    }\n\n    /**\n     * Allocate work texture(s)\n     * @param {SpeedyGPU} gpu\n     */\n    _allocateWorkTextures(gpu)\n    {\n        for(let j = 0; j < this._tex.length; j++)\n            this._tex[j] = gpu.texturePool.allocate();\n    }\n\n    /**\n     * Deallocate work texture(s)\n     * @param {SpeedyGPU} gpu\n     */\n    _deallocateWorkTextures(gpu)\n    {\n        for(let j = this._tex.length - 1; j >= 0; j--)\n            this._tex[j] = gpu.texturePool.free(this._tex[j]);\n    }\n\n    /**\n     * Inspect the pixels of a texture for debugging purposes\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyDrawableTexture} texture\n     * @returns {Uint8Array}\n     */\n    _inspect(gpu, texture)\n    {\n        const textureReader = new SpeedyTextureReader();\n        textureReader.init(gpu);\n        const pixels = textureReader.readPixelsSync(texture);\n        textureReader.release(gpu);\n\n        return new Uint8Array(pixels); // copy the array\n    }\n\n    /**\n     * Inspect the pixels of a texture as unsigned 32-bit integers\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyDrawableTexture} texture\n     * @returns {Uint32Array}\n     */\n    _inspect32(gpu, texture)\n    {\n        Utils.assert(LITTLE_ENDIAN); // make sure we use little-endian\n        return new Uint32Array(this._inspect(gpu, texture).buffer);\n    }\n\n    /**\n     * Visually inspect a texture for debugging purposes\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyDrawableTexture} texture\n     */\n    _visualize(gpu, texture)\n    {\n        const canvas = gpu.renderToCanvas(texture);\n        if(!_texView) {\n            document.body.appendChild(canvas);\n            _texView = true;\n        }\n    }\n}\n\n/**\n * Source node (a node with no input ports)\n * @abstract\n */\nexport class SpeedyPipelineSourceNode extends SpeedyPipelineNode\n{\n    /**\n     * Constructor\n     * @param {string} [name] the name of this node\n     * @param {number} [texCount] number of work textures\n     * @param {SpeedyPipelinePortBuilder[]} [portBuilders] port builders\n     */\n    constructor(name = undefined, texCount = undefined, portBuilders = undefined)\n    {\n        super(name, texCount, portBuilders);\n        Utils.assert(Object.keys(this._inputPorts).length == 0);\n    }\n\n    /**\n     * Is this a source of the pipeline?\n     * @returns {boolean}\n     */\n    isSource()\n    {\n        return true;\n    }\n}\n\n/**\n * Sink node (a node with no output ports)\n * @abstract\n */\nexport class SpeedyPipelineSinkNode extends SpeedyPipelineNode\n{\n    /**\n     * Constructor\n     * @param {string} [name] the name of this node\n     * @param {number} [texCount] number of work textures\n     * @param {SpeedyPipelinePortBuilder[]} [portBuilders] port builders\n     */\n    constructor(name = undefined, texCount = undefined, portBuilders = undefined)\n    {\n        super(name, texCount, portBuilders);\n        Utils.assert(Object.keys(this._outputPorts).length == 0);\n    }\n\n    /**\n     * Export data from this node to the user\n     * @abstract\n     * @returns {SpeedyPromise<any>}\n     */\n    export()\n    {\n        throw new AbstractMethodError();\n    }\n\n    /**\n     * Is this a sink of the pipeline?\n     * @returns {boolean}\n     */\n    isSink()\n    {\n        return true;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * pipeline-port.js\n * Port of a node of a pipeline\n */\n\nimport { Utils } from '../../utils/utils';\nimport { IllegalArgumentError, IllegalOperationError, AbstractMethodError, NotSupportedError } from '../../utils/errors';\nimport { SpeedyPipelinePortSpec } from './pipeline-portspec';\nimport { SpeedyPipelineMessage, SpeedyPipelineMessageWithNothing } from './pipeline-message';\nimport { SpeedyPipelineNode } from './pipeline-node';\n\n// Constants\nconst DEFAULT_INPUT_PORT_NAME = 'in';\nconst DEFAULT_OUTPUT_PORT_NAME = 'out';\nconst ACCEPTABLE_PORT_NAME = /^[a-z][a-zA-Z0-9]*$/;\nconst EMPTY_MESSAGE = new SpeedyPipelineMessageWithNothing();\n\n/**\n * Port of a node of a pipeline\n * @abstract\n */\nexport class SpeedyPipelinePort\n{\n    /**\n     * Constructor\n     * @param {string} name the name of this port \n     * @param {SpeedyPipelinePortSpec} spec port specification\n     * @param {SpeedyPipelineNode} node the node to which this port belongs\n     */\n    constructor(name, spec, node)\n    {\n        /** @type {string} the name of this port */\n        this._name = String(name);\n\n        /** @type {SpeedyPipelinePortSpec} the specification of this port */\n        this._spec = spec;\n\n        /** @type {SpeedyPipelineNode} the node to which this port belongs */\n        this._node = node;\n\n        /** @type {SpeedyPipelineMessage} the message located in this port */\n        this._message = EMPTY_MESSAGE;\n\n\n        // check if we've got an acceptable port name\n        Utils.assert(ACCEPTABLE_PORT_NAME.test(this._name), `Port name \"${this._name}\" is not acceptable`);\n    }\n\n    /**\n     * The name of this port\n     * @returns {string}\n     */\n    get name()\n    {\n        return this._name;\n    }\n\n    /**\n     * The node to which this port belongs\n     * @returns {SpeedyPipelineNode}\n     */\n    get node()\n    {\n        return this._node;\n    }\n\n    /**\n     * Connect this port to another\n     * @abstract\n     * @param {SpeedyPipelinePort} port\n     */\n    connectTo(port)\n    {\n        throw new AbstractMethodError();\n    }\n\n    /**\n     * Is this an input port?\n     * @abstract\n     * @returns {boolean}\n     */\n    isInputPort()\n    {\n        throw new AbstractMethodError();\n    }\n\n    /**\n     * Is this an output port?\n     * @returns {boolean}\n     */\n    isOutputPort()\n    {\n        return !this.isInputPort();\n    }\n\n    /**\n     * Clear the message stored in this port\n     */\n    clearMessage()\n    {\n        this._message = EMPTY_MESSAGE;\n    }\n\n    /**\n     * Is there a valid message located in this port?\n     * @returns {boolean}\n     */\n    hasMessage()\n    {\n        return !this._message.isEmpty();\n    }\n\n    /**\n     * Read the message that is in this port\n     * @returns {SpeedyPipelineMessage}\n     */\n    read()\n    {\n        if(this._message.isEmpty())\n            throw new IllegalOperationError(`Can't read from port ${this.name}: nothing to read`);\n\n        return this._message;\n    }\n\n    /**\n     * Write a message to this port\n     * @param {SpeedyPipelineMessage} message\n     */\n    write(message)\n    {\n        throw new NotSupportedError(`Can't write ${message} to port ${this.name}: unsupported operation`);\n    }\n\n    /**\n     * Default port name\n     * @abstract\n     * @returns {string}\n     */\n    static get DEFAULT_NAME()\n    {\n        throw new AbstractMethodError();\n    }\n}\n\n/**\n * Output port\n */\nexport class SpeedyPipelineOutputPort extends SpeedyPipelinePort\n{\n    /**\n     * Constructor\n     * @param {string} name the name of this port \n     * @param {SpeedyPipelinePortSpec} spec port specification\n     * @param {SpeedyPipelineNode} node the node to which this port belongs\n     */\n    constructor(name, spec, node)\n    {\n        super(name, spec, node);\n\n        /** @type {SpeedyPipelineMessage} cached message */\n        this._cachedMessage = null;\n    }\n\n    /**\n     * Connect this port to another\n     * @param {SpeedyPipelineInputPort} port\n     */\n    connectTo(port)\n    {\n        if(!port.isInputPort())\n            throw new IllegalArgumentError(`Can't connect output port ${this.name} to port ${port.name}: expected an input port`);\n\n        port.connectTo(this);\n    }\n\n    /**\n     * Is this an input port?\n     * @returns {boolean}\n     */\n    isInputPort()\n    {\n        return false;\n    }\n\n    /**\n     * Write a message to this port\n     * @param {SpeedyPipelineMessage} message\n     */\n    write(message)\n    {\n        if(!this._spec.accepts(message))\n            throw new IllegalArgumentError(`Can't write ${message} to port ${this.name}. ${this._spec}`);\n\n        this._message = message;\n    }\n\n    /**\n     * Write a message to this port using a cached message object\n     * @param  {...any} args to be passed to SpeedyPipelineMessage.set()\n     */\n    swrite(...args)\n    {\n        if(this._cachedMessage == null)\n            this._cachedMessage = SpeedyPipelineMessage.create(this._spec.expectedMessageType);\n\n        this.write(this._cachedMessage.set(...args));\n    }\n\n    /**\n     * Default port name\n     * @returns {string}\n     */\n    static get DEFAULT_NAME()\n    {\n        return DEFAULT_OUTPUT_PORT_NAME;\n    }\n}\n\n/**\n * Input port\n */\nexport class SpeedyPipelineInputPort extends SpeedyPipelinePort\n{\n    /**\n     * Constructor\n     * @param {string} name the name of this port \n     * @param {SpeedyPipelinePortSpec} spec port specification\n     * @param {SpeedyPipelineNode} node the node to which this port belongs\n     */\n    constructor(name, spec, node)\n    {\n        super(name, spec, node);\n\n        /** @type {SpeedyPipelineOutputPort|null} incoming link */\n        this._incomingLink = null;\n    }\n\n    /**\n     * Incoming link\n     * @returns {SpeedyPipelineOutputPort|null}\n     */\n    get incomingLink()\n    {\n        return this._incomingLink;\n    }\n\n    /**\n     * Connect this port to another\n     * @param {SpeedyPipelineOutputPort} port\n     */\n    connectTo(port)\n    {\n        if(!port.isOutputPort())\n            throw new IllegalArgumentError(`Can't connect input port ${this.name} of \"${this.node.fullName}\" to input port ${port.name} of \"${port.node.fullName}\": expected an output port`);\n        else if(!this._spec.isCompatibleWith(port._spec))\n            throw new IllegalArgumentError(`Can't connect port ${this.name} of \"${this.node.fullName}\" to port ${port.name} of \"${port.node.fullName}\": incompatible types`);\n\n        this._incomingLink = port;\n    }\n\n    /**\n     * Unlink this port\n     */\n    disconnect()\n    {\n        this._incomingLink = null;\n    }\n\n    /**\n     * Is this an input port?\n     * @returns {boolean}\n     */\n    isInputPort()\n    {\n        return true;\n    }\n\n    /**\n     * Receive a message using the incoming link\n     * @param {string} [nodeName]\n     * @returns {SpeedyPipelineMessage}\n     */\n    pullMessage(nodeName = '')\n    {\n        const name = nodeName.length > 0 ? `${this.name} of ${nodeName}` : this.name;\n\n        if(this._incomingLink == null)\n            throw new IllegalOperationError(`No incoming link for input port ${name}`);\n\n        const message = this._incomingLink.read();\n        if(!this._spec.accepts(message))\n            throw new IllegalArgumentError(`Can't receive ${message} at port ${name}: ${this._spec}`);\n\n        return (this._message = message);\n    }\n\n    /**\n     * Default port name\n     * @returns {string}\n     */\n    static get DEFAULT_NAME()\n    {\n        return DEFAULT_INPUT_PORT_NAME;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * pipeline-portbuilder.js\n * Builder of a port of a node of a pipeline\n */\n\nimport { Utils } from '../../utils/utils';\nimport { SpeedyPipelinePort, SpeedyPipelineInputPort, SpeedyPipelineOutputPort } from './pipeline-port';\nimport { SpeedyPipelinePortSpec } from './pipeline-portspec';\nimport { SpeedyPipelineMessage, SpeedyPipelineMessageType } from './pipeline-message';\nimport { SpeedyPipelineNode } from './pipeline-node';\n\n/**\n * @typedef {import('./pipeline-portspec').SpeedyPipelineMessageConstraint} SpeedyPipelineMessageConstraint\n */\n\n/**\n * Builder of a port of a node of a pipeline\n */\nexport class SpeedyPipelinePortBuilder\n{\n    /**\n     * Constructor\n     * @param {typeof SpeedyPipelinePort} portClass input or output?\n     * @param {string} portName\n     */\n    constructor(portClass, portName)\n    {\n        /** @type {typeof SpeedyPipelinePort} input or output? */\n        this._class = portClass;\n\n        /** @type {string} port name */\n        this._name = String(portName);\n\n        /** @type {SpeedyPipelineMessageType} accepted message type */\n        this._type = SpeedyPipelineMessageType.Nothing;\n\n        /** @type {SpeedyPipelineMessageConstraint} message validation function */\n        this._messageConstraint = undefined;\n    }\n\n    /**\n     * Declare that the new port expects a certain type of message\n     * @param {SpeedyPipelineMessageType} type expected type\n     * @returns {SpeedyPipelinePortBuilder} this builder\n     */\n    expects(type)\n    {\n        Utils.assert(this._type == SpeedyPipelineMessageType.Nothing);\n        Utils.assert(type != SpeedyPipelineMessageType.Nothing);\n\n        this._type = type;\n\n        return this;\n    }\n\n    /**\n     * Declare that the new port expects messages satisfying a constraint\n     * @param {SpeedyPipelineMessageConstraint} constraint\n     * @returns {SpeedyPipelinePortBuilder} this builder\n     */\n    satisfying(constraint)\n    {\n        Utils.assert(this._type != SpeedyPipelineMessageType.Nothing, 'You must first declare what type of message this port expects');\n        Utils.assert(this._messageConstraint === undefined);\n        Utils.assert(typeof constraint === 'function');\n\n        this._messageConstraint = constraint;\n\n        return this;\n    }\n\n    /**\n     * Build a port\n     * @param {SpeedyPipelineNode} node the node to which the new port will belong\n     * @returns {SpeedyPipelinePort}\n     */\n    build(node)\n    {\n        const spec = new SpeedyPipelinePortSpec(this._type, this._messageConstraint);\n        return Reflect.construct(this._class, [this._name, spec, node]);\n    }\n}\n\n/**\n * Creates a builder for an input port\n * @param {string} [portName]\n * @returns {SpeedyPipelinePortBuilder}\n */\nexport function InputPort(portName = SpeedyPipelineInputPort.DEFAULT_NAME)\n{\n    return new SpeedyPipelinePortBuilder(SpeedyPipelineInputPort, portName);\n}\n\n/**\n * Creates a builder for an output port\n * @param {string} [portName]\n * @returns {SpeedyPipelinePortBuilder}\n */\nexport function OutputPort(portName = SpeedyPipelineOutputPort.DEFAULT_NAME)\n{\n    return new SpeedyPipelinePortBuilder(SpeedyPipelineOutputPort, portName);\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * pipeline-portspec.js\n * Specification (requirements) of a port of a node of a pipeline\n */\n\nimport { SpeedyPipelineMessage, SpeedyPipelineMessageType } from './pipeline-message';\nimport { Utils } from '../../utils/utils';\n\n/**\n * A message constraint is a message validation predicate\n * @typedef {function(SpeedyPipelineMessage): boolean} SpeedyPipelineMessageConstraint\n */\n\n/**\n * A validation predicate that validates all messages\n * @type {SpeedyPipelineMessageConstraint}\n */\nconst none = message => true;\n\n/**\n * Specification (requirements) of a port of a node of a pipeline\n */\nexport class SpeedyPipelinePortSpec\n{\n    /**\n     * Constructor\n     * @param {SpeedyPipelineMessageType} expectedMessageType expected message type\n     * @param {SpeedyPipelineMessageConstraint} [messageConstraint] message validation function\n     */\n    constructor(expectedMessageType, messageConstraint = none)\n    {\n        /** @type {SpeedyPipelineMessageType} expected message type */\n        this._expectedMessageType = expectedMessageType;\n\n        /** @type {SpeedyPipelineMessageConstraint} message validation function */\n        this._isValidMessage = (typeof messageConstraint === 'function') ? messageConstraint : none;\n\n\n        // expect a valid type\n        Utils.assert(this._expectedMessageType != SpeedyPipelineMessageType.Nothing);\n    }\n\n    /**\n     * Checks if two specs have the same expected type\n     * @param {SpeedyPipelinePortSpec} spec\n     * @returns {boolean}\n     */\n    isCompatibleWith(spec)\n    {\n        return this._expectedMessageType == spec._expectedMessageType;\n    }\n\n    /**\n     * Is the given message accepted by a port that abides by this specification?\n     * @param {SpeedyPipelineMessage} message\n     * @returns {boolean}\n     */\n    accepts(message)\n    {\n        return message.hasType(this._expectedMessageType) && this._isValidMessage(message);\n    }\n\n    /**\n     * Convert to string\n     * @returns {string}\n     */\n    toString()\n    {\n        const type = Object.keys(SpeedyPipelineMessageType).find(\n            type => SpeedyPipelineMessageType[type] === this._expectedMessageType\n        );\n\n        return `Port expects ${type} satisfying ${this._isValidMessage}`;\n    }\n\n    /**\n     * Expected message type\n     * @returns {SpeedyPipelineMessageType}\n     */\n    get expectedMessageType()\n    {\n        return this._expectedMessageType;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * pipeline.js\n * A pipeline is a network of nodes in which data flows to a sink\n */\n\nimport { Utils } from '../../utils/utils';\nimport { SpeedyPromise } from '../../utils/speedy-promise';\nimport { IllegalOperationError, IllegalArgumentError, NotSupportedError } from '../../utils/errors';\nimport { SpeedyPipelineNode, SpeedyPipelineSourceNode, SpeedyPipelineSinkNode } from './pipeline-node';\nimport { SpeedyPipelinePort, SpeedyPipelineInputPort, SpeedyPipelineOutputPort } from './pipeline-port';\nimport { SpeedyGPU } from '../../gpu/speedy-gpu';\nimport { SpeedyMedia } from '../speedy-media';\nimport { SpeedyKeypoint } from '../speedy-keypoint';\n\n/**\n * A dictionary indexed by the names of the sink nodes\n * @typedef {Object<string,any>} SpeedyPipelineOutput\n */\n\n/**\n * A pipeline is a network of nodes in which data flows to a sink\n */\nexport class SpeedyPipeline\n{\n    /**\n     * Constructor\n     */\n    constructor()\n    {\n        /** @type {SpeedyPipelineNode[]} the collection of all nodes that belong to this pipeline */\n        this._nodes = [];\n\n        /** @type {SpeedyPipelineNode[]} a sequence of nodes: from the source(s) to the sink */\n        this._sequence = [];\n\n        /** @type {SpeedyGPU} GPU instance */\n        this._gpu = null;\n\n        /** @type {boolean} are we running the pipeline at this moment? */\n        this._busy = false;\n    }\n\n    /**\n     * Find a node by its name\n     * @template T extends SpeedyPipelineNode\n     * @param {string} name\n     * @returns {T|null}\n     */\n    node(name)\n    {\n        for(let i = 0, n = this._nodes.length; i < n; i++) {\n            if(this._nodes[i].name === name)\n                return this._nodes[i];\n        }\n\n        return null;\n    }\n\n    /**\n     * Initialize the pipeline\n     * @param  {...SpeedyPipelineNode} nodes\n     * @returns {SpeedyPipeline} this pipeline\n     */\n    init(...nodes)\n    {\n        // validate\n        if(this._nodes.length > 0)\n            throw new IllegalOperationError(`The pipeline has already been initialized`);\n        else if(nodes.length == 0)\n            throw new IllegalArgumentError(`Can't initialize the pipeline. Please specify its nodes`);\n\n        // create a GPU instance\n        this._gpu = new SpeedyGPU();\n\n        // add nodes to the network\n        for(let i = 0; i < nodes.length; i++) {\n            const node = nodes[i];\n            if(!this._nodes.includes(node))\n                this._nodes.push(node);\n        }\n\n        // generate the sequence of nodes\n        this._sequence = SpeedyPipeline._tsort(this._nodes);\n        SpeedyPipeline._validateSequence(this._sequence);\n\n        // initialize nodes\n        for(let i = 0; i < this._sequence.length; i++)\n            this._sequence[i].init(this._gpu);\n\n        // done!\n        return this;\n    }\n\n    /**\n     * Release the resources associated with this pipeline\n     * @returns {null}\n     */\n    release()\n    {\n        if(this._nodes.length == 0)\n            throw new IllegalOperationError(`The pipeline has already been released or has never been initialized`);\n\n        // release nodes\n        for(let i = this._sequence.length - 1; i >= 0; i--)\n            this._sequence[i].release(this._gpu);\n        this._sequence.length = 0;\n        this._nodes.length = 0;\n\n        // release GPU\n        this._gpu = this._gpu.release();\n\n        // done!\n        return null;\n    }\n\n    /**\n     * Run the pipeline\n     * @returns {SpeedyPromise<SpeedyPipelineOutput>} results are indexed by the names of the sink nodes\n     */\n    run()\n    {\n        Utils.assert(this._gpu != null, `The pipeline has not been initialized or has been released`);\n\n        // is the pipeline busy?\n        if(this._busy) {\n            // if so, we need to wait 'til it finishes\n            return new SpeedyPromise((resolve, reject) => {\n                setTimeout(() => this.run().then(resolve, reject), 0);\n            });\n        }\n        else {\n            // the pipeline is now busy and won't accept concurrent tasks\n            // (we allocate textures using a single pool)\n            this._busy = true;\n        }\n\n        // find the sinks\n        const sinks = /** @type {SpeedyPipelineSinkNode[]} */ ( this._sequence.filter(node => node.isSink()) );\n\n        // create output template\n        const template = SpeedyPipeline._createOutputTemplate(sinks);\n\n        // run the pipeline\n        return SpeedyPipeline._runSequence(this._sequence, this._gpu).then(() =>\n\n            // export results\n            SpeedyPromise.all(sinks.map(sink => sink.export().turbocharge())).then(results =>\n\n                // aggregate results by the names of the sinks\n                results.reduce((obj, val, idx) => ((obj[sinks[idx].name] = val), obj), template)\n\n            )\n\n        ).finally(() => {\n\n            // clear all ports\n            for(let i = this._sequence.length - 1; i >= 0; i--)\n                this._sequence[i].clearPorts();\n\n            // the pipeline is no longer busy\n            this._busy = false;\n\n        }).turbocharge();\n    }\n\n    /**\n     * Execute the tasks of a sequence of nodes\n     * @param {SpeedyPipelineNode[]} sequence sequence of nodes\n     * @param {SpeedyGPU} gpu GPU instance\n     * @param {number} [i] in [0,n)\n     * @param {number} [n] number of nodes\n     * @returns {SpeedyPromise<void>}\n     */\n    static _runSequence(sequence, gpu, i = 0, n = sequence.length)\n    {\n        for(; i < n; i++) {\n            const runTask = sequence[i].execute(gpu);\n\n            // this call greatly improves performance when downloading pixel data using PBOs\n            gpu.gl.flush();\n\n            if(typeof runTask !== 'undefined')\n                return runTask.then(() => SpeedyPipeline._runSequence(sequence, gpu, i+1, n));\n        }\n\n        return SpeedyPromise.resolve();\n    }\n\n    /**\n     * Topological sorting\n     * @param {SpeedyPipelineNode[]} nodes \n     * @returns {SpeedyPipelineNode[]}\n     */\n    static _tsort(nodes)\n    {\n        /** @typedef {[SpeedyPipelineNode, boolean]} StackNode */\n\n        const outlinks = SpeedyPipeline._outlinks(nodes);\n        const stack = nodes.map(node => /** @type {StackNode} */ ([ node, false ]) );\n        const trash = new Set();\n        const sorted = new Array(nodes.length);\n        let j = sorted.length;\n\n        while(stack.length > 0) {\n            const [ node, done ] = stack.pop();\n            if(!done) {\n                if(!trash.has(node)) {\n                    const outnodes = outlinks.get(node);\n\n                    trash.add(node);\n                    stack.push([ node, true ]);\n                    stack.push(...(outnodes.map(node => /** @type {StackNode} */ ([ node, false ]) )));\n\n                    if(outnodes.some(node => trash.has(node) && !sorted.includes(node)))\n                        throw new IllegalOperationError(`Pipeline networks cannot have cycles!`);\n                }\n            }\n            else\n                sorted[--j] = node;\n        }\n\n        return sorted;\n    }\n\n    /**\n     * Figure out the outgoing links of all nodes\n     * @param {SpeedyPipelineNode[]} nodes\n     * @returns {Map<SpeedyPipelineNode,SpeedyPipelineNode[]>}\n     */\n    static _outlinks(nodes)\n    {\n        const outlinks = new Map();\n\n        for(let k = 0; k < nodes.length; k++)\n            outlinks.set(nodes[k], []);\n\n        for(let i = 0; i < nodes.length; i++) {\n            const to = nodes[i];\n            const inputs = to.inputNodes();\n\n            for(let j = 0; j < inputs.length; j++) {\n                const from = inputs[j];\n                const links = outlinks.get(from);\n\n                if(!links)\n                    throw new IllegalOperationError(`Can't initialize the pipeline. Missing node: ${from.fullName}. Did you forget to add it to the initialization list?`);\n\n                if(!links.includes(to))\n                    links.push(to);\n            }\n        }\n\n        return outlinks;\n    }\n\n    /**\n     * Generate the output template by aggregating the names of the sinks\n     * @param {SpeedyPipelineNode[]} [sinks]\n     * @returns {SpeedyPipelineOutput}\n     */\n    static _createOutputTemplate(sinks = [])\n    {\n        const template = Object.create(null);\n\n        for(let i = sinks.length - 1; i >= 0; i--)\n            template[sinks[i].name] = null;\n\n        return template;\n    }\n\n    /**\n     * Validate a sequence of nodes\n     * @param {SpeedyPipelineNode[]} sequence\n     */\n    static _validateSequence(sequence)\n    {\n        if(sequence.length == 0)\n            throw new IllegalOperationError(`Pipeline doesn't have nodes`);\n        else if(!sequence[0].isSource())\n            throw new IllegalOperationError(`Pipeline doesn't have a source`);\n        else if(!sequence.find(node => node.isSink()))\n            throw new IllegalOperationError(`Pipeline doesn't have a sink`);\n    }\n}\n","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-keypoint-descriptor.js\n * Keypoint descriptor\n */\n\n/**\n * Represents a keypoint descriptor\n */\nexport class SpeedyKeypointDescriptor\n{\n    /**\n     * Constructor\n     * @param {Uint8Array} data descriptor bytes\n     */\n    constructor(data)\n    {\n        this._data = data;\n        return Object.freeze(this);\n    }\n\n    /**\n     * Descriptor data\n     * @returns {Uint8Array}\n     */\n    get data()\n    {\n        return this._data;\n    }\n\n    /**\n     * The size of the descriptor, in bytes\n     * @returns {number}\n     */\n    get size()\n    {\n        return this._data.byteLength;\n    }\n\n    /**\n     * A string representation of the keypoint descriptor\n     * @returns {string}\n     */\n    toString()\n    {\n        return `SpeedyKeypointDescriptor(${this._data.join(',')})`;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-match.js\n * A match between two keypoint descriptors\n */\n\nimport { MATCH_MAX_DISTANCE } from '../utils/globals';\n\n// Constants\nconst MATCH_NOT_FOUND = -1;\n\n/**\n * A match between two keypoint descriptors\n */\nexport class SpeedyKeypointMatch\n{\n    /**\n     * Constructor\n     * @param {number} index index of the stored keypoint, a non-negative integer\n     * @param {number} distance a measure of the quality of the match, a non-negative number\n     */\n    constructor(index, distance)\n    {\n        const isValid = distance < MATCH_MAX_DISTANCE;\n\n        /** @type {number} index of the stored keypoint */\n        this._index = isValid ? (index | 0) : MATCH_NOT_FOUND;\n\n        /** @type {number} a measure of the quality of the match */\n        this._distance = isValid ? +distance : Number.POSITIVE_INFINITY;\n\n        // done!\n        return Object.freeze(this);\n    }\n\n    /**\n     * The index of the stored keypoint\n     * @returns {number}\n     */\n    get index()\n    {\n        return this._index;\n    }\n\n    /**\n     * A measure of the quality of the match (lower values indicate better matches)\n     * @returns {number}\n     */\n    get distance()\n    {\n        return this._distance;\n    }\n\n    /**\n     * A string representation of the keypoint match\n     * @returns {string}\n     */\n    toString()\n    {\n        return `SpeedyKeypointMatch(${this.index},${this.distance})`;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-keypoint.js\n * Keypoint class\n */\n\nimport { SpeedyKeypointDescriptor } from './speedy-keypoint-descriptor';\nimport { SpeedyKeypointMatch } from './speedy-keypoint-match';\nimport { SpeedyPoint2 } from './speedy-point';\nimport { SpeedyVector2 } from './speedy-vector';\n\n/**\n * Represents a keypoint\n */\nexport class SpeedyKeypoint\n{\n    /**\n     * Constructor\n     * @param {number} x X position\n     * @param {number} y Y position\n     * @param {number} [lod] Level-of-detail\n     * @param {number} [rotation] Rotation in radians\n     * @param {number} [score] Cornerness measure\n     * @param {SpeedyKeypointDescriptor|null} [descriptor] Keypoint descriptor, if any\n     */\n    constructor(x, y, lod = 0.0, rotation = 0.0, score = 0.0, descriptor = null)\n    {\n        /** @type {SpeedyPoint2} keypoint position */\n        this._position = new SpeedyPoint2(+x, +y);\n\n        /** @type {number} level of detail */\n        this._lod = +lod;\n\n        /** @type {number} rotation in radians */\n        this._rotation = +rotation;\n\n        /** @type {number} a cornerness measure */\n        this._score = +score;\n\n        /** @type {SpeedyKeypointDescriptor|null} keypoint descriptor, if any */\n        this._descriptor = descriptor;\n    }\n\n    /**\n     * Converts this keypoint to a descriptive string\n     * @returns {string}\n     */\n    toString()\n    {\n        return `SpeedyKeypoint(${this.x},${this.y})`;\n    }\n\n    /**\n     * The position of this keypoint\n     * @returns {SpeedyPoint2}\n     */\n    get position()\n    {\n        return this._position;\n    }\n\n    /**\n     * The x-position of this keypoint\n     * @returns {number}\n     */\n    get x()\n    {\n        return this._position.x;\n    }\n\n    /**\n     * The x-position of this keypoint\n     * @param {number} value\n     */\n    set x(value)\n    {\n        this._position.x = +value;\n    }\n\n    /**\n     * The y-position of this keypoint\n     * @returns {number}\n     */\n    get y()\n    {\n        return this._position.y;\n    }\n\n    /**\n     * The y-position of this keypoint\n     * @param {number} value\n     */\n    set y(value)\n    {\n        this._position.y = +value;\n    }\n\n    /**\n     * The pyramid level-of-detail from which this keypoint was extracted\n     * @returns {number}\n     */\n    get lod()\n    {\n        return this._lod;\n    }\n\n    /**\n     * Scale: 2^lod\n     * @returns {number}\n     */\n    get scale()\n    {\n        return Math.pow(2, this._lod);\n    }\n\n    /**\n     * The orientation of the keypoint, in radians\n     * @returns {number} Angle in radians\n     */\n    get rotation()\n    {\n        return this._rotation;\n    }\n\n    /**\n     * Score: a cornerness measure\n     * @returns {number} Score\n     */\n    get score()\n    {\n        return this._score;\n    }\n\n    /**\n     * Keypoint descriptor\n     * @return {SpeedyKeypointDescriptor|null}\n     */\n    get descriptor()\n    {\n        return this._descriptor;\n    }\n}\n\n/**\n * Represents a tracked keypoint\n */\nexport class SpeedyTrackedKeypoint extends SpeedyKeypoint\n{\n    /**\n     * Constructor\n     * @param {number} x X position\n     * @param {number} y Y position\n     * @param {number} [lod] Level-of-detail\n     * @param {number} [rotation] Rotation in radians\n     * @param {number} [score] Cornerness measure\n     * @param {SpeedyKeypointDescriptor|null} [descriptor] Keypoint descriptor, if any\n     * @param {SpeedyVector2} [flow] flow vector\n     */\n    constructor(x, y, lod = 0.0, rotation = 0.0, score = 0.0, descriptor = null, flow = new SpeedyVector2(0,0))\n    {\n        super(x, y, lod, rotation, score, descriptor);\n\n        /** @type {SpeedyVector2} flow vector */\n        this._flow = flow;\n    }\n\n    /**\n     * Flow vector\n     * @returns {SpeedyVector2}\n     */\n    get flow()\n    {\n        return this._flow;\n    }\n}\n\n/**\n * Represents a matched keypoint\n */\nexport class SpeedyMatchedKeypoint extends SpeedyKeypoint\n{\n    /**\n     * Constructor\n     * @param {number} x X position\n     * @param {number} y Y position\n     * @param {number} [lod] Level-of-detail\n     * @param {number} [rotation] Rotation in radians\n     * @param {number} [score] Cornerness measure\n     * @param {SpeedyKeypointDescriptor|null} [descriptor] Keypoint descriptor, if any\n     * @param {SpeedyKeypointMatch[]} [matches] Keypoint matches, if any\n     */\n    constructor(x, y, lod = 0.0, rotation = 0.0, score = 0.0, descriptor = null, matches = [])\n    {\n        super(x, y, lod, rotation, score, descriptor);\n\n        /** @type {SpeedyKeypointMatch[]} keypoint matches */\n        this._matches = matches;\n    }\n\n    /**\n     * Keypoint matches\n     * @returns {SpeedyKeypointMatch[]}\n     */\n    get matches()\n    {\n        return this._matches;\n    }\n}\n","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-matrix-expr.js\n * Symbolic matrix expressions\n */\n\nimport { SpeedyMatrixWASM } from './speedy-matrix-wasm';\nimport { Utils } from '../utils/utils';\nimport { AbstractMethodError } from '../utils/errors';\n\n/** @typedef {import('./speedy-matrix').SpeedyMatrixDtype} SpeedyMatrixDtype */\n/** @typedef {import('./speedy-matrix').SpeedyMatrixBufferType} SpeedyMatrixBufferType */\n/** @typedef {import('./speedy-matrix').SpeedyMatrixBufferTypeConstructor} SpeedyMatrixBufferTypeConstructor */\n/** @typedef {import('./speedy-matrix-wasm').SpeedyMatrixWASMMemory} SpeedyMatrixWASMMemory */\n\n/** @typedef {Object<SpeedyMatrixDtype,SpeedyMatrixBufferTypeConstructor>} Dtype2BufferType */\n\n/** @const {Dtype2BufferType} */\nconst DTYPE_TO_BUFFER_TYPE = Object.freeze({\n    'float32': Float32Array\n});\n\n\n/**\n * @abstract Matrix expression\n * It's an opaque object representing an algebraic\n * expression. It has no data attached to it.\n */\nexport class SpeedyMatrixExpr\n{\n    /**\n     * Constructor\n     * @param {number} rows\n     * @param {number} columns\n     * @param {SpeedyMatrixDtype} dtype\n     */\n    constructor(rows, columns, dtype)\n    {\n        Utils.assert(rows > 0 && columns > 0);\n        Utils.assert(dtype === SpeedyMatrixExpr.DEFAULT_DTYPE); // we only support float32 for now\n\n        /** @type {number} number of rows */\n        this._rows = rows | 0;\n\n        /** @type {number} number of columns */\n        this._columns = columns | 0;\n\n        /** @type {SpeedyMatrixDtype} data type */\n        this._dtype = dtype;\n    }\n\n    /**\n     * Number of rows\n     * @returns {number}\n     */\n    get rows()\n    {\n        return this._rows;\n    }\n\n    /**\n     * Number of columns\n     * @returns {number}\n     */\n    get columns()\n    {\n        return this._columns;\n    }\n\n    /**\n     * Data type\n     * @returns {SpeedyMatrixDtype}\n     */\n    get dtype()\n    {\n        return this._dtype;\n    }\n\n    /**\n     * Default data type\n     * @returns {SpeedyMatrixDtype}\n     */\n    static get DEFAULT_DTYPE()\n    {\n        return 'float32';\n    }\n\n    /**\n     * Buffer types\n     * @returns {Dtype2BufferType}\n     */\n    static get BUFFER_TYPE()\n    {\n        return DTYPE_TO_BUFFER_TYPE;\n    }\n\n    /**\n     * Matrix addition\n     * @param {SpeedyMatrixExpr} expr\n     * @returns {SpeedyMatrixExpr}\n     */\n    plus(expr)\n    {\n        return new SpeedyMatrixAddExpr(this, expr);\n    }\n\n    /**\n     * Matrix subtraction\n     * @param {SpeedyMatrixExpr} expr\n     * @returns {SpeedyMatrixExpr}\n     */\n    minus(expr)\n    {\n        return new SpeedyMatrixSubtractExpr(this, expr);\n    }\n\n    /**\n     * Matrix multiplication\n     * @param {SpeedyMatrixExpr|number} expr\n     * @returns {SpeedyMatrixExpr}\n     */\n    times(expr)\n    {\n        if(typeof expr === 'number')\n            return new SpeedyMatrixScaleExpr(this, expr);\n        else\n            return new SpeedyMatrixMultiplyExpr(this, expr);\n    }\n\n    /**\n     * Matrix transposition\n     * @returns {SpeedyMatrixExpr}\n     */\n    transpose()\n    {\n        return new SpeedyMatrixTransposeExpr(this);\n    }\n\n    /**\n     * Matrix inversion\n     * @returns {SpeedyMatrixExpr}\n     */\n    inverse()\n    {\n        return new SpeedyMatrixInvertExpr(this);\n    }\n\n    /**\n     * Component-wise multiplication\n     * @param {SpeedyMatrixExpr} expr\n     * @returns {SpeedyMatrixExpr}\n     */\n    compMult(expr)\n    {\n        return new SpeedyMatrixCompMultExpr(this, expr);\n    }\n\n    /**\n     * Returns a human-readable string representation of the matrix expression\n     * @returns {string}\n     */\n    toString()\n    {\n        return `SpeedyMatrixExpr(rows=${this.rows}, columns=${this.columns})`;\n    }\n\n    /**\n     * Evaluate this expression\n     * @abstract\n     * @param {WebAssembly.Instance} wasm\n     * @param {SpeedyMatrixWASMMemory} memory\n     * @returns {SpeedyMatrix}\n     */\n    _evaluate(wasm, memory)\n    {\n        throw new AbstractMethodError();\n    }\n}\n\nconst { SpeedyMatrix } = require('./speedy-matrix');\n\n/**\n * @abstract operation storing a temporary matrix\n */\nclass SpeedyMatrixTempExpr extends SpeedyMatrixExpr\n{\n    /**\n     * Constructor\n     * @param {number} rows\n     * @param {number} columns\n     * @param {SpeedyMatrixDtype} dtype\n     */\n    constructor(rows, columns, dtype)\n    {\n        super(rows, columns, dtype);\n\n        /** @type {SpeedyMatrix} holds the results of a computation */\n        this._tempMatrix = SpeedyMatrix.Zeros(this.rows, this.columns, this.dtype);\n    }\n}\n\n/**\n * @abstract unary operation\n */\nclass SpeedyMatrixUnaryOperationExpr extends SpeedyMatrixTempExpr\n{\n    /**\n     * Constructor\n     * @param {number} rows rows of the output matrix\n     * @param {number} columns columns of the output matrix\n     * @param {SpeedyMatrixExpr} operand\n     */\n    constructor(rows, columns, operand)\n    {\n        super(rows, columns, operand.dtype);\n\n        /** @type {SpeedyMatrixExpr} operand */\n        this._operand = operand;\n    }\n\n    /**\n     * Evaluate this expression\n     * @param {WebAssembly.Instance} wasm\n     * @param {SpeedyMatrixWASMMemory} memory\n     * @returns {SpeedyMatrix}\n     */\n    _evaluate(wasm, memory)\n    {\n        const operand = this._operand._evaluate(wasm, memory);\n        const result = this._tempMatrix;\n\n        // allocate matrices\n        const resultptr = SpeedyMatrixWASM.allocateMat32(wasm, memory, result);\n        const operandptr = SpeedyMatrixWASM.allocateMat32(wasm, memory, operand);\n\n        // copy operand to WASM memory\n        SpeedyMatrixWASM.copyToMat32(wasm, memory, operandptr, operand);\n\n        // run the WASM routine\n        this._compute(wasm, memory, resultptr, operandptr);\n\n        // copy result from WASM memory\n        SpeedyMatrixWASM.copyFromMat32(wasm, memory, resultptr, result);\n\n        // deallocate matrices\n        SpeedyMatrixWASM.deallocateMat32(wasm, memory, operandptr);\n        SpeedyMatrixWASM.deallocateMat32(wasm, memory, resultptr);\n\n        // done!\n        return result;\n    }\n\n    /**\n     * Compute the result of this operation\n     * @abstract\n     * @param {WebAssembly.Instance} wasm\n     * @param {SpeedyMatrixWASMMemory} memory\n     * @param {number} resultptr pointer to Mat32\n     * @param {number} operandptr pointer to Mat32\n     */\n    _compute(wasm, memory, resultptr, operandptr)\n    {\n        throw new AbstractMethodError();\n    }\n}\n\n/**\n * @abstract binary operation\n */\nclass SpeedyMatrixBinaryOperationExpr extends SpeedyMatrixTempExpr\n{\n    /**\n     * Constructor\n     * @param {number} rows rows of the output matrix\n     * @param {number} columns columns of the output matrix\n     * @param {SpeedyMatrixExpr} left left operand\n     * @param {SpeedyMatrixExpr} right right operand\n     */\n    constructor(rows, columns, left, right)\n    {\n        Utils.assert(left.dtype === right.dtype);\n        super(rows, columns, left.dtype);\n\n        /** @type {SpeedyMatrixExpr} left operand */\n        this._left = left;\n\n        /** @type {SpeedyMatrixExpr} right operand */\n        this._right = right;\n    }\n\n    /**\n     * Evaluate this expression\n     * @param {WebAssembly.Instance} wasm\n     * @param {SpeedyMatrixWASMMemory} memory\n     * @returns {SpeedyMatrix}\n     */\n    _evaluate(wasm, memory)\n    {\n        const left = this._left._evaluate(wasm, memory);\n        const right = this._right._evaluate(wasm, memory);\n        const result = this._tempMatrix;\n\n        // allocate matrices\n        const resultptr = SpeedyMatrixWASM.allocateMat32(wasm, memory, result);\n        const leftptr = SpeedyMatrixWASM.allocateMat32(wasm, memory, left);\n        const rightptr = SpeedyMatrixWASM.allocateMat32(wasm, memory, right);\n\n        // copy input matrices to WASM memory\n        SpeedyMatrixWASM.copyToMat32(wasm, memory, leftptr, left);\n        SpeedyMatrixWASM.copyToMat32(wasm, memory, rightptr, right);\n\n        // run the WASM routine\n        this._compute(wasm, memory, resultptr, leftptr, rightptr);\n\n        // copy output matrix from WASM memory\n        SpeedyMatrixWASM.copyFromMat32(wasm, memory, resultptr, result);\n\n        // deallocate matrices\n        SpeedyMatrixWASM.deallocateMat32(wasm, memory, rightptr);\n        SpeedyMatrixWASM.deallocateMat32(wasm, memory, leftptr);\n        SpeedyMatrixWASM.deallocateMat32(wasm, memory, resultptr);\n\n        // done!\n        return result;\n    }\n\n    /**\n     * Compute the result of this operation\n     * @abstract\n     * @param {WebAssembly.Instance} wasm\n     * @param {SpeedyMatrixWASMMemory} memory\n     * @param {number} resultptr pointer to Mat32\n     * @param {number} leftptr pointer to Mat32\n     * @param {number} rightptr pointer to Mat32\n     */\n    _compute(wasm, memory, resultptr, leftptr, rightptr)\n    {\n        throw new AbstractMethodError();\n    }\n}\n\n/**\n * Transpose matrix\n */\nclass SpeedyMatrixTransposeExpr extends SpeedyMatrixUnaryOperationExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixExpr} operand\n     */\n    constructor(operand)\n    {\n        super(operand.columns, operand.rows, operand);\n    }\n\n    /**\n     * Compute result = operand^T\n     * @param {WebAssembly.Instance} wasm\n     * @param {SpeedyMatrixWASMMemory} memory\n     * @param {number} resultptr pointer to Mat32\n     * @param {number} operandptr pointer to Mat32\n     */\n    _compute(wasm, memory, resultptr, operandptr)\n    {\n        wasm.exports.Mat32_transpose(resultptr, operandptr);\n    }\n}\n\n/**\n * Invert square matrix\n */\nclass SpeedyMatrixInvertExpr extends SpeedyMatrixUnaryOperationExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixExpr} operand\n     */\n    constructor(operand)\n    {\n        Utils.assert(operand.rows === operand.columns);\n        super(operand.rows, operand.columns, operand);\n\n        /** @type {number} size of the matrix */\n        this._size = operand.rows;\n    }\n\n    /**\n     * Compute result = operand ^ (-1)\n     * @param {WebAssembly.Instance} wasm\n     * @param {SpeedyMatrixWASMMemory} memory\n     * @param {number} resultptr pointer to Mat32\n     * @param {number} operandptr pointer to Mat32\n     */\n    _compute(wasm, memory, resultptr, operandptr)\n    {\n        switch(this._size) {\n            case 0: break;\n            case 1:\n                wasm.exports.Mat32_inverse1(resultptr, operandptr);\n                break;\n\n            case 2:\n                wasm.exports.Mat32_inverse2(resultptr, operandptr);\n                break;\n\n            case 3:\n                wasm.exports.Mat32_inverse3(resultptr, operandptr);\n                break;\n\n            default:\n                wasm.exports.Mat32_qr_inverse(resultptr, operandptr);\n                break;\n        }\n    }\n}\n\n/**\n * Multiply matrix by a scalar value\n */\nclass SpeedyMatrixScaleExpr extends SpeedyMatrixUnaryOperationExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixExpr} operand\n     * @param {number} scalar\n     */\n    constructor(operand, scalar)\n    {\n        super(operand.rows, operand.columns, operand);\n\n        /** @type {number} scalar value */\n        this._scalar = +scalar;\n    }\n\n    /**\n     * Compute result = scalar * operand\n     * @param {WebAssembly.Instance} wasm\n     * @param {SpeedyMatrixWASMMemory} memory\n     * @param {number} resultptr pointer to Mat32\n     * @param {number} operandptr pointer to Mat32\n     */\n    _compute(wasm, memory, resultptr, operandptr)\n    {\n        wasm.exports.Mat32_scale(resultptr, operandptr, this._scalar);\n    }\n}\n\n/**\n * Matrix addition\n */\nclass SpeedyMatrixAddExpr extends SpeedyMatrixBinaryOperationExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixExpr} left left operand\n     * @param {SpeedyMatrixExpr} right right operand\n     */\n    constructor(left, right)\n    {\n        Utils.assert(left.rows === right.rows && left.columns === right.columns);\n        super(left.rows, left.columns, left, right);\n    }\n\n    /**\n     * Compute result = left + right\n     * @param {WebAssembly.Instance} wasm\n     * @param {SpeedyMatrixWASMMemory} memory\n     * @param {number} resultptr pointer to Mat32\n     * @param {number} leftptr pointer to Mat32\n     * @param {number} rightptr pointer to Mat32\n     */\n    _compute(wasm, memory, resultptr, leftptr, rightptr)\n    {\n        wasm.exports.Mat32_add(resultptr, leftptr, rightptr);\n    }\n}\n\n/**\n * Matrix subtraction\n */\nclass SpeedyMatrixSubtractExpr extends SpeedyMatrixBinaryOperationExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixExpr} left left operand\n     * @param {SpeedyMatrixExpr} right right operand\n     */\n    constructor(left, right)\n    {\n        Utils.assert(left.rows === right.rows && left.columns === right.columns);\n        super(left.rows, left.columns, left, right);\n    }\n\n    /**\n     * Compute result = left - right\n     * @param {WebAssembly.Instance} wasm\n     * @param {SpeedyMatrixWASMMemory} memory\n     * @param {number} resultptr pointer to Mat32\n     * @param {number} leftptr pointer to Mat32\n     * @param {number} rightptr pointer to Mat32\n     */\n    _compute(wasm, memory, resultptr, leftptr, rightptr)\n    {\n        wasm.exports.Mat32_subtract(resultptr, leftptr, rightptr);\n    }\n}\n\n/**\n * Matrix multiplication\n */\nclass SpeedyMatrixMultiplyExpr extends SpeedyMatrixBinaryOperationExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixExpr} left left operand\n     * @param {SpeedyMatrixExpr} right right operand\n     */\n    constructor(left, right)\n    {\n        Utils.assert(left.columns === right.rows);\n        super(left.rows, right.columns, left, right);\n    }\n\n    /**\n     * Compute result = left * right\n     * @param {WebAssembly.Instance} wasm\n     * @param {SpeedyMatrixWASMMemory} memory\n     * @param {number} resultptr pointer to Mat32\n     * @param {number} leftptr pointer to Mat32\n     * @param {number} rightptr pointer to Mat32\n     */\n    _compute(wasm, memory, resultptr, leftptr, rightptr)\n    {\n        wasm.exports.Mat32_multiply(resultptr, leftptr, rightptr);\n    }\n}\n\n/**\n * Component-wise multiplication\n */\nclass SpeedyMatrixCompMultExpr extends SpeedyMatrixBinaryOperationExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixExpr} left left operand\n     * @param {SpeedyMatrixExpr} right right operand\n     */\n    constructor(left, right)\n    {\n        Utils.assert(left.rows === right.rows && left.columns === right.columns);\n        super(right.rows, right.columns, left, right);\n    }\n\n    /**\n     * Compute result = left <compMult> right\n     * @param {WebAssembly.Instance} wasm\n     * @param {SpeedyMatrixWASMMemory} memory\n     * @param {number} resultptr pointer to Mat32\n     * @param {number} leftptr pointer to Mat32\n     * @param {number} rightptr pointer to Mat32\n     */\n    _compute(wasm, memory, resultptr, leftptr, rightptr)\n    {\n        wasm.exports.Mat32_compmult(resultptr, leftptr, rightptr);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-matrix-factory.js\n * A factory of matrices\n */\n\nimport { SpeedyMatrixExpr } from './speedy-matrix-expr';\nimport { SpeedyMatrixWASM } from './speedy-matrix-wasm';\nimport { SpeedyMatrix } from './speedy-matrix';\nimport { SpeedyPromise } from '../utils/speedy-promise';\nimport { Utils } from '../utils/utils';\nimport { IllegalArgumentError } from '../utils/errors';\n\n/**\n * Matrix routines\n */\nexport class SpeedyMatrixFactory extends Function\n{\n    /**\n     * Constructor\n     */\n    constructor()\n    {\n        // This factory can be invoked as a function\n        super('...args', 'return args.length > 1 ? this._create(...args) : this._from(args[0])');\n        return this.bind(this);\n    }\n\n    /**\n     * @private\n     *\n     * Create a new matrix filled with the specified size and entries\n     * @param {number} rows\n     * @param {number} [columns]\n     * @param {number[]} [entries] in column-major format\n     * @returns {SpeedyMatrix}\n     */\n    _create(rows, columns = rows, entries = [])\n    {\n        return SpeedyMatrix.Create(rows, columns, entries);\n    }\n\n    /**\n     * @private\n     *\n     * Evaluate an expression synchronously and store the result in a new matrix\n     * @param {SpeedyMatrixExpr} expr matrix expression\n     * @returns {SpeedyMatrix}\n     */\n    _from(expr)\n    {\n        return SpeedyMatrix.From(expr);\n    }\n\n    /**\n     * Create a new matrix filled with zeros with the specified size\n     * @param {number} rows\n     * @param {number} [columns]\n     * @returns {SpeedyMatrix}\n     */\n    Zeros(rows, columns = rows)\n    {\n        return SpeedyMatrix.Zeros(rows, columns);\n    }\n\n    /**\n     * Create a new matrix filled with ones with the specified size\n     * @param {number} rows\n     * @param {number} [columns]\n     * @returns {SpeedyMatrix}\n     */\n    Ones(rows, columns = rows)\n    {\n        return SpeedyMatrix.Ones(rows, columns);\n    }\n\n    /**\n     * Create an identity matrix with the specified size\n     * @param {number} rows\n     * @param {number} [columns]\n     * @returns {SpeedyMatrix}\n     */\n    Eye(rows, columns = rows)\n    {\n        return SpeedyMatrix.Eye(rows, columns);\n    }\n\n    /**\n     * Returns a promise that resolves immediately if the WebAssembly routines\n     * are ready to be used, or as soon as they do become ready\n     * @returns {SpeedyPromise<void>}\n     */\n    ready()\n    {\n        return SpeedyMatrix.ready();\n    }\n\n    /**\n     * QR decomposition\n     * @param {SpeedyMatrix} Q is m x n (reduced) or m x m (full), output\n     * @param {SpeedyMatrix} R is n x n (reduced) or m x n (full), output\n     * @param {SpeedyMatrix} mat is m x n, input\n     * @param {object} [options]\n     * @param {'reduced'|'full'} [options.mode]\n     * @returns {SpeedyPromise<[SpeedyMatrix,SpeedyMatrix]>} resolves to [Q,R]\n     */\n    qr(Q, R, mat, { mode = 'reduced' } = {})\n    {\n        const A = mat, m = mat.rows, n = mat.columns;\n\n        // validate shapes & mode\n        if(mode == 'reduced') {\n            if(Q.rows != m || Q.columns != n || R.rows != n || R.columns != n)\n                throw new IllegalArgumentError(`Invalid shape for reduced QR`);\n        }\n        else if(mode == 'full') {\n            if(Q.rows != m || Q.columns != m || R.rows != m || R.columns != n)\n                throw new IllegalArgumentError(`Invalid shape for full QR`);\n        }\n        else\n            throw new IllegalArgumentError(`Invalid mode for QR: \"${mode}\"`);\n\n        return SpeedyMatrixWASM.ready().then(({wasm, memory}) => {\n            // allocate matrices\n            const Qptr = SpeedyMatrixWASM.allocateMat32(wasm, memory, Q);\n            const Rptr = SpeedyMatrixWASM.allocateMat32(wasm, memory, R);\n            const Aptr = SpeedyMatrixWASM.allocateMat32(wasm, memory, A);\n\n            // copy input matrices to WASM memory\n            SpeedyMatrixWASM.copyToMat32(wasm, memory, Aptr, A);\n\n            // run the WASM routine\n            if(mode == 'reduced')\n                wasm.exports.Mat32_qr_reduced(Qptr, Rptr, Aptr);\n            else\n                wasm.exports.Mat32_qr_full(Qptr, Rptr, Aptr);\n\n            // copy output matrices from WASM memory\n            SpeedyMatrixWASM.copyFromMat32(wasm, memory, Qptr, Q);\n            SpeedyMatrixWASM.copyFromMat32(wasm, memory, Rptr, R);\n\n            // deallocate matrices\n            SpeedyMatrixWASM.deallocateMat32(wasm, memory, Aptr);\n            SpeedyMatrixWASM.deallocateMat32(wasm, memory, Rptr);\n            SpeedyMatrixWASM.deallocateMat32(wasm, memory, Qptr);\n\n            // done!\n            return [Q, R];\n        });\n    }\n\n    /**\n     * Solve a possibly overdetermined system of linear\n     * equations Ax = b for x using ordinary least squares\n     * @param {SpeedyMatrix} solution n x 1, output\n     * @param {SpeedyMatrix} A m x n, m >= n, input\n     * @param {SpeedyMatrix} b m x 1, output\n     * @param {object} [options]\n     * @param {'qr'} [options.method] method of resolution\n     * @returns {SpeedyPromise<SpeedyMatrix>} resolves to solution\n     */\n    ols(solution, A, b, { method = 'qr' } = {})\n    {\n        const m = A.rows, n = A.columns;\n        const x = solution;\n\n        // validate shapes\n        if(m < n || n == 0)\n            throw new IllegalArgumentError(`Can't solve an underdetermined system of equations`);\n        else if(b.rows != m || b.columns != 1 || x.rows != n || x.columns != 1)\n            throw new IllegalArgumentError(`Invalid shapes`);\n\n        return SpeedyMatrixWASM.ready().then(({wasm, memory}) => {\n            // allocate matrices\n            const Aptr = SpeedyMatrixWASM.allocateMat32(wasm, memory, A);\n            const bptr = SpeedyMatrixWASM.allocateMat32(wasm, memory, b);\n            const xptr = SpeedyMatrixWASM.allocateMat32(wasm, memory, x);\n\n            // copy input matrices to WASM memory\n            SpeedyMatrixWASM.copyToMat32(wasm, memory, Aptr, A);\n            SpeedyMatrixWASM.copyToMat32(wasm, memory, bptr, b);\n\n            // run the WASM routine\n            switch(method) {\n                case 'qr':\n                    wasm.exports.Mat32_qr_ols(xptr, Aptr, bptr, 2);\n                    break;\n\n                default: \n                    throw new IllegalArgumentError(`Invalid method: \"${method}\"`);\n            }\n\n            // copy output matrix from WASM memory\n            SpeedyMatrixWASM.copyFromMat32(wasm, memory, xptr, x);\n\n            // deallocate matrices\n            SpeedyMatrixWASM.deallocateMat32(wasm, memory, xptr);\n            SpeedyMatrixWASM.deallocateMat32(wasm, memory, bptr);\n            SpeedyMatrixWASM.deallocateMat32(wasm, memory, Aptr);\n\n            // done!\n            return solution;\n        });\n    }\n\n    /**\n     * Solve a system of linear equations Ax = b for x\n     * @param {SpeedyMatrix} solution m x 1, output\n     * @param {SpeedyMatrix} A m x m, input\n     * @param {SpeedyMatrix} b m x 1, output\n     * @param {object} [options]\n     * @param {'qr'} [options.method] method of resolution\n     * @returns {SpeedyPromise<SpeedyMatrix>} resolves to solution\n     */\n    solve(solution, A, b, { method = 'qr' } = {})\n    {\n        const m = A.rows, n = A.columns;\n        const x = solution;\n\n        // validate shapes\n        if(m != n)\n            throw new IllegalArgumentError(`Can't solve an over or underdetermined system of equations`);\n        else if(b.rows != m || b.columns != 1 || x.rows != m || x.columns != 1)\n            throw new IllegalArgumentError(`Invalid shapes`);\n\n        return SpeedyMatrixWASM.ready().then(({wasm, memory}) => {\n            // select method\n            switch(method) {\n                case 'qr':\n                    return this.ols(x, A, b, { method });\n\n                /*case 'lu':\n                    break;*/\n\n                default:\n                    throw new IllegalArgumentError(`Invalid method: \"${method}\"`);\n            }\n        });\n    }\n\n    /**\n     * Compute a perspective transformation using 4 correspondences of points\n     * @param {SpeedyMatrix} homography 3x3 output - homography matrix\n     * @param {SpeedyMatrix} src 2x4 input points - source coordinates\n     * @param {SpeedyMatrix} dest 2x4 input points - destination coordinates\n     * @returns {SpeedyPromise<SpeedyMatrix>} resolves to homography\n     */\n    perspective(homography, src, dest)\n    {\n        // validate shapes\n        if(src.rows != 2 || src.columns != 4 || dest.rows != 2 || dest.columns != 4)\n            throw new IllegalArgumentError(`You need two 2x4 input matrices to compute a perspective transformation`);\n        else if(homography.rows != 3 || homography.columns != 3)\n            throw new IllegalArgumentError(`The output of perspective() is a 3x3 homography`);\n\n        return SpeedyMatrixWASM.ready().then(({wasm, memory}) => {\n            // allocate matrices\n            const homptr = SpeedyMatrixWASM.allocateMat32(wasm, memory, homography);\n            const srcptr = SpeedyMatrixWASM.allocateMat32(wasm, memory, src);\n            const destptr = SpeedyMatrixWASM.allocateMat32(wasm, memory, dest);\n\n            // copy input matrices to WASM memory\n            SpeedyMatrixWASM.copyToMat32(wasm, memory, srcptr, src);\n            SpeedyMatrixWASM.copyToMat32(wasm, memory, destptr, dest);\n\n            // run the WASM routine\n            wasm.exports.Mat32_homography_ndlt4(homptr, srcptr, destptr);\n\n            // copy output matrix from WASM memory\n            SpeedyMatrixWASM.copyFromMat32(wasm, memory, homptr, homography);\n\n            // deallocate matrices\n            SpeedyMatrixWASM.deallocateMat32(wasm, memory, destptr);\n            SpeedyMatrixWASM.deallocateMat32(wasm, memory, srcptr);\n            SpeedyMatrixWASM.deallocateMat32(wasm, memory, homptr);\n\n            // done!\n            return homography;\n        });\n    }\n\n    /**\n     * Compute a perspective transformation using n >= 4 correspondences of points\n     * @param {SpeedyMatrix} homography 3x3 output - homography matrix\n     * @param {SpeedyMatrix} src 2 x n input points - source coordinates\n     * @param {SpeedyMatrix} dest 2 x n input points - destination coordinates\n     * @param {object} [options]\n     * @param {'default'|'pransac'} [options.method] method of computation\n     * @param {SpeedyMatrix|null} [options.mask] (pransac) 1 x n output: i-th entry will be 1 if the i-th input point is an inlier, or 0 otherwise\n     * @param {number} [options.reprojectionError] (pransac) given in pixels, used to separate inliers from outliers of a particular model (e.g., 1 pixel)\n     * @param {number} [options.numberOfHypotheses] (pransac) number of hypotheses to be generated up-front (e.g., 512)\n     * @param {number} [options.bundleSize] (pransac) how many points should we check before reducing the number of viable hypotheses (e.g., 128)\n     * @returns {SpeedyPromise<SpeedyMatrix>} resolves to homography\n     */\n    findHomography(homography, src, dest, {\n        method = 'default',\n        mask = null,\n        reprojectionError = 3,\n        numberOfHypotheses = 512,\n        bundleSize = 128,\n    } = {})\n    {\n        // validate shapes\n        if(src.rows != 2 || src.columns < 4 || dest.rows != 2 || dest.columns != src.columns)\n            throw new IllegalArgumentError(`You need two 2 x n (n >= 4) input matrices to compute a homography`);\n        else if(homography.rows != 3 || homography.columns != 3)\n            throw new IllegalArgumentError(`The output of findHomography() is a 3x3 homography`);\n        else if(mask != null && (mask.rows != 1 || mask.columns != src.columns))\n            throw new IllegalArgumentError(`Invalid shape of the inliers mask`);\n\n        return SpeedyMatrixWASM.ready().then(({wasm, memory}) => {\n            // allocate matrices\n            const homptr = SpeedyMatrixWASM.allocateMat32(wasm, memory, homography);\n            const srcptr = SpeedyMatrixWASM.allocateMat32(wasm, memory, src);\n            const destptr = SpeedyMatrixWASM.allocateMat32(wasm, memory, dest);\n            const maskptr = mask != null ? SpeedyMatrixWASM.allocateMat32(wasm, memory, mask) : 0;\n\n            // copy input matrices to WASM memory\n            SpeedyMatrixWASM.copyToMat32(wasm, memory, srcptr, src);\n            SpeedyMatrixWASM.copyToMat32(wasm, memory, destptr, dest);\n\n            // run the WASM routine\n            switch(method) {\n                case 'pransac':\n                    Utils.assert(reprojectionError >= 0 && numberOfHypotheses > 0 && bundleSize > 0);\n                    wasm.exports.Mat32_pransac_homography(homptr, maskptr, srcptr, destptr, numberOfHypotheses, bundleSize, reprojectionError);\n                    break;\n\n                case 'default':\n                case 'dlt': // obsolete\n                    wasm.exports.Mat32_homography_ndlt(homptr, srcptr, destptr);\n                    break;\n\n                default:\n                    throw new IllegalArgumentError(`Illegal method for findHomography(): \"${method}\"`);\n            }\n\n            // copy output matrices from WASM memory\n            SpeedyMatrixWASM.copyFromMat32(wasm, memory, homptr, homography);\n            if(mask != null)\n                SpeedyMatrixWASM.copyFromMat32(wasm, memory, maskptr, mask);\n\n            // deallocate matrices\n            if(mask != null)\n                SpeedyMatrixWASM.deallocateMat32(wasm, memory, maskptr);\n            SpeedyMatrixWASM.deallocateMat32(wasm, memory, destptr);\n            SpeedyMatrixWASM.deallocateMat32(wasm, memory, srcptr);\n            SpeedyMatrixWASM.deallocateMat32(wasm, memory, homptr);\n\n            // done!\n            return homography;\n        });\n    }\n\n    /**\n     * Apply a perspective transformation to a set of 2D points\n     * @param {SpeedyMatrix} dest 2 x n output matrix\n     * @param {SpeedyMatrix} src 2 x n input matrix (a set of points)\n     * @param {SpeedyMatrix} transform 3x3 homography matrix\n     * @returns {SpeedyPromise<SpeedyMatrix>} resolves to dest\n     */\n    applyPerspectiveTransform(dest, src, transform)\n    {\n        // validate shapes\n        if(src.rows != 2 || dest.rows != 2 || src.columns != dest.columns)\n            throw new IllegalArgumentError(`Invalid shapes`);\n        else if(transform.rows != 3 || transform.columns != 3)\n            throw new IllegalArgumentError(`The perspective transformation must be a 3x3 matrix`);\n\n        return SpeedyMatrixWASM.ready().then(({wasm, memory}) => {\n            // allocate matrices\n            const matptr = SpeedyMatrixWASM.allocateMat32(wasm, memory, transform);\n            const srcptr = SpeedyMatrixWASM.allocateMat32(wasm, memory, src);\n            const destptr = SpeedyMatrixWASM.allocateMat32(wasm, memory, dest);\n\n            // copy input matrices to WASM memory\n            SpeedyMatrixWASM.copyToMat32(wasm, memory, srcptr, src);\n            SpeedyMatrixWASM.copyToMat32(wasm, memory, matptr, transform);\n\n            // run the WASM routine\n            wasm.exports.Mat32_transform_perspective(destptr, srcptr, matptr);\n\n            // copy output matrix from WASM memory\n            SpeedyMatrixWASM.copyFromMat32(wasm, memory, destptr, dest);\n\n            // deallocate matrices\n            SpeedyMatrixWASM.deallocateMat32(wasm, memory, destptr);\n            SpeedyMatrixWASM.deallocateMat32(wasm, memory, srcptr);\n            SpeedyMatrixWASM.deallocateMat32(wasm, memory, matptr);\n\n            // done!\n            return dest;\n        });\n    }\n\n    /**\n     * Compute an affine transform using 3 correspondences of points\n     * @param {SpeedyMatrix} transform 2x3 output - affine transform\n     * @param {SpeedyMatrix} src 2x3 input points - source coordinates\n     * @param {SpeedyMatrix} dest 2x3 input points - destination coordinates\n     * @returns {SpeedyPromise<SpeedyMatrix>} resolves to homography\n     */\n    affine(transform, src, dest)\n    {\n        // validate shapes\n        if(src.rows != 2 || src.columns != 3 || dest.rows != 2 || dest.columns != 3)\n            throw new IllegalArgumentError(`You need two 2x3 input matrices to compute an affine transform`);\n        else if(transform.rows != 2 || transform.columns != 3)\n            throw new IllegalArgumentError(`The output of affine() is a 2x3 matrix`);\n\n        return SpeedyMatrixWASM.ready().then(({wasm, memory}) => {\n            // allocate matrices\n            const matptr = SpeedyMatrixWASM.allocateMat32(wasm, memory, transform);\n            const srcptr = SpeedyMatrixWASM.allocateMat32(wasm, memory, src);\n            const destptr = SpeedyMatrixWASM.allocateMat32(wasm, memory, dest);\n\n            // copy input matrices to WASM memory\n            SpeedyMatrixWASM.copyToMat32(wasm, memory, srcptr, src);\n            SpeedyMatrixWASM.copyToMat32(wasm, memory, destptr, dest);\n\n            // run the WASM routine\n            wasm.exports.Mat32_affine_direct3(matptr, srcptr, destptr);\n\n            // copy output matrix from WASM memory\n            SpeedyMatrixWASM.copyFromMat32(wasm, memory, matptr, transform);\n\n            // deallocate matrices\n            SpeedyMatrixWASM.deallocateMat32(wasm, memory, destptr);\n            SpeedyMatrixWASM.deallocateMat32(wasm, memory, srcptr);\n            SpeedyMatrixWASM.deallocateMat32(wasm, memory, matptr);\n\n            // done!\n            return transform;\n        });\n    }\n\n    /**\n     * Compute an affine transformation using n >= 3 correspondences of points\n     * @param {SpeedyMatrix} transform 2x3 output - affine transform\n     * @param {SpeedyMatrix} src 2 x n input points - source coordinates\n     * @param {SpeedyMatrix} dest 2 x n input points - destination coordinates\n     * @param {object} [options]\n     * @param {'default'|'pransac'} [options.method] method of computation\n     * @param {SpeedyMatrix|null} [options.mask] (pransac) 1 x n output: i-th entry will be 1 if the i-th input point is an inlier, or 0 otherwise\n     * @param {number} [options.reprojectionError] (pransac) given in pixels, used to separate inliers from outliers of a particular model (e.g., 1 pixel)\n     * @param {number} [options.numberOfHypotheses] (pransac) number of hypotheses to be generated up-front (e.g., 512)\n     * @param {number} [options.bundleSize] (pransac) how many points should we check before reducing the number of viable hypotheses (e.g., 128)\n     * @returns {SpeedyPromise<SpeedyMatrix>} resolves to an affine transform\n     */\n    findAffineTransform(transform, src, dest, {\n        method = 'default',\n        mask = null,\n        reprojectionError = 3,\n        numberOfHypotheses = 512,\n        bundleSize = 128,\n    } = {})\n    {\n        // validate shapes\n        if(src.rows != 2 || src.columns < 3 || dest.rows != 2 || dest.columns != src.columns)\n            throw new IllegalArgumentError(`You need two 2 x n (n >= 3) input matrices to compute an affine transform`);\n        else if(transform.rows != 2 || transform.columns != 3)\n            throw new IllegalArgumentError(`The output of findAffineTransform() is a 2x3 matrix`);\n        else if(mask != null && (mask.rows != 1 || mask.columns != src.columns))\n            throw new IllegalArgumentError(`Invalid shape of the inliers mask`);\n\n        return SpeedyMatrixWASM.ready().then(({wasm, memory}) => {\n            // allocate matrices\n            const matptr = SpeedyMatrixWASM.allocateMat32(wasm, memory, transform);\n            const srcptr = SpeedyMatrixWASM.allocateMat32(wasm, memory, src);\n            const destptr = SpeedyMatrixWASM.allocateMat32(wasm, memory, dest);\n            const maskptr = mask != null ? SpeedyMatrixWASM.allocateMat32(wasm, memory, mask) : 0;\n\n            // copy input matrices to WASM memory\n            SpeedyMatrixWASM.copyToMat32(wasm, memory, srcptr, src);\n            SpeedyMatrixWASM.copyToMat32(wasm, memory, destptr, dest);\n\n            // run the WASM routine\n            switch(method) {\n                case 'pransac':\n                    Utils.assert(reprojectionError >= 0 && numberOfHypotheses > 0 && bundleSize > 0);\n                    wasm.exports.Mat32_pransac_affine(matptr, maskptr, srcptr, destptr, numberOfHypotheses, bundleSize, reprojectionError);\n                    break;\n\n                case 'default':\n                    wasm.exports.Mat32_affine_direct(matptr, srcptr, destptr);\n                    break;\n\n                default:\n                    throw new IllegalArgumentError(`Illegal method for findAffineTransform(): \"${method}\"`);\n            }\n\n            // copy output matrices from WASM memory\n            SpeedyMatrixWASM.copyFromMat32(wasm, memory, matptr, transform);\n            if(mask != null)\n                SpeedyMatrixWASM.copyFromMat32(wasm, memory, maskptr, mask);\n\n            // deallocate matrices\n            if(mask != null)\n                SpeedyMatrixWASM.deallocateMat32(wasm, memory, maskptr);\n            SpeedyMatrixWASM.deallocateMat32(wasm, memory, destptr);\n            SpeedyMatrixWASM.deallocateMat32(wasm, memory, srcptr);\n            SpeedyMatrixWASM.deallocateMat32(wasm, memory, matptr);\n\n            // done!\n            return transform;\n        });\n    }\n\n    /**\n     * Apply an affine transformation to a set of 2D points\n     * @param {SpeedyMatrix} dest 2 x n output matrix\n     * @param {SpeedyMatrix} src 2 x n input matrix (a set of points)\n     * @param {SpeedyMatrix} transform 2x3 affine transform\n     * @returns {SpeedyPromise<SpeedyMatrix>} resolves to dest\n     */\n    applyAffineTransform(dest, src, transform)\n    {\n        // validate shapes\n        if(src.rows != 2 || dest.rows != 2 || src.columns != dest.columns)\n            throw new IllegalArgumentError(`Invalid shapes`);\n        else if(transform.rows != 2 || transform.columns != 3)\n            throw new IllegalArgumentError(`The affine transformation must be a 2x3 matrix`);\n\n        return SpeedyMatrixWASM.ready().then(({wasm, memory}) => {\n            // allocate matrices\n            const matptr = SpeedyMatrixWASM.allocateMat32(wasm, memory, transform);\n            const srcptr = SpeedyMatrixWASM.allocateMat32(wasm, memory, src);\n            const destptr = SpeedyMatrixWASM.allocateMat32(wasm, memory, dest);\n\n            // copy input matrices to WASM memory\n            SpeedyMatrixWASM.copyToMat32(wasm, memory, srcptr, src);\n            SpeedyMatrixWASM.copyToMat32(wasm, memory, matptr, transform);\n\n            // run the WASM routine\n            wasm.exports.Mat32_transform_affine(destptr, srcptr, matptr);\n\n            // copy output matrix from WASM memory\n            SpeedyMatrixWASM.copyFromMat32(wasm, memory, destptr, dest);\n\n            // deallocate matrices\n            SpeedyMatrixWASM.deallocateMat32(wasm, memory, destptr);\n            SpeedyMatrixWASM.deallocateMat32(wasm, memory, srcptr);\n            SpeedyMatrixWASM.deallocateMat32(wasm, memory, matptr);\n\n            // done!\n            return dest;\n        });\n    }\n}\n","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-matrix-wasm.js\n * WebAssembly bridge\n */\n\nimport { SpeedyPromise } from '../utils/speedy-promise';\nimport { WebAssemblyError, TimeoutError, NotSupportedError } from '../utils/errors';\nimport { Utils } from '../utils/utils';\nimport { LITTLE_ENDIAN } from '../utils/globals';\n\n/** @typedef {import('./speedy-matrix').SpeedyMatrix} SpeedyMatrix */\n\n/**\n * @typedef {object} SpeedyMatrixWASMMemory a union-like helper for accessing a WebAssembly.Memory object\n * @property {object} as\n * @property {WebAssembly.Memory} as.object\n * @property {Uint8Array} as.uint8\n * @property {Int32Array} as.int32\n * @property {Uint32Array} as.uint32\n * @property {Float32Array} as.float32\n * @property {Float64Array} as.float64\n */\n\n/**\n * @typedef {object} SpeedyMatrixWASMHandle\n * @property {WebAssembly.Instance} wasm\n * @property {SpeedyMatrixWASMMemory} memory\n * @property {WebAssembly.Module} module\n */\n\n/** @type {Uint8Array} WebAssembly binary */\nconst WASM_BINARY = require('./wasm/speedy-matrix.wasm.txt');\n\n/** @type {WebAssembly.Instance|null} WebAssembly Instance, to be loaded asynchronously */\nlet _instance = null;\n\n/** @type {WebAssembly.Module|null} WebAssembly Module, to be loaded asynchronously */\nlet _module = null;\n\n/** @type {SpeedyMatrixWASMMemory} Augmented WebAssembly Memory object */\nconst _memory = (mem => ({\n    as: {\n        object: mem,\n        uint8: new Uint8Array(mem.buffer),\n        int32: new Int32Array(mem.buffer),\n        uint32: new Uint32Array(mem.buffer),\n        float32: new Float32Array(mem.buffer),\n        float64: new Float64Array(mem.buffer),\n    },\n}))(new WebAssembly.Memory({\n    initial: 16, // 1 MB\n    maximum: 256\n}));\n\n/**\n * WebAssembly utilities\n */\nexport class SpeedyMatrixWASM\n{\n    /**\n     * Gets you the WASM instance, augmented memory & module\n     * @returns {SpeedyPromise<SpeedyMatrixWASMHandle>}\n     */\n    static ready()\n    {\n        return new SpeedyPromise((resolve, reject) => {\n            SpeedyMatrixWASM._ready(resolve, reject);\n        });\n    }\n\n    /**\n     * Synchronously gets you the WASM instance, augmented memory & module\n     * @returns {SpeedyMatrixWASMHandle}\n     */\n    static get handle()\n    {\n        if(!_instance || !_module)\n            throw new WebAssemblyError(`Can't get WASM handle: routines not yet loaded`);\n\n        return {\n            wasm: _instance,\n            memory: _memory,\n            module: _module,\n        };\n    }\n\n    /**\n     * Gets you the WASM imports bound to a memory object\n     * @param {SpeedyMatrixWASMMemory} memory\n     * @returns {Object<string,Function>}\n     */\n    static imports(memory)\n    {\n        const obj = new SpeedyMatrixWASMImports(memory);\n\n        return Object.getOwnPropertyNames(SpeedyMatrixWASMImports.prototype)\n        .filter(property => typeof obj[property] === 'function' && property !== 'constructor')\n        .reduce(\n            (imports, methodName) => ((imports[methodName] = obj[methodName]), imports),\n            Object.create(null)\n        );\n    }\n\n    /**\n     * Allocate a Mat32 in WebAssembly memory without copying any data\n     * @param {WebAssembly.Instance} wasm\n     * @param {SpeedyMatrixWASMMemory} memory\n     * @param {SpeedyMatrix} matrix\n     * @returns {number} pointer to the new Mat32\n     */\n    static allocateMat32(wasm, memory, matrix)\n    {\n        const dataptr = wasm.exports.malloc(matrix.data.byteLength);\n        const matptr = wasm.exports.Mat32_create(matrix.rows, matrix.columns, matrix.step0, matrix.step1, matrix._data.length, dataptr);\n\n        return matptr;\n    }\n\n    /**\n     * Deallocate a Mat32 in WebAssembly\n     * @param {WebAssembly.Instance} wasm\n     * @param {SpeedyMatrixWASMMemory} memory\n     * @param {number} matptr pointer to the allocated Mat32\n     * @returns {number} NULL\n     */\n    static deallocateMat32(wasm, memory, matptr)\n    {\n        const dataptr = wasm.exports.Mat32_data(matptr);\n\n        wasm.exports.free(matptr);\n        wasm.exports.free(dataptr);\n\n        return 0;\n    }\n\n    /**\n     * Copy the data of a matrix to a WebAssembly Mat32\n     * @param {WebAssembly.Instance} wasm\n     * @param {SpeedyMatrixWASMMemory} memory\n     * @param {number} matptr pointer to a Mat32\n     * @param {SpeedyMatrix} matrix\n     * @returns {number} matptr\n     */\n    static copyToMat32(wasm, memory, matptr, matrix)\n    {\n        // We assume the following:\n        // 1. the host uses little-endian byte ordering (just like WebAssembly)\n        // 2. the allocated pointers are 4-byte aligned (the bump allocator guarantees this)\n        // 3. the data type is float32\n\n        Utils.assert(\n            //matrix.dtype === 'float32' &&\n            matrix.data.byteLength === wasm.exports.Mat32_dataSize(matptr)\n        );\n\n        const dataptr = wasm.exports.Mat32_data(matptr);\n        memory.as.float32.set(matrix.data, dataptr / Float32Array.BYTES_PER_ELEMENT);\n\n        return matptr;\n    }\n\n    /**\n     * Copy the data of a WebAssembly Mat32 to a matrix\n     * @param {WebAssembly.Instance} wasm\n     * @param {SpeedyMatrixWASMMemory} memory\n     * @param {number} matptr pointer to a Mat32\n     * @param {SpeedyMatrix} matrix\n     * @returns {number} matptr\n     */\n    static copyFromMat32(wasm, memory, matptr, matrix)\n    {\n        // We assume the following:\n        // 1. the host uses little-endian byte ordering (just like WebAssembly)\n        // 2. the allocated pointers are 4-byte aligned (the bump allocator guarantees this)\n        // 3. the data type is float32\n\n        Utils.assert(\n            //matrix.dtype === 'float32' &&\n            matrix.data.byteLength === wasm.exports.Mat32_dataSize(matptr)\n        );\n\n        const base = wasm.exports.Mat32_data(matptr) / Float32Array.BYTES_PER_ELEMENT;\n        for(let offset = matrix.data.length - 1; offset >= 0; offset--)\n            matrix.data[offset] = memory.as.float32[base + offset];\n\n        return matptr;\n    }\n\n    /**\n     * Polls the WebAssembly instance until it's ready\n     * @param {function(SpeedyMatrixWASMHandle): void} resolve\n     * @param {function(Error): void} reject\n     * @param {number} [counter]\n     */\n    static _ready(resolve, reject, counter = 1000)\n    {\n        if(_instance !== null && _module !== null)\n            resolve({ wasm: _instance, memory: _memory, module: _module });\n        else if(counter <= 0)\n            reject(new TimeoutError(`Can't load WASM routines`));\n        else\n            setTimeout(SpeedyMatrixWASM._ready, 0, resolve, reject, counter - 1);\n    }\n}\n\n/**\n * Methods called from WASM\n */\nclass SpeedyMatrixWASMImports\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixWASMMemory} memory will be bound to this object\n     */\n    constructor(memory)\n    {\n        // find all methods of this object\n        const methodNames = Object.getOwnPropertyNames(this.constructor.prototype)\n                            .filter(property => typeof this[property] === 'function')\n                            .filter(property => property !== 'constructor');\n\n        // bind all methods to this object\n        methodNames.forEach(methodName => {\n            this[methodName] = this[methodName].bind(this);\n        });\n\n        /** @type {SpeedyMatrixWASMMemory} WASM memory */\n        this.memory = memory;\n\n        /** @type {CStringUtils} utilities related to C strings */\n        this.cstring = new CStringUtils(memory);\n\n        // done!\n        return Object.freeze(this);\n    }\n\n    /**\n     * Prints a message\n     * @param {number} ptr pointer to char\n     */\n    print(ptr)\n    {\n        Utils.log(this.cstring.get(ptr));\n    }\n\n    /**\n     * Throws an error\n     * @param {number} ptr pointer to char\n     */\n    fatal(ptr)\n    {\n        throw new WebAssemblyError(this.cstring.get(ptr));\n    }\n\n    /**\n     * Fills a memory segment with a byte\n     * @param {number} value byte\n     * @param {number} start memory address, inclusive\n     * @param {number} end memory address greater than start, exclusive\n     */\n    bytefill(value, start, end)\n    {\n        this.memory.as.uint8.fill(value, start, end);\n    }\n\n    /**\n     * Copy a memory segment to another segment\n     * @param {number} target memory address, where we'll start writing\n     * @param {number} start memory address, where we'll start copying (inclusive)\n     * @param {number} end memory address, where we'll end the copy (exclusive)\n     */\n    copyWithin(target, start, end)\n    {\n        this.memory.as.uint8.copyWithin(target, start, end);\n    }\n}\n\n/**\n * Utilities related to C strings\n */\nclass CStringUtils\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixWASMMemory} memory\n     */\n    constructor(memory)\n    {\n        /** @type {TextDecoder} */\n        this._decoder = new TextDecoder('utf-8');\n\n        /** @type {SpeedyMatrixWASMMemory} */\n        this._memory = memory;\n    }\n\n    /**\n     * Convert a C string to a JavaScript string\n     * @param {number} ptr pointer to char\n     * @returns {string}\n     */\n    get(ptr)\n    {\n        const byte = this._memory.as.uint8;\n        const size = this._memory.as.uint8.byteLength;\n\n        let p = ptr;\n        while(p < size && 0 !== byte[p])\n            ++p;\n\n        return this._decoder.decode(byte.subarray(ptr, p));\n    }\n}\n\n/**\n * WebAssembly loader\n * @param {SpeedyMatrixWASMMemory} memory\n */\n(function loadWASM(memory) {\n    const base64decode = data => Uint8Array.from(atob(data), v => v.charCodeAt(0));\n\n    // Endianness check\n    if(!LITTLE_ENDIAN)\n        throw new NotSupportedError(`Can't run WebAssembly code: not in a little-endian machine!`);\n\n    // Load the WASM binary\n    SpeedyPromise.resolve(WASM_BINARY)\n    .then(data => base64decode(data))\n    .then(bytes => WebAssembly.instantiate(bytes, {\n        env: {\n            memory: memory.as.object,\n            ...SpeedyMatrixWASM.imports(memory),\n        }\n    }))\n    .then(wasm => {\n        _instance = wasm.instance;\n        _module = wasm.module;\n\n        wasm.instance.exports.srand((Date.now() * 0.001) & 0xffffffff); // srand(time(NULL))\n\n        Utils.log(`The WebAssembly routines have been loaded!`);\n    })\n    .catch(err => {\n        throw new WebAssemblyError(`Can't load the WebAssembly routines: ${err}`, err);\n    });\n})(_memory);\n","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-matrix.js\n * Matrix class\n */\n\nimport { SpeedyMatrixExpr } from './speedy-matrix-expr';\nimport { SpeedyMatrixWASM } from './speedy-matrix-wasm';\nimport { SpeedyPromise } from '../utils/speedy-promise';\nimport { Utils } from '../utils/utils';\n\n/** @typedef {\"float32\"} SpeedyMatrixDtype Matrix data type */\n/** @typedef {Float32Array} SpeedyMatrixBufferType Buffer type */\n/** @typedef {Float32ArrayConstructor} SpeedyMatrixBufferTypeConstructor Buffer class */\n/** @typedef {import('./speedy-matrix-wasm').SpeedyMatrixWASMMemory} SpeedyMatrixWASMMemory */\n/** @typedef {import('./speedy-matrix-wasm').SpeedyMatrixWASMHandle} SpeedyMatrixWASMHandle */\n\n/**\n * Matrix class\n */\nexport class SpeedyMatrix extends SpeedyMatrixExpr\n{\n    /**\n     * @private\n     * \n     * Low-level constructor\n     * @param {number} rows number of rows\n     * @param {number} columns number of columns\n     * @param {number} step0 step size between two consecutive elements (e.g., 1)\n     * @param {number} step1 step size between two consecutive columns (e.g., rows)\n     * @param {SpeedyMatrixBufferType} data entries in column-major format\n     */\n    constructor(rows, columns, step0, step1, data)\n    {\n        super(rows, columns, SpeedyMatrixExpr.DEFAULT_DTYPE);\n\n        Utils.assert(data.constructor === SpeedyMatrixExpr.BUFFER_TYPE[this.dtype]);\n        Utils.assert(step0 > 0 && step1 >= step0);\n        Utils.assert(\n            data.length + rows * columns === 0 || // empty matrix and empty buffer, or\n            data.length === 1 + step0 * (rows - 1) + step1 * (columns - 1) // correctly sized buffer\n        );\n\n        /** @type {number} step size between two consecutive elements */\n        this._step0 = step0 | 0;\n\n        /** @type {number} step size between two consecutive columns */\n        this._step1 = step1 | 0;\n\n        /** @type {SpeedyMatrixBufferType} buffer containing the entries of the matrix in column-major order */\n        this._data = data;\n    }\n\n    /**\n     * Create a new matrix with the specified size and entries\n     * @param {number} rows number of rows\n     * @param {number} columns number of columns\n     * @param {number[]} entries in column-major format\n     * @param {SpeedyMatrixDtype} [dtype] data type\n     * @returns {SpeedyMatrix}\n     */\n    static Create(rows, columns, entries, dtype = SpeedyMatrixExpr.DEFAULT_DTYPE)\n    {\n        Utils.assert(rows * columns > 0, `Can't create a matrix without a shape`);\n        Utils.assert(rows * columns === entries.length, `Can't create matrix: expected ${rows * columns} entries, but found ${entries.length}`);\n        Utils.assert(Object.prototype.hasOwnProperty.call(SpeedyMatrixExpr.BUFFER_TYPE, dtype), `Invalid dtype: \"${dtype}\"`);\n\n        return new SpeedyMatrix(rows, columns, 1, rows, Reflect.construct(SpeedyMatrixExpr.BUFFER_TYPE[dtype], [entries]));\n    }\n\n    /**\n     * Create a new matrix filled with zeros with the specified size\n     * @param {number} rows number of rows\n     * @param {number} [columns] number of columns\n     * @param {SpeedyMatrixDtype} [dtype] data type\n     * @returns {SpeedyMatrix}\n     */\n    static Zeros(rows, columns = rows, dtype = SpeedyMatrixExpr.DEFAULT_DTYPE)\n    {\n        Utils.assert(rows * columns > 0, `Can't create a matrix without a shape`);\n        Utils.assert(Object.prototype.hasOwnProperty.call(SpeedyMatrixExpr.BUFFER_TYPE, dtype), `Invalid dtype: \"${dtype}\"`);\n\n        return new SpeedyMatrix(rows, columns, 1, rows, Reflect.construct(SpeedyMatrixExpr.BUFFER_TYPE[dtype], [rows * columns]));\n    }\n\n    /**\n     * Create a new matrix filled with ones with the specified size\n     * @param {number} rows number of rows\n     * @param {number} [columns] number of columns\n     * @param {SpeedyMatrixDtype} [dtype] data type\n     * @returns {SpeedyMatrix}\n     */\n    static Ones(rows, columns = rows, dtype = SpeedyMatrixExpr.DEFAULT_DTYPE)\n    {\n        Utils.assert(rows * columns > 0, `Can't create a matrix without a shape`);\n        Utils.assert(Object.prototype.hasOwnProperty.call(SpeedyMatrixExpr.BUFFER_TYPE, dtype), `Invalid dtype: \"${dtype}\"`);\n\n        return new SpeedyMatrix(rows, columns, 1, rows, Reflect.construct(SpeedyMatrixExpr.BUFFER_TYPE[dtype], [rows * columns]).fill(1));\n    }\n\n    /**\n     * Create a new identity matrix with the specified size\n     * @param {number} rows number of rows\n     * @param {number} [columns] number of columns\n     * @param {SpeedyMatrixDtype} [dtype] data type\n     * @returns {SpeedyMatrix}\n     */\n    static Eye(rows, columns = rows, dtype = SpeedyMatrixExpr.DEFAULT_DTYPE)\n    {\n        Utils.assert(rows * columns > 0, `Can't create a matrix without a shape`);\n        Utils.assert(Object.prototype.hasOwnProperty.call(SpeedyMatrixExpr.BUFFER_TYPE, dtype), `Invalid dtype: \"${dtype}\"`);\n\n        const data = Reflect.construct(SpeedyMatrixExpr.BUFFER_TYPE[dtype], [rows * columns]);\n        for(let j = Math.min(rows, columns) - 1; j >= 0; j--)\n            data[j * rows + j] = 1;\n\n        return new SpeedyMatrix(rows, columns, 1, rows, data);\n    }\n\n    /**\n     * Evaluate an expression synchronously and store the result in a new matrix\n     * @param {SpeedyMatrixExpr} expr matrix expression\n     * @returns {SpeedyMatrix}\n     */\n    static From(expr)\n    {\n        return SpeedyMatrix.Zeros(expr.rows, expr.columns, expr.dtype).setToSync(expr);\n    }\n\n    /**\n     * Returns a promise that resolves immediately if the WebAssembly routines\n     * are ready to be used, or as soon as they do become ready\n     * @returns {SpeedyPromise<void>}\n     */\n    static ready()\n    {\n        return SpeedyMatrixWASM.ready().then(_ => void(0));\n    }\n\n    /**\n     * Get the underlying buffer\n     * @returns {SpeedyMatrixBufferType}\n     */\n    get data()\n    {\n        return this._data;\n    }\n\n    /**\n     * Row-step\n     * @returns {number} defaults to 1\n     */\n    get step0()\n    {\n        return this._step0;\n    }\n\n    /**\n     * Column-step\n     * @returns {number} defaults to this.rows\n     */\n    get step1()\n    {\n        return this._step1;\n    }\n\n    /**\n     * Extract a block from this matrix. Use a shared underlying buffer\n     * @param {number} firstRow\n     * @param {number} lastRow\n     * @param {number} firstColumn\n     * @param {number} lastColumn\n     * @returns {SpeedyMatrix}\n     */\n    block(firstRow, lastRow, firstColumn, lastColumn)\n    {\n        Utils.assert(\n            firstRow <= lastRow && firstColumn <= lastColumn,\n            `Invalid indices: [${firstRow}:${lastRow},${firstColumn}:${lastColumn}]`\n        );\n\n        // ensure that the indices are within bounds\n        firstRow = Math.max(firstRow, 0);\n        lastRow = Math.min(lastRow, this._rows - 1);\n        firstColumn = Math.max(firstColumn, 0);\n        lastColumn = Math.min(lastColumn, this._columns - 1);\n\n        // compute the dimensions of the new submatrix\n        const rows = lastRow - firstRow + 1;\n        const columns = lastColumn - firstColumn + 1;\n\n        // obtain the relevant portion of the data\n        const step0 = this._step0, step1 = this._step1;\n        const begin = firstRow * step0 + firstColumn * step1; // inclusive\n        const end = 1 + lastRow * step0 + lastColumn * step1; // exclusive\n\n        // create new matrix\n        return new SpeedyMatrix(rows, columns, step0, step1, this._data.subarray(begin, end));\n    }\n\n    /**\n     * Extract a row from this matrix\n     * @param {number} index 0-based\n     * @returns {SpeedyMatrix}\n     */\n    row(index)\n    {\n        return this.block(index, index, 0, this._columns - 1);\n    }\n\n    /**\n     * Extract a column from this matrix\n     * @param {number} index 0-based\n     * @returns {SpeedyMatrix}\n     */\n    column(index)\n    {\n        return this.block(0, this._rows - 1, index, index);\n    }\n\n    /**\n     * Extract the main diagonal from this matrix\n     * @returns {SpeedyMatrix} as a column-vector\n     */\n    diagonal()\n    {\n        const diagsize = Math.min(this._rows, this._columns);\n\n        // compute the dimensions of the new submatrix\n        const rows = diagsize; // make it a column vector\n        const columns = 1;\n\n        // obtain the relevant portion of the data\n        const diagstep = this._step0 + this._step1; // jump a row and a column\n        const begin = 0; // inclusive\n        const end = 1 + (diagsize - 1) * diagstep; // exclusive\n\n        // create new matrix\n        return new SpeedyMatrix(rows, columns, diagstep, diagstep, this._data.subarray(begin, end));\n    }\n\n    /**\n     * Read a single entry of this matrix\n     * @param {number} row 0-based index\n     * @param {number} column 0-based index\n     * @returns {number}\n     */\n    at(row, column)\n    {\n        if(row >= 0 && row < this._rows && column >= 0 && column < this._columns)\n            return this._data[this._step0 * row + this._step1 * column];\n        else\n            return Number.NaN;\n    }\n\n    /**\n     * Read the entries of the matrix in column-major format\n     * @returns {number[]}\n     */\n    read()\n    {\n        const entries = new Array(this._rows * this._columns);\n        const step0 = this._step0, step1 = this._step1;\n        let i = 0;\n\n        for(let column = 0; column < this._columns; column++) {\n            for(let row = 0; row < this._rows; row++)\n                entries[i++] = this._data[row * step0 + column * step1];\n        }\n\n        return entries;\n    }\n\n    /**\n     * Returns a human-readable string representation of the matrix\n     * @returns {string}\n     */\n    toString()\n    {\n        const DECIMALS = 5;\n        const rows = this.rows, columns = this.columns;\n        const entries = this.read();\n        const mat = /** @type {number[][]} */ ( new Array(rows) );\n\n        for(let i = 0; i < rows; i++) {\n            mat[i] = new Array(columns);\n            for(let j = 0; j < columns; j++)\n                mat[i][j] = entries[j * rows + i];\n        }\n\n        const fix = x => x.toFixed(DECIMALS);\n        const fmt = mat.map(row => '    ' + row.map(fix).join(', ')).join(',\\n');\n        const str = `SpeedyMatrix(rows=${rows}, columns=${columns}, data=[\\n${fmt}\\n])`;\n\n        return str;\n    }\n\n    /**\n     * Set the contents of this matrix to the result of an expression\n     * @param {SpeedyMatrixExpr} expr matrix expression\n     * @returns {SpeedyPromise<SpeedyMatrix>} resolves to this\n     */\n    setTo(expr)\n    {\n        return SpeedyMatrixWASM.ready().then(_ => {\n\n            // TODO: add support for WebWorkers\n            return this.setToSync(expr);\n\n        });\n    }\n\n    /**\n     * Synchronously set the contents of this matrix to the result of an expression\n     * @param {SpeedyMatrixExpr} expr matrix expression\n     * @returns {SpeedyMatrix} this\n     */\n    setToSync(expr)\n    {\n        const { wasm, memory } = SpeedyMatrixWASM.handle;\n\n        // evaluate the expression\n        const result = expr._evaluate(wasm, memory);\n\n        /*\n        // shallow copy the results to this matrix\n        // limitation: can't handle blocks properly\n        // (a tree-like structure could be useful)\n        this._rows = result.rows;\n        this._columns = result.columns;\n        //this._dtype = result.dtype;\n        this._data = result.data;\n        this._step0 = result.step0;\n        this._step1 = result.step1;\n        */\n\n        // validate shape\n        Utils.assert(\n            this._rows === result._rows && this._columns === result._columns && this.dtype === result.dtype,\n            `Can't set the values of a ${this.rows} x ${this.columns} ${this.dtype} matrix to those of a ${result.rows} x ${result.columns} ${result.dtype} matrix`\n        );\n\n        // deep copy\n        const step0 = this._step0, step1 = this._step1, rstep0 = result._step0, rstep1 = result._step1;\n        if(step0 === rstep0 && step1 === rstep1 && this._data.length === result._data.length) {\n            // fast copy\n            this._data.set(result._data);\n        }\n        else {\n            // copy each element\n            for(let column = this._columns - 1; column >= 0; column--) {\n                for(let row = this._rows - 1; row >= 0; row--)\n                    this._data[row * step0 + column * step1] = result._data[row * rstep0 + column * rstep1];\n            }\n        }\n\n        // done!\n        return this;\n    }\n\n    /**\n     * Fill this matrix with a scalar value\n     * @param {number} value\n     * @returns {SpeedyPromise<SpeedyMatrix>} resolves to this\n     */\n    fill(value)\n    {\n        this.fillSync(value);\n        return SpeedyPromise.resolve(this);\n    }\n\n    /**\n     * Synchronously fill this matrix with a scalar value\n     * @param {number} value\n     * @returns {SpeedyMatrix} this\n     */\n    fillSync(value)\n    {\n        value = +value;\n\n        if(this._rows * this._columns === this._data.length) {\n            this._data.fill(value);\n            return this;\n        }\n\n        for(let column = 0; column < this._columns; column++) {\n            for(let row = 0; row < this._rows; row++) {\n                this._data[row * this._step0 + column * this._step1] = value;\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     * Evaluate this expression\n     * @param {WebAssembly.Instance} wasm\n     * @param {SpeedyMatrixWASMMemory} memory\n     * @returns {SpeedyMatrix}\n     */\n    _evaluate(wasm, memory)\n    {\n        return this;\n    }\n}\n","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-media-source.js\n * Wrappers around <img>, <video>, <canvas>, etc.\n */\n\nimport { Utils } from '../utils/utils';\nimport { SpeedyPromise } from '../utils/speedy-promise';\nimport { AbstractMethodError, IllegalArgumentError, IllegalOperationError, TimeoutError } from '../utils/errors';\nimport { MediaType } from '../utils/types'\n\n/** @typedef {HTMLImageElement|HTMLVideoElement|HTMLCanvasElement|ImageBitmap} SpeedyMediaSourceNativeElement */\n\n/** Internal token for protected constructors */\nconst PRIVATE_TOKEN = Symbol();\n\n/**\n * An abstract media source: a wrapper around native\n * elements such as: HTMLImageElement, HTMLVideoElement,\n * and so on\n * @abstract\n */\nexport class SpeedyMediaSource\n{\n    /**\n     * @protected Constructor\n     * @param {symbol} token\n     */\n    constructor(token)\n    {\n        // the constructor is not public\n        if(token !== PRIVATE_TOKEN)\n            throw new IllegalOperationError();\n\n        /** @type {SpeedyMediaSourceNativeElement} underlying media object */\n        this._data = null;\n    }\n\n    /**\n     * Load a media source\n     * @param {SpeedyMediaSourceNativeElement} wrappedObject\n     * @returns {SpeedyPromise<SpeedyMediaSource>}\n     */\n    static load(wrappedObject)\n    {\n        if(wrappedObject instanceof HTMLImageElement)\n            return SpeedyImageMediaSource.load(wrappedObject);\n        else if(wrappedObject instanceof HTMLVideoElement)\n            return SpeedyVideoMediaSource.load(wrappedObject);\n        else if(wrappedObject instanceof HTMLCanvasElement)\n            return SpeedyCanvasMediaSource.load(wrappedObject);\n        else if(wrappedObject instanceof ImageBitmap)\n            return SpeedyBitmapMediaSource.load(wrappedObject);\n        else\n            throw new IllegalArgumentError(`Unsupported media type: ${wrappedObject}`);\n    }\n\n    /**\n     * The underlying wrapped object\n     * @returns {SpeedyMediaSourceNativeElement}\n     */\n    get data()\n    {\n        return this._data;\n    }\n\n    /**\n     * Is the underlying media loaded?\n     * @returns {boolean}\n     */\n    isLoaded()\n    {\n        return this._data !== null;\n    }\n\n    /**\n     * The type of the underlying media source\n     * @abstract\n     * @returns {MediaType}\n     */\n    get type()\n    {\n        throw new AbstractMethodError();\n    }\n\n    /**\n     * Media width, in pixels\n     * @abstract\n     * @returns {number}\n     */\n    get width()\n    {\n        throw new AbstractMethodError();\n    }\n\n    /**\n     * Media height, in pixels\n     * @abstract\n     * @returns {number}\n     */\n    get height()\n    {\n        throw new AbstractMethodError();\n    }\n\n    /**\n     * Clone this media source\n     * @abstract\n     * @returns {SpeedyPromise<SpeedyMediaSource>}\n     */\n    clone()\n    {\n        throw new AbstractMethodError();\n    }\n\n    /**\n     * Release resources associated with this object\n     * @returns {null}\n     */\n    release()\n    {\n        return (this._data = null);\n    }\n\n    /**\n     * Load the underlying media\n     * @abstract\n     * @param {SpeedyMediaSourceNativeElement} element\n     * @returns {SpeedyPromise<SpeedyMediaSource>}\n     */\n    _load(element)\n    {\n        throw new AbstractMethodError();\n    }\n\n    /**\n     * Wait for an event to be triggered in an element\n     * @param {Element} element\n     * @param {string} eventName\n     * @param {number} [timeout] in ms\n     * @returns {SpeedyPromise<Element>}\n     */\n    static _waitUntil(element, eventName, timeout = 30000)\n    {\n        return new SpeedyPromise((resolve, reject) => {\n            Utils.log(`Waiting for ${eventName} to be triggered in ${element}...`);\n\n            const timer = setTimeout(() => {\n                reject(new TimeoutError(`${eventName} has not been triggered in ${element}: timeout (${timeout}ms)`));\n            }, timeout);\n\n            element.addEventListener(eventName, () => {\n                clearTimeout(timer);\n                resolve(element);\n            }, false);\n        });\n    }\n}\n\n/**\n * Image media source:\n * a wrapper around HTMLImageElement\n */\nclass SpeedyImageMediaSource extends SpeedyMediaSource\n{\n    /**\n     * @private Constructor\n     * @param {symbol} token\n     */\n    constructor(token)\n    {\n        super(token);\n\n        /** @type {HTMLImageElement} image element */\n        this._data = null;\n    }\n\n    /**\n     * The underlying wrapped object\n     * @returns {HTMLImageElement}\n     */\n    get data()\n    {\n        return this._data;\n    }\n\n    /**\n     * The type of the underlying media source\n     * @returns {MediaType}\n     */\n    get type()\n    {\n        return MediaType.Image;\n    }\n\n    /**\n     * Media width, in pixels\n     * @returns {number}\n     */\n    get width()\n    {\n        return this._data ? this._data.naturalWidth : 0;\n    }\n\n    /**\n     * Media height, in pixels\n     * @returns {number}\n     */\n    get height()\n    {\n        return this._data ? this._data.naturalHeight : 0;\n    }\n\n    /**\n     * Clone this media source\n     * @returns {SpeedyPromise<SpeedyMediaSource>}\n     */\n    clone()\n    {\n        if(this._data == null)\n            throw new IllegalOperationError(`Media not loaded`);\n\n        const newNode = /** @type {HTMLImageElement} */ ( this._data.cloneNode(true) );\n        return SpeedyImageMediaSource.load(newNode);\n    }\n\n    /**\n     * Load the underlying media\n     * @param {HTMLImageElement} image\n     * @returns {SpeedyPromise<SpeedyMediaSource>}\n     */\n    _load(image)\n    {\n        if(this.isLoaded())\n            this.release();\n\n        if(image.complete && image.naturalWidth !== 0) { // already loaded?\n            return new SpeedyPromise(resolve => {\n                this._data = image;\n                resolve(this);\n            });\n        }\n        else {\n            return SpeedyMediaSource._waitUntil(image, 'load').then(() => {\n                this._data = image;\n                return this;\n            });\n        }\n    }\n\n    /**\n     * Load the underlying media\n     * @param {HTMLImageElement} image\n     * @returns {SpeedyPromise<SpeedyMediaSource>}\n     */\n    static load(image)\n    {\n        return new SpeedyImageMediaSource(PRIVATE_TOKEN)._load(image);\n    }\n}\n\n/**\n * Video media source:\n * a wrapper around HTMLVideoElement\n */\nclass SpeedyVideoMediaSource extends SpeedyMediaSource\n{\n    /**\n     * @private Constructor\n     * @param {symbol} token\n     */\n    constructor(token)\n    {\n        super(token);\n\n        /** @type {HTMLVideoElement} video element */\n        this._data = null;\n    }\n\n    /**\n     * The underlying wrapped object\n     * @returns {HTMLVideoElement}\n     */\n    get data()\n    {\n        return this._data;\n    }\n\n    /**\n     * The type of the underlying media source\n     * @returns {MediaType}\n     */\n    get type()\n    {\n        return MediaType.Video;\n    }\n\n    /**\n     * Media width, in pixels\n     * @returns {number}\n     */\n    get width()\n    {\n        // Warning: videoWidth & videoHeight may change at any time !!!\n        // so you can't cache these dimensions\n        return this._data ? this._data.videoWidth : 0;\n    }\n\n    /**\n     * Media height, in pixels\n     * @returns {number}\n     */\n    get height()\n    {\n        return this._data ? this._data.videoHeight : 0;\n    }\n\n    /**\n     * Clone this media source\n     * @returns {SpeedyPromise<SpeedyMediaSource>}\n     */\n    clone()\n    {\n        if(this._data == null)\n            throw new IllegalOperationError(`Media not loaded`);\n\n        const newNode = /** @type {HTMLVideoElement} */ ( this._data.cloneNode(true) );\n        return SpeedyVideoMediaSource.load(newNode);\n    }\n\n    /**\n     * Load the underlying media\n     * @param {HTMLVideoElement} video\n     * @returns {SpeedyPromise<SpeedyMediaSource>}\n     */\n    _load(video)\n    {\n        if(this.isLoaded())\n            this.release();\n\n        if(video.readyState >= 4) { // already loaded?\n            return new SpeedyPromise(resolve => {\n                this._data = video;\n                resolve(this);\n            });\n        }\n        else {\n            // waitUntil('canplay'); // use readyState >= 3\n            return SpeedyMediaSource._waitUntil(video, 'canplaythrough').then(() => {\n                this._data = video;\n                return this;\n            })\n        }\n    }\n\n    /**\n     * Load the underlying media\n     * @param {HTMLVideoElement} video\n     * @returns {SpeedyPromise<SpeedyMediaSource>}\n     */\n    static load(video)\n    {\n        return new SpeedyVideoMediaSource(PRIVATE_TOKEN)._load(video);\n    }\n}\n\n/**\n * Canvas media source:\n * a wrapper around HTMLCanvasElement\n */\nclass SpeedyCanvasMediaSource extends SpeedyMediaSource\n{\n    /**\n     * @private Constructor\n     * @param {symbol} token\n     */\n    constructor(token)\n    {\n        super(token);\n\n        /** @type {HTMLCanvasElement} canvas element */\n        this._data = null;\n    }\n\n    /**\n     * The underlying wrapped object\n     * @returns {HTMLCanvasElement}\n     */\n    get data()\n    {\n        return this._data;\n    }\n\n    /**\n     * The type of the underlying media source\n     * @returns {MediaType}\n     */\n    get type()\n    {\n        return MediaType.Canvas;\n    }\n\n    /**\n     * Media width, in pixels\n     * @returns {number}\n     */\n    get width()\n    {\n        return this._data ? this._data.width : 0;\n    }\n\n    /**\n     * Media height, in pixels\n     * @returns {number}\n     */\n    get height()\n    {\n        return this._data ? this._data.height : 0;\n    }\n\n    /**\n     * Clone this media source\n     * @returns {SpeedyPromise<SpeedyMediaSource>}\n     */\n    clone()\n    {\n        if(this._data == null)\n            throw new IllegalOperationError(`Media not loaded`);\n\n        const newCanvas = Utils.createCanvas(this.width, this.height);\n        const newContext = newCanvas.getContext('2d');\n        newContext.drawImage(this._data, 0, 0);\n\n        return SpeedyCanvasMediaSource.load(newCanvas);\n    }\n\n    /**\n     * Load the underlying media\n     * @param {HTMLCanvasElement} canvas\n     * @returns {SpeedyPromise<SpeedyMediaSource>}\n     */\n    _load(canvas)\n    {\n        if(this.isLoaded())\n            this.release();\n\n        return new SpeedyPromise(resolve => {\n            this._data = canvas;\n            resolve(this);\n        });\n    }\n\n    /**\n     * Load the underlying media\n     * @param {HTMLCanvasElement} canvas\n     * @returns {SpeedyPromise<SpeedyMediaSource>}\n     */\n    static load(canvas)\n    {\n        return new SpeedyCanvasMediaSource(PRIVATE_TOKEN)._load(canvas);\n    }\n}\n\n/**\n * Bitmap media source:\n * a wrapper around ImageBitmap\n */\nclass SpeedyBitmapMediaSource extends SpeedyMediaSource\n{\n    /**\n     * @private Constructor\n     * @param {symbol} token\n     */\n    constructor(token)\n    {\n        super(token);\n\n        /** @type {ImageBitmap} image bitmap */\n        this._data = null;\n    }\n\n    /**\n     * The underlying wrapped object\n     * @returns {ImageBitmap}\n     */\n    get data()\n    {\n        return this._data;\n    }\n\n    /**\n     * The type of the underlying media source\n     * @returns {MediaType}\n     */\n    get type()\n    {\n        return MediaType.Bitmap;\n    }\n\n    /**\n     * Media width, in pixels\n     * @returns {number}\n     */\n    get width()\n    {\n        return this._data ? this._data.width : 0;\n    }\n\n    /**\n     * Media height, in pixels\n     * @returns {number}\n     */\n    get height()\n    {\n        return this._data ? this._data.height : 0;\n    }\n\n    /**\n     * Clone this media source\n     * @returns {SpeedyPromise<SpeedyMediaSource>}\n     */\n    clone()\n    {\n        if(this._data == null)\n            throw new IllegalOperationError(`Media not loaded`);\n\n        return new SpeedyPromise((resolve, reject) => {\n            createImageBitmap(this._data).then(\n                newBitmap => {\n                    const newSource = new SpeedyBitmapMediaSource(PRIVATE_TOKEN);\n                    newSource._load(newBitmap).then(resolve, reject);\n                },\n                reject\n            );\n        });\n    }\n\n    /**\n     * Release resources associated with this object\n     * @returns {null}\n     */\n    release()\n    {\n        if(this._data != null)\n            this._data.close();\n\n        return super.release();\n    }\n\n    /**\n     * Load the underlying media\n     * @param {ImageBitmap} bitmap\n     * @returns {SpeedyPromise<SpeedyMediaSource>}\n     */\n    _load(bitmap)\n    {\n        if(this.isLoaded())\n            this.release();\n\n        return new SpeedyPromise(resolve => {\n            this._data = bitmap;\n            resolve(this);\n        });\n    }\n\n    /**\n     * Load the underlying media\n     * @param {ImageBitmap} bitmap\n     * @returns {SpeedyPromise<SpeedyMediaSource>}\n     */\n    static load(bitmap)\n    {\n        return new SpeedyBitmapMediaSource(PRIVATE_TOKEN)._load(bitmap);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-media.js\n * SpeedyMedia implementation\n */\n\nimport { SpeedyGPU } from '../gpu/speedy-gpu';\nimport { SpeedyTexture } from '../gpu/speedy-texture';\nimport { MediaType, ImageFormat } from '../utils/types'\nimport { IllegalOperationError, IllegalArgumentError } from '../utils/errors';\nimport { Utils } from '../utils/utils';\nimport { SpeedyMediaSource } from './speedy-media-source';\nimport { SpeedyPromise } from '../utils/speedy-promise';\nimport { SpeedySize } from './speedy-size';\n\n/** @typedef {import('./speedy-media-source').SpeedyMediaSourceNativeElement} SpeedyMediaSourceNativeElement */\n\n/**\n * @typedef {object} SpeedyMediaOptions\n * @property {ImageFormat} [format] default is RGBA\n */\n\n/** A helper used to keep the constructor of SpeedyMedia private */\nconst PRIVATE_TOKEN = Symbol();\n\n/**\n * SpeedyMedia encapsulates a media element\n * (e.g., image, video, canvas)\n */\nexport class SpeedyMedia\n{\n    /**\n     * @private Constructor. It receives a VALID media source that is ALREADY LOADED.\n     * @param {symbol} token\n     * @param {SpeedyMediaSource} source\n     * @param {SpeedyMediaOptions} [options] options object\n     */\n    constructor(token, source, options = {})\n    {\n        // private constructor\n        if(token !== PRIVATE_TOKEN)\n            throw new IllegalOperationError();\n\n\n\n        /** @type {SpeedyMediaSource} media source */\n        this._source = source;\n\n        /** @type {ImageFormat} format */\n        this._format = options.format !== undefined ? options.format : ImageFormat.RGBA;\n\n        /** @type {SpeedyMediaOptions} options */\n        this._options = Object.freeze({ ...options, format: this._format });\n\n\n\n        // validate\n        if(!source.isLoaded())\n            throw new IllegalOperationError(`Source not loaded: ${source}`);\n        else if(this._format !== ImageFormat.RGBA && this._format !== ImageFormat.GREY)\n            throw new IllegalArgumentError(`Invalid format: ${this._format}`);\n    }\n\n    /**\n     * Load a media source\n     * Will wait until the HTML media source is loaded\n     * @param {SpeedyMediaSourceNativeElement} mediaSource An image, video or canvas\n     * @param {SpeedyMediaOptions} [options] options object\n     * @param {boolean} [log] show log message?\n     * @returns {SpeedyPromise<SpeedyMedia>}\n     */\n    static load(mediaSource, options = {}, log = true)\n    {\n        return SpeedyMediaSource.load(mediaSource).then(source => {\n            Utils.assert(source.width !== 0 && source.height !== 0);\n\n            // FIXME user could pass an invalid format in options if ImageFormat is made public\n            const media = new SpeedyMedia(PRIVATE_TOKEN, source, options);\n\n            // show log message\n            if(log)\n                Utils.log(`Loaded SpeedyMedia with a ${mediaSource}.`);\n\n            // done!\n            return media;\n        });\n    }\n\n    /**\n     * The media element (image, video, canvas) encapsulated by this SpeedyMedia object\n     * @returns {SpeedyMediaSourceNativeElement} the media element\n     */\n    get source()\n    {\n        return this._source ? this._source.data : null;\n    }\n\n    /**\n     * Gets the width of the media\n     * @returns {number} media width\n     */\n    get width()\n    {\n        return this._source ? this._source.width : 0;\n    }\n\n    /**\n     * Gets the height of the media\n     * @returns {number} media height\n     */\n    get height()\n    {\n        return this._source ? this._source.height : 0;\n    }\n\n    /**\n     * The type of the media attached to this SpeedyMedia object\n     * @returns {\"image\" | \"video\" | \"canvas\" | \"bitmap\" | \"unknown\"}\n     */\n    get type()\n    {\n        if(this.isReleased())\n            return 'unknown';\n\n        switch(this._source.type) {\n            case MediaType.Image:\n                return 'image';\n\n            case MediaType.Video:\n                return 'video';\n\n            case MediaType.Canvas:\n                return 'canvas';\n\n            case MediaType.Bitmap:\n                return 'bitmap';\n\n            default: // this shouldn't happen\n                return 'unknown';\n        }\n    }\n\n    /**\n     * Returns a read-only object featuring advanced options\n     * related to this SpeedyMedia object\n     * @returns {SpeedyMediaOptions}\n     */\n    get options()\n    {\n        return this._options;\n    }\n\n    /**\n     * The size of this media, in pixels\n     * @returns {SpeedySize}\n     */\n    size()\n    {\n        return new SpeedySize(this.width, this.height);\n    }\n\n    /**\n     * Releases resources associated with this media\n     * @returns {null}\n     */\n    release()\n    {\n        if(!this.isReleased()) {\n            Utils.log('Releasing SpeedyMedia object...');\n            this._source = this._source.release();\n        }\n\n        return null;\n    }\n\n    /**\n     * Has this media been released?\n     * @returns {boolean}\n     */\n    isReleased()\n    {\n        return this._source == null;\n    }\n\n    /**\n     * Clones the SpeedyMedia object\n     * @returns {SpeedyPromise<SpeedyMedia>} a clone object\n     */\n    clone()\n    {\n        // has the media been released?\n        if(this.isReleased())\n            throw new IllegalOperationError(`Can't clone a SpeedyMedia that has been released`);\n\n        // clone the object\n        const clone = new SpeedyMedia(PRIVATE_TOKEN, this._source, this._options);\n\n        // done!\n        return SpeedyPromise.resolve(clone);\n    }\n\n    /**\n     * Draws the media to a canvas\n     * @param {HTMLCanvasElement} canvas canvas element\n     * @param {number} [x] x-position\n     * @param {number} [y] y-position\n     * @param {number} [width] desired width\n     * @param {number} [height] desired height\n     */\n    draw(canvas, x = 0, y = 0, width = this.width, height = this.height)\n    {\n        // fail silently if the media been released\n        if(this.isReleased())\n            return;\n\n        // validate parameters\n        width = Math.max(+width, 0);\n        height = Math.max(+height, 0);\n\n        // draw\n        const ctx = canvas.getContext('2d');\n        ctx.drawImage(this._source.data, +x, +y, width, height);\n    }\n\n    /**\n     * Converts the media to an ImageBitmap\n     * @returns {SpeedyPromise<ImageBitmap>}\n     */\n    toBitmap()\n    {\n        if(this.isReleased())\n            throw new IllegalOperationError('Can\\'t convert SpeedyMedia to ImageBitmap: the media has been released');\n        else if(!this._source.isLoaded())\n            throw new IllegalOperationError('Can\\'t convert SpeedyMedia to bitmap: the media hasn\\'t been loaded');\n        else if(this._source.type == MediaType.Bitmap)\n            return SpeedyPromise.resolve(this._source.data);\n        else\n            return new SpeedyPromise((resolve, reject) => createImageBitmap(this._source.data).then(resolve, reject));\n    }\n}\n","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-namespace.js\n * Symbolizes a namespace\n */\n\nimport { AbstractMethodError } from '../utils/errors'\n\n/**\n * An abstract namespace\n * @abstract\n */\nexport class SpeedyNamespace\n{\n    /**\n     * Namespaces can't be instantiated.\n     * Only static methods are allowed.\n     * @abstract\n     * @throws SpeedyError\n     */\n    constructor()\n    {\n        // only static methods are allowed\n        throw new AbstractMethodError(`Namespaces can't be instantiated`);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-point.js\n * Points in space\n */\n\nimport { SpeedyVector2 } from './speedy-vector';\n\n/**\n * 2D point\n */\nexport class SpeedyPoint2\n{\n    /**\n     * Create a 2D point\n     * @param {number} x\n     * @param {number} y\n     */\n    constructor(x, y)\n    {\n        /** @type {number} x coordinate */\n        this._x = +x;\n\n        /** @type {number} y coordinate */\n        this._y = +y;\n    }\n\n\n\n    //\n    // ===== METHODS =====\n    //\n\n    /**\n     * x-coordinate\n     * @returns {number}\n     */\n    get x()\n    {\n        return this._x;\n    }\n\n    /**\n     * x-coordinate\n     * @param {number} value\n     */\n    set x(value)\n    {\n        this._x = +value;\n    }\n\n    /**\n     * y-coordinate\n     * @returns {number}\n     */\n    get y()\n    {\n        return this._y;\n    }\n\n    /**\n     * y-coordinate\n     * @param {number} value\n     */\n    set y(value)\n    {\n        this._y = +value;\n    }\n\n    /**\n     * Convert to string\n     * @returns {string}\n     */\n    toString()\n    {\n        return `SpeedyPoint2(${this.x.toFixed(5)}, ${this.y.toFixed(5)})`;\n    }\n\n    /**\n     * Add a vector to this point\n     * @param {SpeedyVector2} v \n     * @returns {SpeedyPoint2}\n     */\n    plus(v)\n    {\n        return new SpeedyPoint2(this.x + v.x, this.y + v.y);\n    }\n\n    /**\n     * Subtracts a point p from this point\n     * @param {SpeedyPoint2} p \n     * @returns {SpeedyVector2}\n     */\n    minus(p)\n    {\n        return new SpeedyVector2(this.x - p.x, this.y - p.y);\n    }\n\n    /**\n     * Is this point equal to p?\n     * @param {SpeedyPoint2} p\n     * @returns {boolean}\n     */\n    equals(p)\n    {\n        return this.x === p.x && this.y === p.y;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-size.js\n * Size of a rectangle\n */\n\n/**\n * Size of a rectangle\n */\nexport class SpeedySize\n{\n    /**\n     * Constructor\n     * @param {number} width non-negative number\n     * @param {number} height non-negative number\n     */\n    constructor(width, height)\n    {\n        /** @type {number} width */\n        this._width = Math.max(0, +width);\n\n        /** @type {number} height */\n        this._height = Math.max(0, +height);\n    }\n\n\n\n    //\n    // ===== METHODS =====\n    //\n\n    /**\n     * Width\n     * @returns {number}\n     */\n    get width()\n    {\n        return this._width;\n    }\n\n    /**\n     * Width\n     * @param {number} value\n     */\n    set width(value)\n    {\n        this._width = Math.max(0, +value);\n    }\n\n    /**\n     * Height\n     * @returns {number}\n     */\n    get height()\n    {\n        return this._height;\n    }\n\n    /**\n     * Height\n     * @param {number} value\n     */\n    set height(value)\n    {\n        this._height = Math.max(0, +value);\n    }\n\n    /**\n     * Convert to string\n     * @returns {string}\n     */\n    toString()\n    {\n        return `SpeedySize(${this.width}, ${this.height})`;\n    }\n\n    /**\n     * Is this size equal to anotherSize?\n     * @param {SpeedySize} anotherSize\n     * @returns {boolean}\n     */\n    equals(anotherSize)\n    {\n        return this.width === anotherSize.width && this.height === anotherSize.height;\n    }\n\n    /**\n     * The area of the rectangle\n     * @returns {number}\n     */\n    area()\n    {\n        return this.width * this.height;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-vector.js\n * Vectors\n */\n\n/**\n * 2D vector of floating-point numbers\n */\nexport class SpeedyVector2\n{\n    /**\n     * Create a 2D vector\n     * @param {number} x\n     * @param {number} y\n     */\n    constructor(x, y)\n    {\n        /** @type {number} x coordinate */\n        this._x = +x;\n\n        /** @type {number} y coordinate */\n        this._y = +y;\n    }\n\n\n\n    //\n    // ===== METHODS =====\n    //\n\n    /**\n     * x-coordinate\n     * @returns {number}\n     */\n    get x()\n    {\n        return this._x;\n    }\n\n    /**\n     * x-coordinate\n     * @param {number} value\n     */\n    set x(value)\n    {\n        this._x = +value;\n    }\n\n    /**\n     * y-coordinate\n     * @returns {number}\n     */\n    get y()\n    {\n        return this._y;\n    }\n\n    /**\n     * y-coordinate\n     * @param {number} value\n     */\n    set y(value)\n    {\n        this._y = +value;\n    }\n\n    /**\n     * Convert to string\n     * @returns {string}\n     */\n    toString()\n    {\n        return `SpeedyVector2(${this.x.toFixed(5)}, ${this.y.toFixed(5)})`;\n    }\n\n    /**\n     * Is this vector equal to v?\n     * @param {SpeedyVector2} v\n     * @returns {boolean}\n     */\n    equals(v)\n    {\n        return this.x === v.x && this.y === v.y;\n    }\n\n    /**\n     * Dot product between this vector and another vector\n     * @param {SpeedyVector2} v another vector\n     * @returns {number}\n     */\n    dot(v)\n    {\n        return this.x * v.x + this.y * v.y;\n    }\n\n    /**\n     * The distance between this vector and another vector\n     * @param {SpeedyVector2} v another vector\n     * @returns {number}\n     */\n    distanceTo(v)\n    {\n        const dx = this.x - v.x;\n        const dy = this.y - v.y;\n\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    /**\n     * Euclidean norm\n     * @returns {number}\n     */\n    length()\n    {\n        return Math.sqrt(this.x * this.x + this.y * this.y);\n    }\n\n    /**\n     * Returns a normalized version of this vector\n     * @returns {SpeedyVector2}\n     */\n    normalized()\n    {\n        const len = this.length();\n\n        if(len > 0.0)\n            return new SpeedyVector2(this.x / len, this.y / len);\n        else\n            return new SpeedyVector2(0.0, 0.0);\n    }\n\n    /**\n     * Returns a copy of this vector translated by offset\n     * @param {SpeedyVector2} offset\n     * @returns {SpeedyVector2}\n     */\n    plus(offset)\n    {\n        return new SpeedyVector2(this.x + offset.x, this.y + offset.y);\n    }\n\n    /**\n     * Returns a copy of this vector translated by -offset\n     * @param {SpeedyVector2} offset\n     * @returns {SpeedyVector2}\n     */\n    minus(offset)\n    {\n        return new SpeedyVector2(this.x - offset.x, this.y - offset.y);\n    }\n\n    /**\n     * Returns a copy of this vector scaled by a scalar\n     * @param {number} scalar\n     * @returns {SpeedyVector2}\n     */\n    times(scalar)\n    {\n        return new SpeedyVector2(this.x * scalar, this.y * scalar);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * filters.js\n * Image filtering on the GPU\n */\n\nimport { SpeedyGPU } from '../speedy-gpu';\nimport { SpeedyProgramGroup } from '../speedy-program-group';\nimport { importShader } from '../shader-declaration';\nimport { convX, convY } from '../shaders/filters/convolution';\nimport { Utils } from '../../utils/utils';\n\n\n\n//\n// Shaders\n//\n\n// Convert to greyscale\nconst rgb2grey = importShader('filters/rgb2grey.glsl')\n                .withArguments('image');\n\n// Convolution\nconst convolution = [3, 5, 7].reduce((obj, ksize) => ((obj[ksize] =\n                        importShader('filters/convolution2d.glsl')\n                       .withDefines({ 'KERNEL_SIZE_SQUARED': ksize * ksize })\n                       .withArguments('image', 'kernel')\n                    ), obj), {});\n\n// Separable convolution\nconst convolutionX = [3, 5, 7, 9, 11, 13, 15].reduce((obj, ksize) => ((obj[ksize] =\n                         importShader('filters/convolution1d.glsl')\n                        .withDefines({ 'KERNEL_SIZE': ksize, 'AXIS': 0 })\n                        .withArguments('image', 'kernel')\n                     ), obj), {});\n\nconst convolutionY = [3, 5, 7, 9, 11, 13, 15].reduce((obj, ksize) => ((obj[ksize] =\n                         importShader('filters/convolution1d.glsl')\n                        .withDefines({ 'KERNEL_SIZE': ksize, 'AXIS': 1 })\n                        .withArguments('image', 'kernel')\n                     ), obj), {});\n// Median filter\nconst median = [3, 5, 7].reduce((obj, ksize) => ((obj[ksize] =\n                   importShader('filters/fast-median.glsl')\n                  .withDefines({ 'KERNEL_SIZE': ksize })\n                  .withArguments('image')\n               ), obj), {});\n\n// Normalize image\nconst normalizeGreyscale = importShader('filters/normalize-image.glsl')\n                          .withDefines({ 'GREYSCALE': 1 })\n                          .withArguments('minmax2d', 'minValue', 'maxValue');\n\nconst normalizeColored = importShader('filters/normalize-image.glsl')\n                        .withDefines({ 'GREYSCALE': 0 })\n                        .withArguments('minmax2dRGB', 'minValue', 'maxValue');\n\n// Nightvision\nconst nightvision = importShader('filters/nightvision.glsl')\n                   .withDefines({ 'GREYSCALE': 0 })\n                   .withArguments('image', 'illuminationMap', 'gain', 'offset', 'decay');\n\nconst nightvisionGreyscale = importShader('filters/nightvision.glsl')\n                            .withDefines({ 'GREYSCALE': 1 })\n                            .withArguments('image', 'illuminationMap', 'gain', 'offset', 'decay');\n\n\n\n//\n// Utilities\n//\n\n// Handy conversion for Gaussian filters\n// (symmetric kernel, approx. zero after 3*sigma)\nconst ksize2sigma = ksize => Math.max(1.0, ksize / 6.0);\n\n// Generate a 1D Gaussian kernel\nconst gaussian = ksize => Utils.gaussianKernel(ksize2sigma(ksize), ksize);\n\n// Generate a 1D Box filter\nconst box = ksize => (new Array(ksize)).fill(1.0 / ksize);\n\n\n\n/**\n * SpeedyProgramGroupFilters\n * Image filtering\n */\nexport class SpeedyProgramGroupFilters extends SpeedyProgramGroup\n{\n    /**\n     * Class constructor\n     * @param {SpeedyGPU} gpu\n     */\n    constructor(gpu)\n    {\n        super(gpu);\n        this\n            // convert to greyscale\n            .declare('rgb2grey', rgb2grey)\n\n            // median filters\n            .declare('median3', median[3]) // 3x3 window\n            .declare('median5', median[5]) // 5x5 window\n            .declare('median7', median[7]) // 7x7 window\n\n            // 2D convolution\n            .declare('convolution3', convolution[3]) // 3x3 kernel\n            .declare('convolution5', convolution[5]) // 5x5 kernel\n            .declare('convolution7', convolution[7]) // 7x7 kernel\n\n            // 1D separable convolution\n            .declare('convolution3x', convolutionX[3]) // 1x3 kernel\n            .declare('convolution3y', convolutionY[3]) // 3x1 kernel\n            .declare('convolution5x', convolutionX[5]) // 1x5 kernel\n            .declare('convolution5y', convolutionY[5]) // 5x1 kernel\n            .declare('convolution7x', convolutionX[7])\n            .declare('convolution7y', convolutionY[7])\n            .declare('convolution9x', convolutionX[9])\n            .declare('convolution9y', convolutionY[9])\n            .declare('convolution11x', convolutionX[11])\n            .declare('convolution11y', convolutionY[11])\n            .declare('convolution13x', convolutionX[13])\n            .declare('convolution13y', convolutionY[13])\n            .declare('convolution15x', convolutionX[15])\n            .declare('convolution15y', convolutionY[15])\n\n            // normalize image\n            .declare('normalizeGreyscale', normalizeGreyscale)\n            .declare('normalizeColored', normalizeColored)\n\n            // nightvision\n            .declare('nightvision', nightvision)\n            .declare('nightvisionGreyscale', nightvisionGreyscale)\n            .declare('illuminationMapLoX', convX(Utils.gaussianKernel(80, 31)))\n            .declare('illuminationMapLoY', convY(Utils.gaussianKernel(80, 31)))\n            .declare('illuminationMapX', convX(Utils.gaussianKernel(80, 63)))\n            .declare('illuminationMapY', convY(Utils.gaussianKernel(80, 63)))\n            .declare('illuminationMapHiX', convX(Utils.gaussianKernel(80, 255)))\n            .declare('illuminationMapHiY', convY(Utils.gaussianKernel(80, 255)))\n\n            // gaussian: separable kernels\n            // see also: http://dev.theomader.com/gaussian-kernel-calculator/\n            .declare('gaussian3x', convX([ 0.25, 0.5, 0.25 ])) // sigma ~ 1.0\n            .declare('gaussian3y', convY([ 0.25, 0.5, 0.25 ]))\n            .declare('gaussian5x', convX([ 0.05, 0.25, 0.4, 0.25, 0.05 ])) // sigma ~ 1.0\n            .declare('gaussian5y', convY([ 0.05, 0.25, 0.4, 0.25, 0.05 ]))\n            .declare('gaussian7x', convX(gaussian(7)))\n            .declare('gaussian7y', convY(gaussian(7)))\n            .declare('gaussian9x', convX(gaussian(9)))\n            .declare('gaussian9y', convY(gaussian(9)))\n            .declare('gaussian11x', convX(gaussian(11)))\n            .declare('gaussian11y', convY(gaussian(11)))\n\n            // box filter: separable kernels\n            .declare('box3x', convX(box(3)))\n            .declare('box3y', convY(box(3)))\n            .declare('box5x', convX(box(5)))\n            .declare('box5y', convY(box(5)))\n            .declare('box7x', convX(box(7)))\n            .declare('box7y', convY(box(7)))\n            .declare('box9x', convX(box(9)))\n            .declare('box9y', convY(box(9)))\n            .declare('box11x', convX(box(11)))\n            .declare('box11y', convY(box(11)))\n        ;\n    }\n}\n","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * keypoints.js\n * Facade for various keypoint detection algorithms\n */\n\nimport { SpeedyGPU } from '../speedy-gpu';\nimport { SpeedyProgramGroup } from '../speedy-program-group';\nimport { SpeedyTexture, SpeedyDrawableTexture } from '../speedy-texture';\nimport { LSH_SEQUENCE_COUNT, LSH_SEQUENCE_MAXLEN, LSH_ACCEPTABLE_DESCRIPTOR_SIZES, LSH_ACCEPTABLE_HASH_SIZES } from '../speedy-lsh';\nimport { importShader } from '../shader-declaration';\n\n\n// FAST corner detector\nconst fast9_16 = importShader('keypoints/fast.glsl', 'keypoints/fast.vs.glsl')\n                .withDefines({ 'FAST_TYPE': 916 })\n                .withArguments('corners', 'pyramid', 'lod', 'threshold');\n\n// Harris corner detector\nconst harris = [1, 3, 5, 7].reduce((obj, win) => ((obj[win] =\n                   importShader('keypoints/harris.glsl')\n                  .withDefines({ 'WINDOW_SIZE': win })\n                  .withArguments('corners', 'pyramid', 'derivatives', 'lod', 'lodStep', 'gaussian')\n               ), obj), {});\n\nconst harrisScoreFindMax = importShader('keypoints/score-findmax.glsl')\n                          .withArguments('corners', 'iterationNumber');\n\nconst harrisScoreCutoff = importShader('keypoints/harris-cutoff.glsl')\n                         .withArguments('corners', 'maxScore', 'quality');\n\n// Subpixel refinement\nconst subpixelQuadratic1d = importShader('keypoints/subpixel-refinement.glsl')\n                           .withDefines({ 'METHOD': 0 })\n                           .withArguments('pyramid', 'encodedKeypoints', 'descriptorSize', 'extraSize', 'encoderLength', 'maxIterations', 'epsilon');\n\nconst subpixelTaylor2d = importShader('keypoints/subpixel-refinement.glsl')\n                        .withDefines({ 'METHOD': 1 })\n                        .withArguments('pyramid', 'encodedKeypoints', 'descriptorSize', 'extraSize', 'encoderLength', 'maxIterations', 'epsilon');\n\nconst subpixelBilinear = importShader('keypoints/subpixel-refinement.glsl')\n                        .withDefines({ 'METHOD': 2 })\n                        .withArguments('pyramid', 'encodedKeypoints', 'descriptorSize', 'extraSize', 'encoderLength', 'maxIterations', 'epsilon');\n\nconst subpixelBicubic = importShader('keypoints/subpixel-refinement.glsl')\n                       .withDefines({ 'METHOD': 3 })\n                       .withArguments('pyramid', 'encodedKeypoints', 'descriptorSize', 'extraSize', 'encoderLength', 'maxIterations', 'epsilon');\n\n// Scale refinement\nconst refineScaleLoG = importShader('keypoints/refine-scale.glsl')\n                      .withDefines({ 'METHOD': 0 })\n                      .withArguments('pyramid', 'lodStep', 'encodedKeypoints', 'descriptorSize', 'extraSize', 'encoderLength');\n\nconst refineScaleFAST916 = importShader('keypoints/refine-scale.glsl')\n                          .withDefines({ 'METHOD': 1 })\n                          .withArguments('pyramid', 'lodStep', 'encodedKeypoints', 'descriptorSize', 'extraSize', 'encoderLength', 'threshold');\n\n// Pixel allocation\nconst allocateDescriptors = importShader('keypoints/allocate-descriptors.glsl')\n                            .withArguments('inputEncodedKeypoints', 'inputDescriptorSize', 'inputExtraSize', 'inputEncoderLength', 'outputDescriptorSize', 'outputExtraSize', 'outputEncoderLength');\n\nconst allocateExtra = importShader('keypoints/allocate-extra.glsl')\n                     .withArguments('inputEncodedKeypoints', 'inputDescriptorSize', 'inputExtraSize', 'inputEncoderLength', 'outputDescriptorSize', 'outputExtraSize', 'outputEncoderLength');\n\nconst transferToExtra = importShader('keypoints/transfer-to-extra.glsl')\n                        .withArguments('encodedData', 'strideOfEncodedData', 'encodedKeypoints', 'descriptorSize', 'extraSize', 'encoderLength');\n\n// ORB descriptors\nconst orbDescriptor = importShader('keypoints/orb-descriptor.glsl')\n                     .withArguments('image', 'encodedCorners', 'extraSize', 'encoderLength');\n\nconst orbOrientation = importShader('keypoints/orb-orientation.glsl')\n                      .withArguments('image', 'encodedKeypoints', 'descriptorSize', 'extraSize', 'encoderLength');\n\n// Non-maximum suppression\nconst nonMaxSuppression = importShader('keypoints/nonmax-suppression.glsl')\n                         .withDefines({ 'MULTISCALE': 0 })\n                         .withArguments('image', 'lodStep');\n\nconst multiscaleNonMaxSuppression = importShader('keypoints/nonmax-suppression.glsl')\n                                   .withDefines({ 'MULTISCALE': 1 })\n                                   .withArguments('image', 'lodStep');\n\nconst nonmaxSpace = importShader('keypoints/nonmax-space.glsl')\n                    .withArguments('corners');\n\nconst nonmaxScale = importShader('keypoints/nonmax-scale.glsl')\n                    .withDefines({ 'USE_LAPLACIAN': 1 })\n                    .withArguments('corners', 'pyramid', 'pyrLaplacian', 'lodStep');\n\nconst nonmaxScaleSimple = importShader('keypoints/nonmax-scale.glsl')\n                         .withDefines({ 'USE_LAPLACIAN': 0 })\n                         .withArguments('corners', 'pyramid', 'lodStep');\n\nconst laplacian = importShader('keypoints/laplacian.glsl')\n                 .withArguments('corners', 'pyramid', 'lodStep', 'lodOffset');\n\n// Keypoint tracking & optical-flow\nconst lk = [3, 5, 7, 9, 11, 13, 15, 17, 19, 21].reduce((obj, win) => ((obj[win] =\n               importShader('keypoints/lk.glsl')\n               .withDefines({ 'WINDOW_SIZE': win })\n               .withArguments('encodedFlow', 'prevKeypoints', 'nextPyramid', 'prevPyramid', 'level', 'depth', 'numberOfIterations', 'discardThreshold', 'epsilon', 'descriptorSize', 'extraSize', 'encoderLength')\n           ), obj), {});\n\nconst transferFlow = importShader('keypoints/transfer-flow.glsl')\n                     .withArguments('encodedFlow', 'encodedKeypoints', 'descriptorSize', 'extraSize', 'encoderLength');\n\n// Brute-force matching\nconst bfMatcherInitCandidates = importShader('keypoints/knn-init.glsl')\n                               .withDefines({ 'ENCODE_FILTERS': 0 });\n\nconst bfMatcherInitFilters = importShader('keypoints/knn-init.glsl')\n                            .withDefines({ 'ENCODE_FILTERS': 1 });\n\nconst bfMatcherTransfer = importShader('keypoints/knn-transfer.glsl')\n                         .withArguments('encodedMatches', 'encodedKthMatches', 'numberOfMatchesPerKeypoint', 'kthMatch');\n\nconst bfMatcher32 = importShader('keypoints/bf-knn.glsl')\n                    .withDefines({\n                        'DESCRIPTOR_SIZE': 32,\n                        'NUMBER_OF_KEYPOINTS_PER_PASS': 16,\n                    })\n                    .withArguments('encodedMatches', 'encodedFilters', 'matcherLength', 'dbEncodedKeypoints', 'dbDescriptorSize', 'dbExtraSize', 'dbEncoderLength', 'encodedKeypoints', 'descriptorSize', 'extraSize', 'encoderLength', 'passId');\n\nconst bfMatcher64 = importShader('keypoints/bf-knn.glsl')\n                    .withDefines({\n                        'DESCRIPTOR_SIZE': 64,\n                        'NUMBER_OF_KEYPOINTS_PER_PASS': 8,\n                    })\n                    .withArguments('encodedMatches', 'encodedFilters', 'matcherLength', 'dbEncodedKeypoints', 'dbDescriptorSize', 'dbExtraSize', 'dbEncoderLength', 'encodedKeypoints', 'descriptorSize', 'extraSize', 'encoderLength', 'passId');\n\n// LSH-based KNN matching\nconst lshKnnInitCandidates = importShader('keypoints/knn-init.glsl')\n                            .withDefines({ 'ENCODE_FILTERS': 0 });\n\nconst lshKnnInitFilters = importShader('keypoints/knn-init.glsl')\n                         .withDefines({ 'ENCODE_FILTERS': 1 });\n\nconst lshKnn = LSH_ACCEPTABLE_DESCRIPTOR_SIZES.reduce((obj, descriptorSize) => ((obj[descriptorSize] = LSH_ACCEPTABLE_HASH_SIZES.reduce((obj, hashSize) => ((obj[hashSize] = [0, 1, 2].reduce((obj, level) => ((obj[level] =\n                  importShader('keypoints/lsh-knn.glsl')\n                  .withDefines({\n                      'DESCRIPTOR_SIZE': descriptorSize,\n                      'HASH_SIZE': hashSize,\n                      'LEVEL': level,\n                      'SEQUENCE_MAXLEN': LSH_SEQUENCE_MAXLEN,\n                      'SEQUENCE_COUNT': LSH_SEQUENCE_COUNT,\n                  })\n                  .withArguments('candidates', 'filters', 'matcherLength', 'tables', 'descriptorDB', 'tableIndex', 'bucketCapacity', 'bucketsPerTable', 'tablesStride', 'descriptorDBStride', 'encodedKeypoints', 'descriptorSize', 'extraSize', 'encoderLength')\n              ), obj), {})), obj), {})), obj), {});\n\nconst lshKnnTransfer = importShader('keypoints/knn-transfer.glsl')\n                       .withArguments('encodedMatches', 'encodedKthMatches', 'numberOfMatchesPerKeypoint', 'kthMatch');\n\n// Keypoint sorting\nconst sortCreatePermutation = importShader('keypoints/sort-keypoints.glsl')\n                             .withDefines({ 'STAGE': 1 })\n                             .withArguments('encodedKeypoints', 'descriptorSize', 'extraSize', 'encoderLength');\n\nconst sortMergePermutation = importShader('keypoints/sort-keypoints.glsl')\n                            .withDefines({ 'STAGE': 2 })\n                            .withArguments('permutation', 'blockSize', 'dblLog2BlockSize');\n\nconst sortApplyPermutation = importShader('keypoints/sort-keypoints.glsl')\n                            .withDefines({ 'STAGE': 3 })\n                            .withArguments('permutation', 'maxKeypoints', 'encodedKeypoints', 'descriptorSize', 'extraSize');\n\n// Keypoint mixing\nconst mixKeypointsPreInit = importShader('keypoints/mix-keypoints.glsl')\n                           .withDefines({ 'STAGE': 1 })\n                           .withArguments('encodedKeypointsA', 'encodedKeypointsB', 'encoderLengthA', 'encoderLengthB', 'encoderCapacityA', 'encoderCapacityB', 'descriptorSize', 'extraSize', 'encoderLength');\n\nconst mixKeypointsInit = importShader('keypoints/mix-keypoints.glsl')\n                        .withDefines({ 'STAGE': 2 })\n                        .withArguments('encodedKeypoints', 'descriptorSize', 'extraSize', 'encoderLength', 'maxKeypoints');\n\nconst mixKeypointsSort = importShader('keypoints/mix-keypoints.glsl')\n                        .withDefines({ 'STAGE': 3 })\n                        .withArguments('array', 'blockSize');\n\nconst mixKeypointsView = importShader('keypoints/mix-keypoints.glsl')\n                        .withDefines({ 'STAGE': 5 })\n                        .withArguments('array');\n\nconst mixKeypointsApply = importShader('keypoints/mix-keypoints.glsl')\n                         .withDefines({ 'STAGE': 4 })\n                         .withArguments('array', 'encodedKeypoints', 'descriptorSize', 'extraSize', 'encoderLength');\n\n// Keypoint encoding\nconst initLookupTable = importShader('keypoints/lookup-of-locations.glsl')\n                       .withDefines({ 'FS_OUTPUT_TYPE': 2, 'STAGE': 1 })\n                       .withArguments('corners');\n\nconst sortLookupTable = importShader('keypoints/lookup-of-locations.glsl', 'keypoints/lookup-of-locations.vs.glsl')\n                       .withDefines({ 'FS_OUTPUT_TYPE': 2, 'FS_USE_CUSTOM_PRECISION': 1, 'STAGE': 2 })\n                       .withArguments('lookupTable', 'blockSize', 'width', 'height');\n\nconst viewLookupTable = importShader('keypoints/lookup-of-locations.glsl')\n                       .withDefines({ 'STAGE': -1 })\n                       .withArguments('lookupTable');\n\nconst encodeKeypoints = importShader('keypoints/encode-keypoints.glsl')\n                       .withArguments('corners', 'lookupTable', 'stride', 'descriptorSize', 'extraSize', 'encoderLength', 'encoderCapacity');\n\nconst encodeKeypointSkipOffsets = importShader('keypoints/encode-keypoint-offsets.glsl')\n                                 .withArguments('corners', 'imageSize');\n\nconst encodeKeypointLongSkipOffsets = importShader('keypoints/encode-keypoint-long-offsets.glsl')\n                                     .withDefines({ 'MAX_ITERATIONS': 6 }) // dependent texture reads :(\n                                     .withArguments('offsetsImage', 'imageSize');\n\nconst encodeKeypointPositions = importShader('keypoints/encode-keypoint-positions.glsl')\n                               .withArguments('offsetsImage', 'imageSize', 'passId', 'numPasses', 'keypointLimit', 'encodedKeypoints', 'descriptorSize', 'extraSize', 'encoderLength');\n\nconst encodeKeypointProperties = importShader('keypoints/encode-keypoint-properties.glsl')\n                                .withArguments('corners', 'encodedKeypoints', 'descriptorSize', 'extraSize', 'encoderLength');\n\nconst encodeNullKeypoints = importShader('keypoints/encode-null-keypoints.glsl')\n                           .withArguments();\n\nconst transferOrientation = importShader('keypoints/transfer-orientation.glsl')\n                           .withArguments('encodedOrientations', 'encodedKeypoints', 'descriptorSize', 'extraSize', 'encoderLength');\n\nconst uploadKeypoints = importShader('keypoints/upload-keypoints.glsl')\n                       .withDefines({\n                            // UBOs can hold at least 16KB of data;\n                            // gl.MAX_UNIFORM_BLOCK_SIZE >= 16384\n                            // according to the GL ES 3 reference.\n                            // Each keypoint uses 16 bytes (vec4)\n                           'BUFFER_SIZE': 1024 //16384 / 16\n                        })\n                       .withArguments('encodedKeypoints', 'startIndex', 'endIndex', 'descriptorSize', 'extraSize', 'encoderLength');\n\n// Geometric transformations\nconst applyHomography = importShader('keypoints/apply-homography.glsl')\n                        .withArguments('homography', 'encodedKeypoints', 'descriptorSize', 'extraSize', 'encoderLength');\n\n// Keypoint filters\nconst clipBorder = importShader('keypoints/clip-border.glsl')\n                  .withArguments('imageWidth', 'imageHeight', 'borderTop', 'borderRight', 'borderBottom', 'borderLeft', 'encodedKeypoints', 'descriptorSize', 'extraSize', 'encoderLength');\n\nconst distanceFilter = importShader('keypoints/distance-filter.glsl')\n                      .withArguments('encodedKeypointsA', 'encoderLengthA', 'encodedKeypointsB', 'encoderLengthB', 'descriptorSize', 'extraSize', 'encoderLength', 'threshold');\n\nconst hammingDistanceFilter32 = importShader('keypoints/hamming-distance-filter.glsl')\n                               .withDefines({ 'DESCRIPTOR_SIZE': 32 })\n                               .withArguments('encodedKeypointsA', 'encoderLengthA', 'encodedKeypointsB', 'encoderLengthB', 'descriptorSize', 'extraSize', 'encoderLength', 'threshold');\n\nconst hammingDistanceFilter64 = importShader('keypoints/hamming-distance-filter.glsl')\n                               .withDefines({ 'DESCRIPTOR_SIZE': 64 })\n                               .withArguments('encodedKeypointsA', 'encoderLengthA', 'encodedKeypointsB', 'encoderLengthB', 'descriptorSize', 'extraSize', 'encoderLength', 'threshold');\n\n// Other utilities\nconst shuffle = importShader('keypoints/shuffle.glsl')\n               .withDefines({ 'PERMUTATION_MAXLEN': 2048 })\n               .withArguments('encodedKeypoints', 'descriptorSize', 'extraSize', 'encoderLength');\n\nconst clip = importShader('keypoints/clip.glsl')\n            .withArguments('encodedKeypoints', 'descriptorSize', 'extraSize', 'encoderLength', 'maxKeypoints');\n\n/**\n * SpeedyProgramGroupKeypoints\n * Keypoint detection\n */\nexport class SpeedyProgramGroupKeypoints extends SpeedyProgramGroup\n{\n    /**\n     * Class constructor\n     * @param {SpeedyGPU} gpu\n     */\n    constructor(gpu)\n    {\n        super(gpu);\n        this\n            //\n            // FAST corner detector\n            //\n            .declare('fast9_16', fast9_16, {\n                ...this.program.usesPingpongRendering()\n            })\n\n            //\n            // Harris corner detector\n            //\n            .declare('harris1', harris[1], {\n                ...this.program.usesPingpongRendering()\n            })\n            .declare('harris3', harris[3], {\n                ...this.program.usesPingpongRendering()\n            })\n            .declare('harris5', harris[5], {\n                ...this.program.usesPingpongRendering()\n            })\n            .declare('harris7', harris[7], {\n                ...this.program.usesPingpongRendering()\n            })\n            .declare('harrisScoreFindMax', harrisScoreFindMax, {\n                ...this.program.usesPingpongRendering()\n            })\n            .declare('harrisScoreCutoff', harrisScoreCutoff)\n\n            //\n            // Subpixel refinement\n            //\n            .declare('subpixelQuadratic1d', subpixelQuadratic1d)\n            .declare('subpixelTaylor2d', subpixelTaylor2d)\n            .declare('subpixelBicubic', subpixelBicubic)\n            .declare('subpixelBilinear', subpixelBilinear)\n\n            //\n            // Scale refinement\n            //\n            .declare('refineScaleLoG', refineScaleLoG)\n            .declare('refineScaleFAST916', refineScaleFAST916)\n\n            //\n            // Pixel allocation\n            //\n            .declare('allocateDescriptors', allocateDescriptors)\n            .declare('allocateExtra', allocateExtra)\n            .declare('transferToExtra', transferToExtra)\n\n            //\n            // ORB descriptors\n            //\n            .declare('orbDescriptor', orbDescriptor)\n            .declare('orbOrientation', orbOrientation)\n\n            //\n            // Non-maximum suppression\n            //\n            .declare('nonmax', nonMaxSuppression)\n            .declare('pyrnonmax', multiscaleNonMaxSuppression)\n            .declare('nonmaxSpace', nonmaxSpace)\n            .declare('nonmaxScale', nonmaxScale)\n            .declare('nonmaxScaleSimple', nonmaxScaleSimple)\n            .declare('laplacian', laplacian)\n\n            //\n            // LK optical-flow\n            //\n            .declare('lk21', lk[21], {\n                ...this.program.usesPingpongRendering()\n            })\n            .declare('lk19', lk[19], {\n                ...this.program.usesPingpongRendering()\n            })\n            .declare('lk17', lk[17], {\n                ...this.program.usesPingpongRendering()\n            })\n            .declare('lk15', lk[15], {\n                ...this.program.usesPingpongRendering()\n            })\n            .declare('lk13', lk[13], {\n                ...this.program.usesPingpongRendering()\n            })\n            .declare('lk11', lk[11], {\n                ...this.program.usesPingpongRendering()\n            })\n            .declare('lk9', lk[9], {\n                ...this.program.usesPingpongRendering()\n            })\n            .declare('lk7', lk[7], {\n                ...this.program.usesPingpongRendering()\n            })\n            .declare('lk5', lk[5], {\n                ...this.program.usesPingpongRendering()\n            })\n            .declare('lk3', lk[3], {\n                ...this.program.usesPingpongRendering()\n            })\n            .declare('transferFlow', transferFlow)\n\n            //\n            // Brute-force KNN matching\n            //\n            .declare('bfMatcherInitCandidates', bfMatcherInitCandidates)\n            .declare('bfMatcherInitFilters', bfMatcherInitFilters)\n            .declare('bfMatcherTransfer', bfMatcherTransfer, {\n                ...this.program.usesPingpongRendering()\n            })\n            .declare('bfMatcher32', bfMatcher32, {\n                ...this.program.usesPingpongRendering()\n            })\n            .declare('bfMatcher64', bfMatcher64, {\n                ...this.program.usesPingpongRendering()\n            })\n\n            //\n            // LSH-based KNN matching\n            //\n            .declare('lshKnnInitCandidates', lshKnnInitCandidates)\n            .declare('lshKnnInitFilters', lshKnnInitFilters)\n            .declare('lshKnnTransfer', lshKnnTransfer, {\n                ...this.program.usesPingpongRendering()\n            })\n\n            //\n            // Keypoint sorting\n            //\n            .declare('sortCreatePermutation', sortCreatePermutation)\n            .declare('sortMergePermutation', sortMergePermutation, {\n                ...this.program.usesPingpongRendering()\n            })\n            .declare('sortApplyPermutation', sortApplyPermutation)\n\n            //\n            // Keypoint mixing\n            //\n            .declare('mixKeypointsPreInit', mixKeypointsPreInit)\n            .declare('mixKeypointsInit', mixKeypointsInit)\n            .declare('mixKeypointsSort', mixKeypointsSort, {\n                ...this.program.usesPingpongRendering()\n            })\n            .declare('mixKeypointsView', mixKeypointsView)\n            .declare('mixKeypointsApply', mixKeypointsApply)\n\n            //\n            // Keypoint encoders\n            //\n            .declare('encodeNullKeypoints', encodeNullKeypoints)\n            .declare('encodeKeypoints', encodeKeypoints)\n            .declare('initLookupTable', initLookupTable)\n            .declare('sortLookupTable', sortLookupTable, {\n                ...this.program.usesPingpongRendering()\n            })\n            .declare('viewLookupTable', viewLookupTable)\n\n\n            .declare('encodeKeypointSkipOffsets', encodeKeypointSkipOffsets)\n            .declare('encodeKeypointLongSkipOffsets', encodeKeypointLongSkipOffsets, {\n                ...this.program.usesPingpongRendering()\n            })\n            .declare('encodeKeypointPositions', encodeKeypointPositions, {\n                ...this.program.usesPingpongRendering()\n            })\n            .declare('encodeKeypointProperties', encodeKeypointProperties)\n\n\n\n            .declare('transferOrientation', transferOrientation)\n            .declare('uploadKeypoints', uploadKeypoints, {\n                ...this.program.usesPingpongRendering()\n            })\n\n            //\n            // Geometric transformations\n            //\n            .declare('applyHomography', applyHomography)\n\n            //\n            // Keypoint filters\n            //\n            .declare('clipBorder', clipBorder)\n            .declare('distanceFilter', distanceFilter)\n            .declare('hammingDistanceFilter32', hammingDistanceFilter32)\n            .declare('hammingDistanceFilter64', hammingDistanceFilter64)\n\n            //\n            // Other utilities\n            //\n            .declare('shuffle', shuffle)\n            .declare('clip', clip)\n        ;\n\n        //\n        // LSH-based KNN matching\n        //\n        for(const descriptorSize of Object.keys(lshKnn)) {\n            for(const hashSize of Object.keys(lshKnn[descriptorSize])) {\n                for(const level of Object.keys(lshKnn[descriptorSize][hashSize])) {\n                    const name = `lshKnn${descriptorSize}h${hashSize}lv${level}`;\n                    this.declare(name, lshKnn[descriptorSize][hashSize][level], {\n                        ...this.program.usesPingpongRendering()\n                    });\n                }\n            }\n        }\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * pyramids.js\n * Image pyramids\n */\n\nimport { SpeedyGPU } from '../speedy-gpu';\nimport { SpeedyProgramGroup } from '../speedy-program-group';\nimport { SpeedyTexture, SpeedyDrawableTexture } from '../speedy-texture';\nimport { importShader } from '../shader-declaration';\nimport { convX, convY, conv2D } from '../shaders/filters/convolution';\n\n\n\n//\n// Shaders\n//\n\nconst upsample2 = importShader('pyramids/upsample2.glsl').withArguments('image');\nconst downsample2 = importShader('pyramids/downsample2.glsl').withArguments('image');\n\n\n/**\n * SpeedyProgramGroupPyramids\n * Image pyramids\n */\nexport class SpeedyProgramGroupPyramids extends SpeedyProgramGroup\n{\n    /**\n     * Class constructor\n     * @param {SpeedyGPU} gpu\n     */\n    constructor(gpu)\n    {\n        super(gpu);\n        this\n            // upsampling & downsampling\n            .declare('upsample2', upsample2)\n            .declare('downsample2', downsample2)\n\n            // separable kernels for gaussian smoothing\n            // use [c, b, a, b, c] where a+2c = 2b and a+2b+2c = 1\n            // pick a = 0.4 for gaussian approximation (sigma = 1)\n            .declare('smoothX', convX([\n                0.05, 0.25, 0.4, 0.25, 0.05\n            ]))\n            .declare('smoothY', convY([\n                0.05, 0.25, 0.4, 0.25, 0.05\n            ]))\n            /*\n            .declare('reduce', conv2D([\n                0.00250, 0.01250, 0.02000, 0.01250, 0.00250,\n                0.01250, 0.06250, 0.10000, 0.06250, 0.01250,\n                0.02000, 0.10000, 0.16000, 0.10000, 0.02000,\n                0.01250, 0.06250, 0.10000, 0.06250, 0.01250,\n                0.00250, 0.01250, 0.02000, 0.01250, 0.00250\n            ]))\n            */\n\n            // smoothing for 2x image\n            // same rules as above with sum(k) = 2\n            .declare('smoothX2', convX([\n                0.1, 0.5, 0.8, 0.5, 0.1\n                // NOTE: this would saturate the image, but we apply it\n                // on a 2x upsampled version with lots of zero pixels\n            ]))\n            .declare('smoothY2', convY([\n                0.1, 0.5, 0.8, 0.5, 0.1\n            ], 1.0 / 2.0))\n        ;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * transforms.js\n * Geometric transformations\n */\n\nimport { SpeedyGPU } from '../speedy-gpu';\nimport { SpeedyProgramGroup } from '../speedy-program-group';\nimport { importShader } from '../shader-declaration';\nimport { IllegalArgumentError } from '../../utils/errors';\n\n\n\n//\n// Shaders\n//\n\n// Perspective warp\nconst warpPerspective = importShader('transforms/warp-perspective.glsl')\n                        .withArguments('image', 'inverseHomography');\n\n// Resize image\nconst resizeNearest = importShader('transforms/resize.glsl')\n                     .withDefines({\n                         'INTERPOLATION_METHOD': 0 // Nearest neighbors\n                     })\n                     .withArguments('image');\n\nconst resizeBilinear = importShader('transforms/resize.glsl')\n                      .withDefines({\n                          'INTERPOLATION_METHOD': 1 // Bilinear interpolation\n                      })\n                      .withArguments('image');\n\n// Additive mix (TODO create a new program group?)\nconst additiveMix = importShader('transforms/additive-mix.glsl')\n                    .withArguments('image0', 'image1', 'alpha', 'beta', 'gamma');\n\n/**\n * SpeedyProgramGroupTransforms\n * Geometric transformations\n */\nexport class SpeedyProgramGroupTransforms extends SpeedyProgramGroup\n{\n    /**\n     * Class constructor\n     * @param {SpeedyGPU} gpu\n     */\n    constructor(gpu)\n    {\n        super(gpu);\n        this\n            .declare('warpPerspective', warpPerspective)\n            .declare('resizeNearest', resizeNearest)\n            .declare('resizeBilinear', resizeBilinear)\n            .declare('additiveMix', additiveMix)\n        ;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * utils.js\n * GPU utilities\n */\n\nimport { SpeedyGPU } from '../speedy-gpu';\nimport { SpeedyProgramGroup } from '../speedy-program-group';\nimport { SpeedyTexture, SpeedyDrawableTexture } from '../speedy-texture';\nimport { importShader } from '../shader-declaration';\nimport { Utils } from '../../utils/utils';\n\n\n\n//\n// Shaders\n//\n\n// Copy image\nconst copy = importShader('utils/copy.glsl').withArguments('image');\n\n// Copy keypoints\nconst copyKeypoints = importShader('utils/copy-raster.glsl').withDefines({ 'TYPE': 1 }).withArguments('image');\n\n// Copy 2D vectors\nconst copy2DVectors = importShader('utils/copy-raster.glsl').withDefines({ 'TYPE': 2 }).withArguments('image');\n\n// Flip y-axis for output\nconst flipY = importShader('utils/copy.glsl', 'utils/flip-y.vs.glsl').withArguments('image');\n\n// Fill image with a constant\nconst fill = importShader('utils/fill.glsl').withArguments('value');\n\n// Fill zero or more color components of the input image with a constant value\nconst fillComponents = importShader('utils/fill-components.glsl').withArguments('image', 'pixelComponents', 'value');\n\n// Copy the src component of src to zero or more color components of a copy of dest\nconst copyComponents = importShader('utils/copy-components.glsl').withArguments('dest', 'src', 'destComponents', 'srcComponentId');\n\n// Scan the entire image and find the minimum & maximum pixel intensity\nconst scanMinMax2D = importShader('utils/scan-minmax2d.glsl').withArguments('image', 'iterationNumber');\n\n// Compute the partial derivatives of an image\nconst sobelDerivatives = importShader('utils/sobel-derivatives.glsl', 'utils/sobel-derivatives.vs.glsl').withArguments('pyramid', 'lod');\n\n\n\n\n/**\n * SpeedyProgramGroupUtils\n * Utility operations\n */\nexport class SpeedyProgramGroupUtils extends SpeedyProgramGroup\n{\n    /**\n     * Class constructor\n     * @param {SpeedyGPU} gpu\n     */\n    constructor(gpu)\n    {\n        super(gpu);\n        this\n            // render to the canvas\n            .declare('renderToCanvas', flipY, {\n                ...this.program.rendersToCanvas()\n            })\n\n            // copy image\n            .declare('copy', copy)\n\n            // copy keypoints\n            .declare('copyKeypoints', copyKeypoints)\n\n            // copy 2D vectors\n            .declare('copy2DVectors', copy2DVectors)\n\n            // Fill image with a constant\n            .declare('fill', fill)\n\n            // Fill zero or more color components of the input image with a constant value\n            .declare('fillComponents', fillComponents)\n\n            // Copy the src component of src to zero or more color components of a copy of dest\n            .declare('copyComponents', copyComponents)\n\n            // find minimum & maximum pixel intensity\n            .declare('scanMinMax2D', scanMinMax2D, {\n                ...this.program.usesPingpongRendering()\n            })\n\n            // Compute the partial derivatives of an image\n            .declare('sobelDerivatives', sobelDerivatives)\n        ;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * shader-declaration.js\n * Encapsulates a shader declaration\n */\n\nimport { ShaderPreprocessor } from './shader-preprocessor';\nimport { FileNotFoundError, IllegalArgumentError, IllegalOperationError, ParseError } from '../utils/errors';\n\nconst DEFAULT_ATTRIBUTES = Object.freeze({\n    position: 'a_position',\n    texCoord: 'a_texCoord'\n});\n\nconst DEFAULT_ATTRIBUTES_LOCATION = Object.freeze({\n    position: 0, // use location 0; see https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices\n    texCoord: 1,\n});\n\nconst DEFAULT_VERTEX_SHADER_PREFIX = `#version 300 es\nprecision highp float;\nprecision highp int;\n\nlayout (location=${DEFAULT_ATTRIBUTES_LOCATION.position}) in vec2 ${DEFAULT_ATTRIBUTES.position};\nlayout (location=${DEFAULT_ATTRIBUTES_LOCATION.texCoord}) in vec2 ${DEFAULT_ATTRIBUTES.texCoord};\nout highp vec2 texCoord;\nuniform highp vec2 texSize;\n\n#define vsinit() \\\ngl_Position = vec4(${DEFAULT_ATTRIBUTES.position}, 0.0f, 1.0f); \\\ntexCoord = ${DEFAULT_ATTRIBUTES.texCoord};\n\\n\\n`;\n\nconst DEFAULT_VERTEX_SHADER = `#define vsmain() ;`;\n\nconst DEFAULT_VERTEX_SHADER_SUFFIX = `\\n\\nvoid main() { vsinit(); vsmain(); }\\n`;\n\nconst DEFAULT_FRAGMENT_SHADER_PREFIX = `#version 300 es\n\n#if @FS_USE_CUSTOM_PRECISION@ == 0\nprecision mediump float; // ~float16\nprecision mediump sampler2D;\nprecision highp int; // int32\n#endif\n\n#if @FS_OUTPUT_TYPE@ == 0\n#define OUT_TYPE mediump vec4\n#elif @FS_OUTPUT_TYPE@ == 1\n#define OUT_TYPE mediump ivec4\n#elif @FS_OUTPUT_TYPE@ == 2\n#define OUT_TYPE mediump uvec4\n#else\n#error Unknown FS_OUTPUT_TYPE\n#endif\n\nout OUT_TYPE color;\nin highp vec2 texCoord;\nuniform highp vec2 texSize;\n\n@include \"global.glsl\"\\n\\n`;\n\nconst PRIVATE_TOKEN = Symbol();\n\n/**\n * @typedef {object} ShaderDeclarationFilepathOptions\n * @property {\"filepath\"} type\n * @property {string} filepath\n * @property {string} [vsfilepath]\n *\n * @typedef {object} ShaderDeclarationSourceOptions\n * @property {\"source\"} type\n * @property {string} source\n * @property {string} [vssource]\n *\n * @typedef {ShaderDeclarationFilepathOptions | ShaderDeclarationSourceOptions} ShaderDeclarationOptions\n */\n\n/** @typedef {import('./shader-preprocessor').ShaderDefines} ShaderDefines */\n\n/**\n * Shader Declaration\n */\nexport class ShaderDeclaration\n{\n    /**\n     * @private Constructor\n     * @param {ShaderDeclarationOptions} options\n     * @param {Symbol} privateToken\n     */\n    constructor(options, privateToken)\n    {\n        if(privateToken !== PRIVATE_TOKEN)\n            throw new IllegalOperationError(); // private constructor!\n\n        /** @type {string} original source code provided by the user (fragment shader) */\n        this._source = (() => {\n            switch(options.type) {\n                case 'filepath': return require('./shaders/' + options.filepath);\n                case 'source':   return options.source;\n                default:         return /** @type {never} */ ( '' );\n             }\n        })();\n\n        /** @type {string} vertex shader source code (without preprocessing) */\n        this._vssource = (() => {\n            switch(options.type) {\n                case 'filepath': return options.vsfilepath ? require('./shaders/' + options.vsfilepath) : DEFAULT_VERTEX_SHADER;\n                case 'source':   return options.vssource ? options.vssource : DEFAULT_VERTEX_SHADER;\n                default:         return /** @type {never} */ ( '' );\n             }\n        })();\n\n        /** @type {string} preprocessed source code of the fragment shader */\n        this._fragmentSource = ShaderPreprocessor.run(DEFAULT_FRAGMENT_SHADER_PREFIX + this._source);\n\n        /** @type {string} preprocessed source code of the vertex shader */\n        this._vertexSource = ShaderPreprocessor.run(DEFAULT_VERTEX_SHADER_PREFIX + this._vssource + DEFAULT_VERTEX_SHADER_SUFFIX);\n\n        /** @type {string} filepath of the fragment shader */\n        this._filepath = options.type === 'filepath' ? options.filepath : '<in-memory>';\n\n        /** @type {string} filepath of the vertex shader */\n        this._vsfilepath = options.type === 'filepath' && options.vsfilepath ? options.vsfilepath : '<in-memory>';\n\n        /** @type {string[]} an ordered list of uniform names */\n        this._arguments = [];\n\n        /** @type {Map<string,string>} it maps uniform names to their types */\n        this._uniforms = this._autodetectUniforms(this._fragmentSource + '\\n' + this._vertexSource);\n\n        /** @type {ShaderDefines} it maps externally #defined constants to their values */\n        this._defines = new Map();\n    }\n\n    /**\n     * Creates a new Shader directly from a GLSL source\n     * @param {string} source fragment shader\n     * @param {string|null} [vssource] vertex shader\n     * @returns {ShaderDeclaration}\n     */\n    static create(source, vssource = null)\n    {\n        return new ShaderDeclaration({ type: 'source', source, vssource }, PRIVATE_TOKEN);\n    }\n\n    /**\n     * Import a Shader from a file containing a GLSL source\n     * @param {string} filepath path to .glsl file relative to the shaders/ folder\n     * @param {string} [vsfilepath] path to a .vs.glsl file relative to the shaders/ folder\n     * @returns {ShaderDeclaration}\n     */\n    static import(filepath, vsfilepath = null)\n    {\n        if(!String(filepath).match(/^[a-zA-Z0-9_\\-/]+\\.glsl$/))\n            throw new FileNotFoundError(`Can't import fragment shader at \"${filepath}\"`);\n        else if(vsfilepath != null && !String(vsfilepath).match(/^[a-zA-Z0-9_\\-/]+\\.vs\\.glsl$/))\n            throw new FileNotFoundError(`Can't import vertex shader at \"${vsfilepath}\"`);\n\n        return new ShaderDeclaration({ type: 'filepath', filepath, vsfilepath }, PRIVATE_TOKEN);\n    }\n\n    /**\n     * Specify the list & order of arguments to be\n     * passed to the shader\n     * @param  {...string} args argument names\n     * @returns {this}\n     */\n    withArguments(...args)\n    {\n        // the list of arguments may be declared only once\n        if(this._arguments.length > 0)\n            throw new IllegalOperationError(`Redefinition of shader arguments`);\n\n        // get arguments\n        this._arguments = args.map(arg => String(arg));\n\n        // validate\n        for(const argname of this._arguments) {\n            if(!this._uniforms.has(argname)) {\n                if(!this._uniforms.has(argname + '[0]'))\n                    throw new IllegalArgumentError(`Argument \"${argname}\" has not been declared in the shader`);\n            }\n        }\n\n        // done!\n        return this;\n    }\n\n    /**\n     * Specify a set of #defines to be prepended to the fragment shader\n     * @param {Object<string,number>} defines key-value pairs (define-name: define-value)\n     * @returns {this}\n     */\n    withDefines(defines)\n    {\n        // the list of #defines may be defined only once\n        if(this._defines.size > 0)\n            throw new IllegalOperationError(`Redefinition of externally defined constants of a shader`);\n\n        // store and write the #defines\n        const defs = [], keys = Object.keys(defines);\n        for(const key of keys) {\n            const value = Number(defines[key]); // force numeric values (just in case)\n            this._defines.set(key, value);\n            defs.push(`#define ${key} ${value}\\n`);\n        }\n\n        // update the shaders & the uniforms\n        const source = DEFAULT_FRAGMENT_SHADER_PREFIX + defs.join('') + this._source;\n        const vssource = DEFAULT_VERTEX_SHADER_PREFIX + defs.join('') + this._vssource + DEFAULT_VERTEX_SHADER_SUFFIX;\n        this._fragmentSource = ShaderPreprocessor.run(source, this._defines);\n        this._vertexSource = ShaderPreprocessor.run(vssource, this._defines);\n        this._uniforms = this._autodetectUniforms(this._fragmentSource + '\\n' + this._vertexSource);\n\n        // done!\n        return this;\n    }\n\n    /**\n     * Return the GLSL source of the fragment shader\n     * @returns {string}\n     */\n    get fragmentSource()\n    {\n        return this._fragmentSource;\n    }\n\n    /**\n     * Return the GLSL source of the vertex shader\n     * @returns {string}\n     */\n    get vertexSource()\n    {\n        return this._vertexSource;\n    }\n\n    /**\n     * Get the names of the vertex shader attributes\n     * @returns {typeof DEFAULT_ATTRIBUTES}\n     */\n    get attributes()\n    {\n        return DEFAULT_ATTRIBUTES;\n    }\n\n    /**\n     * Get the pre-defined locations of the vertex shader attributes\n     * @returns {typeof DEFAULT_ATTRIBUTES_LOCATION}\n     */\n    get locationOfAttributes()\n    {\n        return DEFAULT_ATTRIBUTES_LOCATION;\n    }\n\n    /**\n     * Names of the arguments that will be passed to the Shader,\n     * corresponding to GLSL uniforms, in the order they will be passed\n     * @returns {string[]}\n     */\n    get arguments()\n    {\n        return this._arguments;\n    }\n\n    /**\n     * Names of the uniforms declared in the shader\n     * @returns {string[]}\n     */\n    get uniforms()\n    {\n        return Array.from(this._uniforms.keys());\n    }\n\n    /**\n     * The GLSL type of a uniform variable declared in the shader\n     * @param {string} name\n     * @returns {string}\n     */\n    uniformType(name)\n    {\n        if(!this._uniforms.has(name))\n            throw new IllegalArgumentError(`Unrecognized uniform variable: \"${name}\"`);\n\n        return this._uniforms.get(name);\n    }\n\n    /**\n     * The value of an externally defined constant, i.e., via withDefines()\n     * @param {string} name \n     * @returns {number}\n     */\n    definedConstant(name)\n    {\n        if(!this._defines.has(name))\n            throw new IllegalArgumentError(`Unrecognized externally defined constant: \"${name}\"`);\n\n        return this._defines.get(name);\n    }\n\n    /**\n     * Parses a GLSL source and detects the uniform variables,\n     * as well as their types\n     * @param {string} preprocessedSource \n     * @returns {Map<string,string>} specifies the types of all uniforms\n     */\n    _autodetectUniforms(preprocessedSource)\n    {\n        const sourceWithoutComments = preprocessedSource; // assume we've preprocessed the source already\n        const regex = /^\\s*uniform\\s+(highp\\s+|mediump\\s+|lowp\\s+)?(\\w+)\\s+([^;]+)/gm;\n        const uniforms = new Map();\n\n        let match;\n        while((match = regex.exec(sourceWithoutComments)) !== null) {\n            const type = match[2];\n            const names = match[3].split(',').map(name => name.trim()).filter(name => name); // trim & remove empty names\n\n            for(const name of names) {\n                if(name.endsWith(']')) {\n                    // is it an array?\n                    if(!(match = name.match(/(\\w+)\\s*\\[\\s*(\\d+)\\s*\\]$/)))\n                        throw new ParseError(`Unspecified array length for uniform \"${name}\" in the shader`);\n\n                    // read array name & size\n                    const [ array, size ] = [ match[1], Number(match[2]) ];\n\n                    // register uniforms\n                    for(let i = 0; i < size; i++)\n                        uniforms.set(`${array}[${i}]`, type);\n                }\n                else {\n                    // register a regular uniform\n                    if(!uniforms.has(name) || uniforms.get(name) === type)\n                        uniforms.set(name, type);\n                    else\n                        throw new IllegalOperationError(`Redefinition of uniform \"${name}\" in the shader`);\n                }\n            }\n        }\n\n        return uniforms;\n    }\n}\n\n/**\n * Import a ShaderDeclaration from a GLSL file\n * @param {string} filepath relative to the shaders/ folder (a .glsl file)\n * @param {string|null} [vsfilepath] optional vertex shader (a .vs.glsl file)\n * @returns {ShaderDeclaration}\n */\nexport function importShader(filepath, vsfilepath = null)\n{\n    return ShaderDeclaration.import(filepath, vsfilepath);\n}\n\n/**\n * Create a ShaderDeclaration from a GLSL source code\n * @param {string} source fragment shader\n * @param {string|null} [vssource] optional vertex shader\n * @returns {ShaderDeclaration}\n */\nexport function createShader(source, vssource = null)\n{\n    return ShaderDeclaration.create(source, vssource);\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * shader-preprocessor.js\n * Custom preprocessor for shaders\n */\n\nimport { Utils } from '../utils/utils';\nimport { PixelComponent } from '../utils/types';\nimport { FileNotFoundError, ParseError } from '../utils/errors';\n\n// Import numeric globals\nconst globals = require('../utils/globals');\nconst numericGlobals = Object.keys(globals).filter(key => typeof globals[key] == 'number').reduce(\n    (obj, key) => ((obj[key] = globals[key]), obj), {}\n);\n\n// Constants accessible by all shaders\nconst constants = Object.freeze({\n    // numeric globals\n    ...numericGlobals,\n\n    // fragment shader\n    'FS_USE_CUSTOM_PRECISION': 0, // use default precision settings\n    'FS_OUTPUT_TYPE': 0, // normalized RGBA\n\n    // colors\n    'PIXELCOMPONENT_RED': PixelComponent.RED,\n    'PIXELCOMPONENT_GREEN': PixelComponent.GREEN,\n    'PIXELCOMPONENT_BLUE': PixelComponent.BLUE,\n    'PIXELCOMPONENT_ALPHA': PixelComponent.ALPHA,\n});\n\n// Regular Expressions\nconst commentsRegex = [ /\\/\\*(.|\\s)*?\\*\\//g , /\\/\\/.*$/gm ];\nconst includeRegex = /^\\s*@\\s*include\\s+\"(.*?)\"/gm;\nconst constantRegex = /@(\\w+)@/g;\nconst unrollRegex = [\n    /@\\s*unroll\\s+?for\\s*\\(\\s*(int|)\\s*(?<counter>\\w+)\\s*=\\s*(-?\\d+|\\w+)\\s*;\\s*\\k<counter>\\s*(<=?)\\s*(-?\\d+|\\w+)\\s*;\\s*\\k<counter>\\s*\\+\\+()\\s*\\)\\s*\\{\\s*([\\s\\S]+?)\\s*\\}/g,\n    /@\\s*unroll\\s+?for\\s*\\(\\s*(int|)\\s*(?<counter>\\w+)\\s*=\\s*(-?\\d+|\\w+)\\s*;\\s*\\k<counter>\\s*(<=?)\\s*(-?\\d+|\\w+)\\s*;\\s*\\k<counter>\\s*\\+=\\s*(-?\\d+)\\s*\\)\\s*\\{\\s*([\\s\\S]+?)\\s*\\}/g,\n];\n\n/** @typedef {Map<string,number>} ShaderDefines */\n\n/**\n * Custom preprocessor for the shaders\n */\nexport class ShaderPreprocessor\n{\n    /**\n     * Runs the preprocessor\n     * @param {string} code \n     * @param {ShaderDefines} [defines]\n     * @returns {string} preprocessed code\n     */\n    static run(code, defines = new Map())\n    {\n        const errors = []; // compile-time errors\n\n        //\n        // The preprocessor will remove comments from GLSL code,\n        // include requested GLSL files and import global constants\n        // defined for all shaders (see above)\n        //\n        return unrollLoops(\n            String(code)\n                .replace(commentsRegex[0], '')\n                .replace(commentsRegex[1], '')\n                .replace(includeRegex, (_, filename) =>\n                    // FIXME: no cycle detection for @include\n                    ShaderPreprocessor.run(readfileSync(filename), defines)\n                )\n                .replace(constantRegex, (_, name) => String(\n                    // Find a defined constant. If not possible, find a global constant\n                    defines.has(name) ? Number(defines.get(name)) : (\n                        constants[name] !== undefined ? Number(constants[name]) : (\n                            errors.push(`Undefined constant: ${name}`), 0\n                        )\n                    )\n                )),\n            defines\n        ) + (errors.length > 0 ? errors.map(msg => `\\n#error ${msg}\\n`).join('') : '');\n    }\n}\n\n /**\n * Reads a shader from the shaders/include/ folder\n * @param {string} filename\n * @returns {string}\n */\nfunction readfileSync(filename)\n{\n    if(String(filename).match(/^[a-zA-Z0-9_-]+\\.glsl$/))\n        return require('./shaders/include/' + filename);\n\n    throw new FileNotFoundError(`Shader preprocessor: can't read file \"${filename}\"`);\n}\n\n/**\n * Unroll for loops in our own preprocessor\n * @param {string} code\n * @param {ShaderDefines} defines\n * @returns {string}\n */\nfunction unrollLoops(code, defines)\n{\n    //\n    // Currently, only integer for loops with positive step values\n    // can be unrolled. (TODO: negative step values?)\n    //\n    // The current implementation does not support curly braces\n    // inside unrolled loops. You may define macros to get around\n    // this, but do you actually need to unroll such loops?\n    //\n    // Loops that don't fit the supported pattern will crash\n    // the preprocessor if you try to unroll them.\n    //\n    const fn = unroll.bind(defines); // CRAZY!\n    const n = unrollRegex.length;\n\n    for(let i = 0; i < n; i++)\n        code = code.replace(unrollRegex[i], fn);\n\n    return code;\n}\n\n/**\n * Unroll a loop pattern (regexp)\n * @param {string} match the matched for loop\n * @param {string} type\n * @param {string} counter\n * @param {string} start\n * @param {string} cmp\n * @param {string} end\n * @param {string} step\n * @param {string} loopcode\n * @returns {string} unrolled loop\n */\nfunction unroll(match, type, counter, start, cmp, end, step, loopcode)\n{\n    const defines = /** @type {ShaderDefines} */ ( this );\n\n    // check if the loop limits are numeric constants or #defined numbers from the outside\n    const hasStart = Number.isFinite(+start) || defines.has(start);\n    const hasEnd = Number.isFinite(+end) || defines.has(end);\n    if(!hasStart || !hasEnd) {\n        if(defines.size > 0)\n            throw new ParseError(`Can't unroll loop: unknown limits (start=${start}, end=${end}). Code:\\n\\n${match}`);\n        else\n            return match; // don't unroll now, because defines is empty - maybe we'll succeed in the next pass\n    }\n\n    // parse and validate limits & step\n    let istart = defines.has(start) ? defines.get(start) : parseInt(start);\n    let iend = defines.has(end) ? defines.get(end) : parseInt(end);\n    let istep = (step.length == 0) ? 1 : parseInt(step);\n    Utils.assert(istart <= iend && istep > 0);\n\n    /*\n    // debug\n    console.log(`Encontrei \"${match}\"`);\n    console.log(`type=\"${type}\"`);\n    console.log(`counter=\"${counter}\"`);\n    console.log(`start=\"${start}\"`);\n    console.log(`cmp=\"${cmp}\"`);\n    console.log(`end=\"${end}\"`);\n    console.log(`step=\"${step}\"`);\n    console.log(`loopcode=\"${loopcode}\"`)\n    console.log('Defines:', defines);\n    */\n\n    // continue statements are not supported inside unrolled loops\n    // and will generate a compiler error. Using break is ok.\n    const hasBreak = (loopcode.match(/\\bbreak\\s*;/) !== null);\n\n    // create a new scope\n    let unrolledCode = hasBreak ? 'switch(1) { default:\\n' : '{\\n';\n\n    // declare counter\n    unrolledCode += `${type} ${counter};\\n`;\n\n    // unroll loop\n    iend += (cmp == '<=') ? 1 : 0;\n    for(let i = istart; i < iend; i += istep)\n        unrolledCode += `{\\n${counter} = ${i};\\n${loopcode}\\n}\\n`;\n\n    // close scope\n    unrolledCode += '}\\n';\n    //console.log('Unrolled code:\\n\\n' + unrolledCode);\n\n    // done!\n    return unrolledCode;\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * convolution.js\n * Convolution shader generators\n */\n\nimport { createShader } from '../../shader-declaration';\nimport { Utils } from '../../../utils/utils';\nimport { IllegalArgumentError } from '../../../utils/errors';\n\n\n\n/**\n * Generate a 2D convolution with a square kernel\n * @param {number[]} kernel convolution kernel\n * @param {number} [normalizationConstant] will be multiplied by all kernel entries\n */\nexport function conv2D(kernel, normalizationConstant = 1.0)\n{\n    const kernel32 = new Float32Array(kernel.map(x => (+x) * (+normalizationConstant)));\n    const kSize = Math.sqrt(kernel32.length) | 0;\n    const N = kSize >> 1; // idiv 2\n\n    // validate input\n    if(kSize < 1 || kSize % 2 == 0)\n        throw new IllegalArgumentError(`Can't perform a 2D convolution with an invalid kSize of ${kSize}`);\n    else if(kSize * kSize != kernel32.length)\n        throw new IllegalArgumentError(`Invalid 2D convolution kernel of ${kernel32.length} elements (expected: square)`);\n\n    // select the appropriate pixel function\n    const pixelAtOffset = (N <= 7) ? 'pixelAtShortOffset' : 'pixelAtLongOffset';\n\n    // code generator\n    const foreachKernelElement = fn => Utils.cartesian(Utils.symmetricRange(N), Utils.symmetricRange(N)).map(\n        cur => fn(\n            kernel32[(cur[0] + N) * kSize + (cur[1] + N)],\n            cur[0], cur[1]\n        )\n    ).join('\\n');\n\n    const generateCode = (k, dy, dx) => `\n        result += ${pixelAtOffset}(image, ivec2(${(-dx) | 0}, ${(-dy) | 0})) * float(${+k});\n    `;\n\n    // shader\n    const source = `\n    uniform sampler2D image;\n\n    void main()\n    {\n        float alpha = threadPixel(image).a;\n        vec4 result = vec4(0.0f);\n\n        ${foreachKernelElement(generateCode)}\n\n        color = vec4(result.rgb, alpha);\n    }\n    `;\n\n    // done!\n    return createShader(source).withArguments('image');\n}\n\n\n\n\n/**\n * Generate a 1D convolution function on the x-axis\n * @param {number[]} kernel convolution kernel\n * @param {number} [normalizationConstant] will be multiplied by all kernel entries\n */\nexport function convX(kernel, normalizationConstant = 1.0)\n{\n    return conv1D('x', kernel, normalizationConstant);\n}\n\n\n\n\n/**\n * Generate a 1D convolution function on the y-axis\n * @param {number[]} kernel convolution kernel\n * @param {number} [normalizationConstant] will be multiplied by all kernel entries\n */\nexport function convY(kernel, normalizationConstant = 1.0)\n{\n    return conv1D('y', kernel, normalizationConstant);\n}\n\n\n\n\n/**\n * 1D convolution function generator\n * @param {string} axis either \"x\" or \"y\"\n * @param {number[]} kernel convolution kernel\n * @param {number} [normalizationConstant] will be multiplied by all kernel entries\n */\nfunction conv1D(axis, kernel, normalizationConstant = 1.0)\n{\n    const kernel32 = new Float32Array(kernel.map(x => (+x) * (+normalizationConstant)));\n    const kSize = kernel32.length;\n    const N = kSize >> 1; // idiv 2\n\n    // validate input\n    if(kSize < 1 || kSize % 2 == 0)\n        throw new IllegalArgumentError(`Can't perform a 1D convolution with an invalid kSize of ${kSize}`);\n    else if(axis != 'x' && axis != 'y')\n        throw new IllegalArgumentError(`Can't perform 1D convolution: invalid axis \"${axis}\"`); // this should never happen\n\n    // select the appropriate pixel function\n    const pixelAtOffset = (N <= 7) ? 'pixelAtShortOffset' : 'pixelAtLongOffset';\n\n    // code generator\n    const foreachKernelElement = fn => Utils.symmetricRange(N).reduce(\n        (acc, cur) => acc + fn(kernel32[cur + N], cur),\n    '');\n    const generateCode = (k, i) => ((axis == 'x') ? `\n        pixel += ${pixelAtOffset}(image, ivec2(${(-i) | 0}, 0)) * float(${+k});\n    ` : `\n        pixel += ${pixelAtOffset}(image, ivec2(0, ${(-i) | 0})) * float(${+k});\n    `);\n\n    // shader\n    const source = `\n    uniform sampler2D image;\n\n    void main()\n    {\n        float alpha = threadPixel(image).a;\n        vec4 pixel = vec4(0.0f);\n\n        ${foreachKernelElement(generateCode)}\n\n        color = vec4(pixel.rgb, alpha);\n    }\n    `;\n\n    // done!\n    return createShader(source).withArguments('image');\n}","var map = {\n\t\"./colors.glsl\": \"./src/gpu/shaders/include/colors.glsl\",\n\t\"./filters.glsl\": \"./src/gpu/shaders/include/filters.glsl\",\n\t\"./fixed-point.glsl\": \"./src/gpu/shaders/include/fixed-point.glsl\",\n\t\"./float16.glsl\": \"./src/gpu/shaders/include/float16.glsl\",\n\t\"./global.glsl\": \"./src/gpu/shaders/include/global.glsl\",\n\t\"./int32.glsl\": \"./src/gpu/shaders/include/int32.glsl\",\n\t\"./keypoint-descriptors.glsl\": \"./src/gpu/shaders/include/keypoint-descriptors.glsl\",\n\t\"./keypoint-matches.glsl\": \"./src/gpu/shaders/include/keypoint-matches.glsl\",\n\t\"./keypoints.glsl\": \"./src/gpu/shaders/include/keypoints.glsl\",\n\t\"./math.glsl\": \"./src/gpu/shaders/include/math.glsl\",\n\t\"./pyramids.glsl\": \"./src/gpu/shaders/include/pyramids.glsl\",\n\t\"./subpixel.glsl\": \"./src/gpu/shaders/include/subpixel.glsl\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"./src/gpu/shaders/include sync recursive ^\\\\.\\\\/.*$\";","var map = {\n\t\"./filters/convolution\": \"./src/gpu/shaders/filters/convolution.js\",\n\t\"./filters/convolution.js\": \"./src/gpu/shaders/filters/convolution.js\",\n\t\"./filters/convolution1d.glsl\": \"./src/gpu/shaders/filters/convolution1d.glsl\",\n\t\"./filters/convolution2d.glsl\": \"./src/gpu/shaders/filters/convolution2d.glsl\",\n\t\"./filters/fast-median.glsl\": \"./src/gpu/shaders/filters/fast-median.glsl\",\n\t\"./filters/nightvision.glsl\": \"./src/gpu/shaders/filters/nightvision.glsl\",\n\t\"./filters/normalize-image.glsl\": \"./src/gpu/shaders/filters/normalize-image.glsl\",\n\t\"./filters/rgb2grey.glsl\": \"./src/gpu/shaders/filters/rgb2grey.glsl\",\n\t\"./include/colors.glsl\": \"./src/gpu/shaders/include/colors.glsl\",\n\t\"./include/filters.glsl\": \"./src/gpu/shaders/include/filters.glsl\",\n\t\"./include/fixed-point.glsl\": \"./src/gpu/shaders/include/fixed-point.glsl\",\n\t\"./include/float16.glsl\": \"./src/gpu/shaders/include/float16.glsl\",\n\t\"./include/global.glsl\": \"./src/gpu/shaders/include/global.glsl\",\n\t\"./include/int32.glsl\": \"./src/gpu/shaders/include/int32.glsl\",\n\t\"./include/keypoint-descriptors.glsl\": \"./src/gpu/shaders/include/keypoint-descriptors.glsl\",\n\t\"./include/keypoint-matches.glsl\": \"./src/gpu/shaders/include/keypoint-matches.glsl\",\n\t\"./include/keypoints.glsl\": \"./src/gpu/shaders/include/keypoints.glsl\",\n\t\"./include/math.glsl\": \"./src/gpu/shaders/include/math.glsl\",\n\t\"./include/pyramids.glsl\": \"./src/gpu/shaders/include/pyramids.glsl\",\n\t\"./include/subpixel.glsl\": \"./src/gpu/shaders/include/subpixel.glsl\",\n\t\"./keypoints/allocate-descriptors.glsl\": \"./src/gpu/shaders/keypoints/allocate-descriptors.glsl\",\n\t\"./keypoints/allocate-extra.glsl\": \"./src/gpu/shaders/keypoints/allocate-extra.glsl\",\n\t\"./keypoints/apply-homography.glsl\": \"./src/gpu/shaders/keypoints/apply-homography.glsl\",\n\t\"./keypoints/bf-knn.glsl\": \"./src/gpu/shaders/keypoints/bf-knn.glsl\",\n\t\"./keypoints/clip-border.glsl\": \"./src/gpu/shaders/keypoints/clip-border.glsl\",\n\t\"./keypoints/clip.glsl\": \"./src/gpu/shaders/keypoints/clip.glsl\",\n\t\"./keypoints/distance-filter.glsl\": \"./src/gpu/shaders/keypoints/distance-filter.glsl\",\n\t\"./keypoints/encode-keypoint-long-offsets.glsl\": \"./src/gpu/shaders/keypoints/encode-keypoint-long-offsets.glsl\",\n\t\"./keypoints/encode-keypoint-offsets.glsl\": \"./src/gpu/shaders/keypoints/encode-keypoint-offsets.glsl\",\n\t\"./keypoints/encode-keypoint-positions.glsl\": \"./src/gpu/shaders/keypoints/encode-keypoint-positions.glsl\",\n\t\"./keypoints/encode-keypoint-properties.glsl\": \"./src/gpu/shaders/keypoints/encode-keypoint-properties.glsl\",\n\t\"./keypoints/encode-keypoints.glsl\": \"./src/gpu/shaders/keypoints/encode-keypoints.glsl\",\n\t\"./keypoints/encode-null-keypoints.glsl\": \"./src/gpu/shaders/keypoints/encode-null-keypoints.glsl\",\n\t\"./keypoints/fast.glsl\": \"./src/gpu/shaders/keypoints/fast.glsl\",\n\t\"./keypoints/fast.vs.glsl\": \"./src/gpu/shaders/keypoints/fast.vs.glsl\",\n\t\"./keypoints/hamming-distance-filter.glsl\": \"./src/gpu/shaders/keypoints/hamming-distance-filter.glsl\",\n\t\"./keypoints/harris-cutoff.glsl\": \"./src/gpu/shaders/keypoints/harris-cutoff.glsl\",\n\t\"./keypoints/harris.glsl\": \"./src/gpu/shaders/keypoints/harris.glsl\",\n\t\"./keypoints/knn-init.glsl\": \"./src/gpu/shaders/keypoints/knn-init.glsl\",\n\t\"./keypoints/knn-transfer.glsl\": \"./src/gpu/shaders/keypoints/knn-transfer.glsl\",\n\t\"./keypoints/laplacian.glsl\": \"./src/gpu/shaders/keypoints/laplacian.glsl\",\n\t\"./keypoints/lk.glsl\": \"./src/gpu/shaders/keypoints/lk.glsl\",\n\t\"./keypoints/lookup-of-locations.glsl\": \"./src/gpu/shaders/keypoints/lookup-of-locations.glsl\",\n\t\"./keypoints/lookup-of-locations.vs.glsl\": \"./src/gpu/shaders/keypoints/lookup-of-locations.vs.glsl\",\n\t\"./keypoints/lsh-knn.glsl\": \"./src/gpu/shaders/keypoints/lsh-knn.glsl\",\n\t\"./keypoints/mix-keypoints.glsl\": \"./src/gpu/shaders/keypoints/mix-keypoints.glsl\",\n\t\"./keypoints/nonmax-scale.glsl\": \"./src/gpu/shaders/keypoints/nonmax-scale.glsl\",\n\t\"./keypoints/nonmax-space.glsl\": \"./src/gpu/shaders/keypoints/nonmax-space.glsl\",\n\t\"./keypoints/nonmax-suppression.glsl\": \"./src/gpu/shaders/keypoints/nonmax-suppression.glsl\",\n\t\"./keypoints/orb-descriptor.glsl\": \"./src/gpu/shaders/keypoints/orb-descriptor.glsl\",\n\t\"./keypoints/orb-orientation.glsl\": \"./src/gpu/shaders/keypoints/orb-orientation.glsl\",\n\t\"./keypoints/refine-scale.glsl\": \"./src/gpu/shaders/keypoints/refine-scale.glsl\",\n\t\"./keypoints/score-findmax.glsl\": \"./src/gpu/shaders/keypoints/score-findmax.glsl\",\n\t\"./keypoints/shuffle.glsl\": \"./src/gpu/shaders/keypoints/shuffle.glsl\",\n\t\"./keypoints/sort-keypoints.glsl\": \"./src/gpu/shaders/keypoints/sort-keypoints.glsl\",\n\t\"./keypoints/subpixel-refinement.glsl\": \"./src/gpu/shaders/keypoints/subpixel-refinement.glsl\",\n\t\"./keypoints/transfer-flow.glsl\": \"./src/gpu/shaders/keypoints/transfer-flow.glsl\",\n\t\"./keypoints/transfer-orientation.glsl\": \"./src/gpu/shaders/keypoints/transfer-orientation.glsl\",\n\t\"./keypoints/transfer-to-extra.glsl\": \"./src/gpu/shaders/keypoints/transfer-to-extra.glsl\",\n\t\"./keypoints/upload-keypoints.glsl\": \"./src/gpu/shaders/keypoints/upload-keypoints.glsl\",\n\t\"./pyramids/downsample2.glsl\": \"./src/gpu/shaders/pyramids/downsample2.glsl\",\n\t\"./pyramids/upsample2.glsl\": \"./src/gpu/shaders/pyramids/upsample2.glsl\",\n\t\"./transforms/additive-mix.glsl\": \"./src/gpu/shaders/transforms/additive-mix.glsl\",\n\t\"./transforms/resize.glsl\": \"./src/gpu/shaders/transforms/resize.glsl\",\n\t\"./transforms/warp-perspective.glsl\": \"./src/gpu/shaders/transforms/warp-perspective.glsl\",\n\t\"./utils/copy-components.glsl\": \"./src/gpu/shaders/utils/copy-components.glsl\",\n\t\"./utils/copy-raster.glsl\": \"./src/gpu/shaders/utils/copy-raster.glsl\",\n\t\"./utils/copy.glsl\": \"./src/gpu/shaders/utils/copy.glsl\",\n\t\"./utils/fill-components.glsl\": \"./src/gpu/shaders/utils/fill-components.glsl\",\n\t\"./utils/fill.glsl\": \"./src/gpu/shaders/utils/fill.glsl\",\n\t\"./utils/flip-y.vs.glsl\": \"./src/gpu/shaders/utils/flip-y.vs.glsl\",\n\t\"./utils/scan-minmax2d.glsl\": \"./src/gpu/shaders/utils/scan-minmax2d.glsl\",\n\t\"./utils/sobel-derivatives.glsl\": \"./src/gpu/shaders/utils/sobel-derivatives.glsl\",\n\t\"./utils/sobel-derivatives.vs.glsl\": \"./src/gpu/shaders/utils/sobel-derivatives.vs.glsl\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"./src/gpu/shaders sync recursive ^\\\\.\\\\/.*$\";","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-descriptordb.js\n * A database of binary descriptors in video memory\n */\n\nimport { SpeedyTexture } from './speedy-texture';\nimport { SpeedyNamespace } from '../core/speedy-namespace';\nimport { Utils } from '../utils/utils';\nimport { NotSupportedError } from '../utils/errors';\n\n//\n// A database of binary descriptors is a texture that stores\n// a set of (descriptor: uint8_t[]) entries.\n//\n\n/** @type {number} we use RGBA8 textures to store the descriptors */\nconst DESCRIPTORDB_BYTESPERPIXEL = 4;\n\n/** @type {number} texture size goes up to 16 MB */\nconst DESCRIPTORDB_MAXLOG2STRIDE = 11; // 2048x2048 RGBA8 textures are guaranteed to be available in WebGL2 (where is the source of this?)\n\n/**\n * Utility for generating a database of binary descriptors in video memory\n */\nexport class SpeedyDescriptorDB extends SpeedyNamespace\n{\n    /**\n     * Create a database of binary descriptors\n     * @param {SpeedyTexture} texture output texture\n     * @param {Uint8Array[]} descriptors binary descriptors\n     * @param {number} descriptorSize in bytes, a multiple of 4\n     * @returns {SpeedyTexture} texture\n     */\n    static create(texture, descriptors, descriptorSize)\n    {\n        Utils.assert(descriptorSize % DESCRIPTORDB_BYTESPERPIXEL == 0, `Invalid descriptorSize: ${descriptorSize}`);\n\n        const numberOfDescriptors = descriptors.length;\n        const pixelsPerDescriptor = descriptorSize / DESCRIPTORDB_BYTESPERPIXEL;\n\n        // find an appropriate texture size\n        const n = Math.log2(pixelsPerDescriptor * Math.max(numberOfDescriptors, 1)) / 2;\n        const log2stride = Math.min(DESCRIPTORDB_MAXLOG2STRIDE, Math.ceil(n));\n\n        // setup texture parameters\n        const stride = 1 << log2stride;\n        const width = stride, height = stride; // we use powers-of-two\n\n        // are we within storage capacity?\n        const capacity = (width * height) / pixelsPerDescriptor;\n        if(numberOfDescriptors > capacity)\n            throw new NotSupportedError(`The capacity of the descriptorDB (${capacity} for ${descriptorSize * 8}-bit descriptors) has been exceeded`);\n\n        // create texture data\n        const data = new Uint8Array(width * height * DESCRIPTORDB_BYTESPERPIXEL);\n        for(let i = 0; i < numberOfDescriptors; i++) {\n            const byteOffset = i * descriptorSize;\n            const descriptor = descriptors[i];\n\n            // validate input\n            Utils.assert(descriptor.byteLength === descriptorSize);\n            Utils.assert(byteOffset + descriptorSize <= data.byteLength);\n\n            // write data\n            data.set(descriptor, byteOffset);\n        }\n\n        // log data for further study\n        const MEGABYTE = 1048576;\n        const totalSize = numberOfDescriptors * descriptorSize;\n        Utils.log(\n            `Creating a ${width}x${height} database of ${numberOfDescriptors} ` +\n            `${descriptorSize * 8}-bit descriptors ` +\n            `(total size: ${(totalSize / MEGABYTE).toFixed(2)} MB)`\n        );\n\n        // upload to the texture\n        texture.resize(width, height);\n        texture.upload(data);\n        return texture;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-gl.js\n * A wrapper around the WebGL Rendering Context\n */\n\nimport { Utils } from '../utils/utils';\nimport { Observable } from '../utils/observable';\nimport { SpeedyPromise } from '../utils/speedy-promise';\nimport { NotSupportedError, IllegalArgumentError } from '../utils/errors';\n\n/** @typedef {'default' | 'low-power' | 'high-performance'} SpeedyPowerPreference */\n\n// Constants\nconst SINGLETON_KEY = Symbol();\nconst DEFAULT_POWER_PREFERENCE = 'default';\n\n//\n// We use a small canvas to improve the performance\n// of createImageBitmap() on Firefox.\n//\n// A large canvas (2048x2048) causes a FPS drop, even\n// if we only extract a small region of it (this is\n// unlike Chrome, which is fast).\n//\n// Note: we automatically increase the size of the\n// canvas (as needed) when rendering to it.\n//\nconst CANVAS_WIDTH = 16, CANVAS_HEIGHT = 16;\n\n/** @type {SpeedyGL} Singleton */\nlet instance = null;\n\n/** @type {SpeedyPowerPreference} power preference */\nlet powerPreference = DEFAULT_POWER_PREFERENCE;\n\n\n\n/**\n * A wrapper around the WebGL Rendering Context\n */\nexport class SpeedyGL extends Observable\n{\n    /**\n     * Constructor\n     * @param {Symbol} key\n     * @private\n     */\n    constructor(key)\n    {\n        Utils.assert(key === SINGLETON_KEY);\n        super();\n\n\n\n        /** @type {boolean} internal flag */\n        this._reinitializeOnContextLoss = true;\n\n        /** @type {HTMLCanvasElement} canvas */\n        this._canvas = this._createCanvas(this._reinitialize.bind(this));\n\n        /** @type {WebGL2RenderingContext} WebGL rendering context */\n        this._gl = null;\n\n\n\n        // create WebGL2 rendering context\n        this._gl = this._createContext(this._canvas);\n    }\n\n    /**\n     * Get Singleton\n     * @returns {SpeedyGL}\n     */\n    static get instance()\n    {\n        return instance || (instance = new SpeedyGL(SINGLETON_KEY));\n    }\n\n    /**\n     * The WebGL Rendering Context\n     * Be careful not to cache this, as the WebGL Rendering Context may be lost!\n     * @returns {WebGL2RenderingContext}\n     */\n    get gl()\n    {\n        return this._gl;\n    }\n\n    /**\n     * The canvas\n     * @returns {HTMLCanvasElement}\n     */\n    get canvas()\n    {\n        return this._canvas;\n    }\n\n    /**\n     * Create a WebGL-capable canvas\n     * @param {Function} reinitialize to be called if we get a WebGL context loss event\n     * @returns {HTMLCanvasElement}\n     */\n    _createCanvas(reinitialize)\n    {\n        const canvas = Utils.createCanvas(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        canvas.addEventListener('webglcontextlost', ev => {\n            Utils.warning(`Lost WebGL2 context`);\n            setTimeout(reinitialize, 0);\n            ev.preventDefault();\n        }, false);\n\n        /*canvas.addEventListener('webglcontextrestored', ev => {\n            Utils.warning(`Restored WebGL2 context`);\n            ev.preventDefault();\n        }, false);*/\n\n        return canvas;\n    }\n\n    /**\n     * Create a WebGL2 Rendering Context\n     * @param {HTMLCanvasElement} canvas\n     * @returns {WebGL2RenderingContext}\n     */\n    _createContext(canvas)\n    {\n        Utils.log(`Creating a ${powerPreference} WebGL2 rendering context...`);\n\n        // does the browser support WebGL2?\n        if(typeof WebGL2RenderingContext === 'undefined')\n            throw new NotSupportedError(`This application requires WebGL2. Please use a different browser.`);\n\n         const gl = canvas.getContext('webgl2', {\n            premultipliedAlpha: false,\n            preserveDrawingBuffer: false,\n            powerPreference: powerPreference,\n            alpha: true, // see https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices#avoid_alphafalse_which_can_be_expensive\n            antialias: false,\n            depth: false,\n            stencil: false,\n            desynchronized: true,\n        });\n\n        if(!gl)\n            throw new NotSupportedError(`Can't create a WebGL2 Rendering Context. Try a different browser!`);\n\n        return gl;\n    }\n\n    /**\n     * Reinitialize WebGL\n     */\n    _reinitialize()\n    {\n        // disable reinitialization?\n        if(!this._reinitializeOnContextLoss)\n            return;\n\n        // warning\n        Utils.warning(`Reinitializing WebGL2...`);\n\n        // create new canvas\n        this._canvas.remove();\n        this._canvas = this._createCanvas(this._reinitialize.bind(this));\n\n        // create new context\n        this._gl = this._createContext(this._canvas);\n\n        // notify observers: we have a new context!\n        // we need to recreate all textures...\n        this._notify();\n    }\n\n    /**\n     * Lose the WebGL context. This is used to manually\n     * free resources, and also for purposes of testing\n     * @returns {WEBGL_lose_context}\n     */\n    loseContext()\n    {\n        const gl = this._gl;\n\n        // nothing to do?\n        if(gl.isContextLost())\n            return;\n\n        // find the appropriate extension\n        const ext = gl.getExtension('WEBGL_lose_context');\n        if(!ext)\n            throw new NotSupportedError('WEBGL_lose_context extension is unavailable');\n\n        // disable reinitialization\n        this._reinitializeOnContextLoss = false;\n\n        // lose context\n        ext.loseContext();\n\n        // done!\n        return ext;\n    }\n\n    /**\n     * Lose & restore the WebGL context\n     * @param {number} [secondsToRestore]\n     * @return {SpeedyPromise<WEBGL_lose_context>} resolves as soon as the context is restored\n     */\n    loseAndRestoreContext(secondsToRestore = 1)\n    {\n        const ms = Math.max(secondsToRestore, 0) * 1000;\n        const ext = this.loseContext();\n\n        return new SpeedyPromise(resolve => {\n            setTimeout(() => {\n                //ext.restoreContext();\n                this._reinitializeOnContextLoss = true;\n                this._reinitialize();\n                setTimeout(() => resolve(ext), 0); // next frame\n            }, ms);\n        });\n    }\n\n    /**\n     * Power preference for the WebGL context\n     * @returns {SpeedyPowerPreference}\n     */\n    static get powerPreference()\n    {\n        return powerPreference;\n    }\n\n    /**\n     * Power preference for the WebGL context\n     * @param {SpeedyPowerPreference} value\n     */\n    static set powerPreference(value)\n    {\n        // validate\n        if(!(value === 'default' || value === 'low-power' || value === 'high-performance'))\n            throw new IllegalArgumentError(`Invalid powerPreference: \"${value}\"`);\n\n        // the power preference should be set before we create the WebGL context\n        if(instance == null || powerPreference !== value) {\n            powerPreference = value;\n\n            // recreate the context if it already exists. Experimental.\n            if(instance != null)\n                instance.loseAndRestoreContext();\n        }\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-gpu.js\n * GPU-accelerated routines for Computer Vision\n */\n\nimport { SpeedyGL } from './speedy-gl';\nimport { SpeedyTexture } from './speedy-texture';\nimport { SpeedyProgramCenter } from './speedy-program-center';\nimport { SpeedyTexturePool } from './speedy-texture-pool';\nimport { SpeedyTextureUploader } from './speedy-texture-uploader';\nimport { SpeedyMediaSource } from '../core/speedy-media-source';\nimport { SpeedyPromise } from '../utils/speedy-promise';\nimport { Utils } from '../utils/utils';\nimport { Observable } from '../utils/observable';\n\n\n/**\n * GPU-accelerated routines for Computer Vision\n */\nexport class SpeedyGPU extends Observable\n{\n    /**\n     * Constructor\n     */\n    constructor()\n    {\n        super();\n\n        /** @type {SpeedyGL} cached reference */\n        this._speedyGL = SpeedyGL.instance;\n\n        /** @type {SpeedyProgramCenter} GPU-based programs */\n        this._programs = new SpeedyProgramCenter(this);\n\n        /** @type {SpeedyTexturePool} texture pool */\n        this._texturePool = new SpeedyTexturePool(this);\n\n        /** @type {SpeedyTextureUploader} texture uploader */\n        this._textureUploader = new SpeedyTextureUploader(this);\n\n\n\n        // recreate the state if necessary\n        this._speedyGL.subscribe(this._reset, this);\n    }\n\n    /**\n     * Access point to all GPU programs\n     * @returns {SpeedyProgramCenter}\n     */\n    get programs()\n    {\n        return this._programs;\n    }\n\n    /**\n     * The WebGL Rendering Context\n     * Be careful not to cache this, as the WebGL Rendering Context may be lost!\n     * @returns {WebGL2RenderingContext}\n     */\n    get gl()\n    {\n        return this._speedyGL.gl;\n    }\n\n    /**\n     * Internal canvas\n     * @returns {HTMLCanvasElement}\n     */\n    get canvas()\n    {\n        return this._speedyGL.canvas;\n    }\n\n    /**\n     * Texture pool\n     * @returns {SpeedyTexturePool}\n     */\n    get texturePool()\n    {\n        return this._texturePool;\n    }\n\n    /**\n     * Renders a texture to the canvas\n     * @param {SpeedyTexture} texture\n     * @returns {HTMLCanvasElement} returned for convenience\n     */\n    renderToCanvas(texture)\n    {\n        const width = texture.width;\n        const height = texture.height;\n        const canvas = this.canvas;\n\n        // do we need to resize the canvas?\n        if(width > canvas.width || height > canvas.height) {\n            Utils.warning(`Resizing the canvas to ${width} x ${height}`);\n            canvas.width = width;\n            canvas.height = height;\n        }\n\n        // render\n        this.programs.utils.renderToCanvas.outputs(width, height, null);\n        this.programs.utils.renderToCanvas(texture);\n\n        // done!\n        return canvas;\n    }\n\n    /**\n     * Upload an image to the GPU\n     * @param {SpeedyMediaSource} source\n     * @param {SpeedyTexture} outputTexture\n     * @returns {SpeedyTexture} outputTexture\n     */\n    upload(source, outputTexture)\n    {\n        return this._textureUploader.upload(source, outputTexture);\n    }\n\n    /**\n     * Releases resources\n     * @returns {null}\n     */\n    release()\n    {\n        Utils.assert(!this.isReleased());\n\n        // release internal components\n        this._programs = this._programs.release();\n        this._texturePool = this._texturePool.release();\n        this._textureUploader = this._textureUploader.release();\n\n        // unsubscribe\n        this._speedyGL.unsubscribe(this._reset);\n        return null;\n    }\n\n    /**\n     * Has this SpeedyGPU been released?\n     * @returns {boolean}\n     */\n    isReleased()\n    {\n        return this._programs == null;\n    }\n\n    /**\n     * Lose & restore the WebGL context (useful for testing purposes)\n     * @return {SpeedyPromise<void>} resolves as soon as the context is restored\n     */\n    loseAndRestoreWebGLContext()\n    {\n        return this._speedyGL.loseAndRestoreContext().then(() => void(0));\n    }\n\n    /**\n     * Reset the internal state\n     * (called on context reset)\n     */\n    _reset()\n    {\n        if(this.isReleased())\n            return;\n\n        this._programs = new SpeedyProgramCenter(this);\n        this._texturePool = new SpeedyTexturePool(this);\n        this._textureUploader = new SpeedyTextureUploader(this);\n\n        this._notify();\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-lsh.js\n * GPU-based LSH tables for fast matching of binary descriptors\n */\n\nimport { SpeedyTexture, SpeedyDrawableTexture } from './speedy-texture';\nimport { SpeedyDescriptorDB } from './speedy-descriptordb';\nimport { Utils } from '../utils/utils';\nimport { MATCH_MAX_INDEX } from '../utils/globals';\n\n/*\n *              ALE'S GPU-BASED LSH FOR APPROXIMATE KNN MATCHING\n *              ------------------------------------------------\n *\n * Here is my variant of Locality Sensitive Hashing for GPU-based KNN matching!\n * Indices of keypoint descriptors are stored in several tables, each with many\n * buckets of fixed capacity. In a nutshell, I create a data structure of fixed\n * size to match the keypoints.\n *\n * Buckets in video memory may get full. Wouldn't it be cool if we could use a\n * probabilistic approach to let us work within their storage capacity?\n *\n * Let there be n buckets in a table, each with storage capacity c (holding\n * up to c elements). Buckets are numbered from 0 to n-1.\n *\n * We pick uniformly a random bucket to store a new element in the table. Let\n * X be the chosen bucket. The probability that we'll store the new element in\n * any particular bucket k is:\n *\n * P(X = k) = 1/n   (k = 0, 1, 2, ... n-1)\n *\n * On average, each new element stored in the table inserts 1/n of an element\n * in each bucket. If we add m new elements to the table, each bucket receives\n * m/n elements, on average(*).\n *\n * (*) for all k, define the Ik random variable as 1 if X = k and 0 otherwise.\n *     It follows that the expected value of Ik, E(Ik), is 1/n for all k. In\n *     addition, the expected value of (m Ik) is m * E(ik) = m/n.\n *\n * Now let Yi be the number of elements inserted in bucket i in m additions to\n * the table. We model Yi as Poisson(m/n), since on average, m additions to\n * the table result in m/n new elements being inserted in bucket i. Buckets\n * are picked independently. Hence, for all i, the probability that we insert\n * q elements in bucket i in m additions to the table is:\n *\n * P(Yi = q) = (m/n)^q * exp(-m/n) / q!   (q = 0, 1, 2...)\n *\n * Given that each bucket has storage capacity c, we require Yi <= c with a\n * high probability p (say, p = 0.99). This means that, in m additions, we\n * don't want to exceed the capacity c with high probability. So, let us find\n * a (large) value of m such that:\n *\n * P(Yi <= c) >= p\n *\n * Sounds good! We can find the largest matching m using binary search.\n *\n * I don't think we need to enforce a high probability that ALL buckets stay\n * within their capacity - n is large, we need to use the available space, and\n * we have multiple tables anyway.\n *\n * In practice, the assumption that buckets are picked uniformly doesn't hold:\n * keypoints that are nearby tend to have similar descriptors and buckets are\n * picked according to those descriptors. Still, this model works well enough\n * in practice and it is simple! That's what I like about it!\n *\n * ... now, how I actually do the matching is the theme of the next episode!\n */\n\n/** @type {number} Default number of tables in a LSH data structure */\nexport const LSH_DEFAULT_NUMBER_OF_TABLES = 8;\n\n/** @type {number} Default number of bits of a hash */\nexport const LSH_DEFAULT_HASH_SIZE = 15;\n\n/** @type {number[]} Acceptable number of tables for a LSH data structure */\nexport const LSH_ACCEPTABLE_NUMBER_OF_TABLES = [4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32];\n\n/** @type {number[]} Acceptable values for hashSize, in bits */\nexport const LSH_ACCEPTABLE_HASH_SIZES = [10,11,12,13,14,15,16,17,18,19,20];\n\n/** @type {number[]} Acceptable sizes for keypoint descriptors, in bytes */\nexport const LSH_ACCEPTABLE_DESCRIPTOR_SIZES = [32,64];\n\n/**\n * @typedef {Object} LSHProfile LSH profile\n * @property {string} name name of the profile\n * @property {number} capacity maximum number of keypoints that can be stored in such a table\n * @property {number} hashSize number of bits in a keypoint descriptor hash (at most 16)\n * @property {number} tableCount number of tables, preferably a power of 2 (at most 16)\n * @property {number} bucketCapacity maximum number of entries of a bucket of a table\n */\n\n/** @type {function(number,number,number):LSHProfile[]|null} generate LSH profiles sorted by increasing capacity */\nconst generateLSHProfiles = (t,h,p) => !LSH_ACCEPTABLE_HASH_SIZES.includes(h) || !LSH_ACCEPTABLE_NUMBER_OF_TABLES.includes(t) ? null : [\n    {\n        name: 'x-small',\n        bucketCapacity: 1,\n        tableCount: t,\n        hashSize: h,\n        capacity: findTableCapacity(h, 1, p),\n    },\n    {\n        name: 'small',\n        bucketCapacity: 2,\n        tableCount: t,\n        hashSize: h,\n        capacity: findTableCapacity(h, 2, p),\n    },\n    {\n        name: 'small-plus',\n        bucketCapacity: 3,\n        tableCount: t,\n        hashSize: h,\n        capacity: findTableCapacity(h, 3, p),\n    },\n    {\n        name: 'medium',\n        bucketCapacity: 4,\n        tableCount: t,\n        hashSize: h,\n        capacity: findTableCapacity(h, 4, p),\n    },\n    {\n        name: 'medium-plus',\n        bucketCapacity: 5,\n        tableCount: t,\n        hashSize: h,\n        capacity: findTableCapacity(h, 5, p),\n    },\n    {\n        name: 'large',\n        bucketCapacity: 6,\n        tableCount: t,\n        hashSize: h,\n        capacity: findTableCapacity(h, 6, p),\n    },\n    {\n        name: 'x-large',\n        bucketCapacity: 8,\n        tableCount: t,\n        hashSize: h,\n        capacity: findTableCapacity(h, 8, p),\n    },\n];\n\n//\n// LSH hash sequences: random bits in increasing order\n// We generate a few sequences (one for each table) supporting up to 16 hash bits\n// We pad each sequence with invalid values at the end - we want to pick any bit with equal probability\n//\n\n/** @typedef {Uint32Array} BitSequences flattened array of LSH_SEQUENCE_COUNT sequences of LSH_SEQUENCE_MAXLEN elements each - each entry represents a bit index */\n/** @typedef {Object<number,BitSequences>} BitSequencesIndexedByDescriptorSize */\n/** @typedef {Object<number,BitSequencesIndexedByDescriptorSize>} LSHSequences */\n\n/** @type {number} maximum number of elements of a sequence */\nexport const LSH_SEQUENCE_MAXLEN = Math.max(...LSH_ACCEPTABLE_HASH_SIZES);\n\n/** @type {number} number of sequences in a BitSequences object */\nexport const LSH_SEQUENCE_COUNT = Math.max(...LSH_ACCEPTABLE_NUMBER_OF_TABLES);\n\n/** @type {function(BitSequences): BitSequences} Sort subsequences of random bits in ascending order */\nconst partitionedSort = seq => (Utils.range(LSH_SEQUENCE_COUNT)\n    .forEach(i => seq.subarray(i * LSH_SEQUENCE_MAXLEN, (i+1) * LSH_SEQUENCE_MAXLEN).sort()),\nseq);\n\n/** @type {function(number, BitSequences): BitSequences} Set the last p entries of the input subsequences to an invalid value */\nconst padSequences = (p, seq) => (Utils.range(LSH_SEQUENCE_COUNT)\n    .forEach(i => seq.subarray((i+1) * LSH_SEQUENCE_MAXLEN - p, (i+1) * LSH_SEQUENCE_MAXLEN).fill(0xBADCAFE)),\nseq);\n\n/** @type {LSHSequences} the bits we pick to form the hashes, laid out in ascending order and indexed by descriptorSize and hashSize */\nconst LSH_SEQUENCES = (f => LSH_ACCEPTABLE_HASH_SIZES.reduce((p,o) => ((p[o]=f(o)), p), {}))(h => ({\n    // for 256-bit descriptors\n    32: partitionedSort(padSequences(LSH_SEQUENCE_MAXLEN - h, new Uint32Array([\n        ...(Utils.shuffle(Utils.range(256))),\n        ...(Utils.shuffle(Utils.range(256))),\n        ...(Utils.shuffle(Utils.range(256))),\n    ].slice(0, LSH_SEQUENCE_COUNT * LSH_SEQUENCE_MAXLEN)))),\n\n    // for 512-bit descriptors\n    64: partitionedSort(padSequences(LSH_SEQUENCE_MAXLEN - h, new Uint32Array([\n        ...(Utils.shuffle(Utils.range(512))),\n        ...(Utils.shuffle(Utils.range(512))),\n    ].slice(0, LSH_SEQUENCE_COUNT * LSH_SEQUENCE_MAXLEN)))),\n}));\n\n//\n// Misc\n//\n\n/** @type {number} we use RGBA8 textures (32 bits per pixel) as storage */\nconst LSH_BYTESPERPIXEL = 4;\n\n/** @type {function(number): number} next power of 2 */\nconst nextPot = x => x > 1 ? 1 << Math.ceil(Math.log2(x)) : 1;\n\n\n\n/**\n * GPU-based LSH tables for fast matching of binary descriptors\n */\nexport class SpeedyLSH\n{\n    /**\n     * Constructor\n     * @param {SpeedyTexture} lshTables texture to be used as the set of LSH tables\n     * @param {SpeedyTexture} descriptorDB texture to be used as the descriptor database\n     * @param {Uint8Array[]} descriptors the binary descriptors you'll store (make sure you don't repeat them, otherwise they will just waste space)\n     * @param {number} [tableCount] number of LSH tables, preferably a power of two\n     * @param {number} [hashSize] number of bits of a hash of a descriptor\n     * @param {number} [probability] probability of no discard events happening in the theoretical model\n     */\n    constructor(lshTables, descriptorDB, descriptors, tableCount = LSH_DEFAULT_NUMBER_OF_TABLES, hashSize = LSH_DEFAULT_HASH_SIZE, probability = 0.95)\n    {\n        const descriptorCount = descriptors.length;\n        const descriptorSize = descriptorCount > 0 ? descriptors[0].byteLength : 0;\n        const lshProfiles = generateLSHProfiles(tableCount, hashSize, probability);\n\n        // validate input\n        Utils.assert(descriptorCount > 0, `Can't build LSH tables without descriptors!`);\n        Utils.assert(LSH_ACCEPTABLE_DESCRIPTOR_SIZES.includes(descriptorSize), `Can't build LSH tables: unacceptable descriptor size of ${descriptorSize} bytes`);\n        Utils.assert(descriptors.findIndex(d => d.byteLength !== descriptorSize) < 0, `Can't build LSH tables: incorrectly sized descriptors. Expected ${descriptorSize} bytes for each`);\n        Utils.assert(descriptorCount < MATCH_MAX_INDEX, `Can't build LSH tables: too many descriptors (${descriptors.length})`);\n        Utils.assert(lshProfiles != null, `Can't build LSH tables: unacceptable number of tables (${tableCount}) x hash size (${hashSize})`);\n\n        /** @type {LSHProfile} LSH profile */\n        this._profile = lshProfiles.find(profile => descriptorCount <= profile.capacity) || lshProfiles[lshProfiles.length - 1];\n\n        /** @type {number} descriptor size, in bytes */\n        this._descriptorSize = descriptorSize;\n\n        /** @type {number} number of descriptors */\n        this._descriptorCount = descriptorCount;\n\n        /** @type {BitSequences} bit sequences */\n        this._sequences = this._pickSequences(this._descriptorSize);\n\n        /** @type {SpeedyTexture} LSH tables storing indices of descriptors */\n        this._tables = this._createStaticTables(lshTables, this._sequences, descriptors, descriptorSize);\n\n        /** @type {SpeedyTexture} a storage of descriptors */\n        this._descriptorDB = SpeedyDescriptorDB.create(descriptorDB, descriptors, descriptorSize);\n    }\n\n    /**\n     * Descriptor size, in bytes\n     * @returns {number}\n     */\n    get descriptorSize()\n    {\n        return this._descriptorSize;\n    }\n\n    /**\n     * Number of descriptors stored in this LSH data structure\n     * @returns {number}\n     */\n    get descriptorCount()\n    {\n        return this._descriptorCount;\n    }\n\n    /**\n     * LSH bit sequences\n     * @returns {BitSequences}\n     */\n    get sequences()\n    {\n        return this._sequences;\n    }\n\n    /**\n     * Number of bits that make a hash\n     * @returns {number}\n     */\n    get hashSize()\n    {\n        return this._profile.hashSize;\n    }\n\n    /**\n     * Maximum number of descriptors that can be stored in a bucket of a table\n     * @returns {number}\n     */\n    get bucketCapacity()\n    {\n        return this._profile.bucketCapacity;\n    }\n\n    /**\n     * How many buckets per table do we have?\n     * @returns {number}\n     */\n    get bucketsPerTable()\n    {\n        return 1 << this._profile.hashSize;\n    }\n\n    /**\n     * Number of LSH tables\n     * @returns {number}\n     */\n    get tableCount()\n    {\n        return this._profile.tableCount;\n    }\n\n    /**\n     * Size of one LSH table, in bytes\n     * @returns {number}\n     */\n    get tableSize()\n    {\n        return this.bucketsPerTable * this.bucketCapacity * LSH_BYTESPERPIXEL;\n    }\n\n    /**\n     * Size of all LSH tables combined, in bytes\n     * @returns {number}\n     */\n    get totalSize()\n    {\n        // actually, the total memory in VRAM may be a bit larger than\n        // this value, depending on the actual size of the texture\n        return this.tableCount * this.tableSize;\n    }\n\n    /**\n     * LSH tables texture\n     * @returns {SpeedyDrawableTexture}\n     */\n    get tables()\n    {\n        return this._tables;\n    }\n\n    /**\n     * A collection of descriptors\n     * @returns {SpeedyDrawableTexture}\n     */\n    get descriptorDB()\n    {\n        return this._descriptorDB;\n    }\n\n    /**\n     * Pick the appropriate LSH sequences for a particular descriptor size\n     * @param {number} descriptorSize in bytes\n     * @returns {BitSequences}\n     */\n    _pickSequences(descriptorSize)\n    {\n        Utils.assert(Object.prototype.hasOwnProperty.call(LSH_SEQUENCES, this.hashSize));\n        Utils.assert(Object.prototype.hasOwnProperty.call(LSH_SEQUENCES[this.hashSize], descriptorSize));\n\n        return LSH_SEQUENCES[this.hashSize][descriptorSize];\n    }\n\n    /**\n     * Create LSH tables\n     * @param {SpeedyTexture} texture output texture\n     * @param {BitSequences} sequences bit sequences\n     * @param {Uint8Array[]} descriptors non-empty array of binary descriptors, ALL HAVING THE SAME SIZE\n     * @param {number} descriptorSize in bytes\n     * @returns {SpeedyTexture} texture\n     */\n    _createStaticTables(texture, sequences, descriptors, descriptorSize)\n    {\n        const END_OF_LIST = 0xFFFFFFFF;\n        const profileName = this._profile.name;\n        const tableCapacity = this._profile.capacity;\n        const tableCount = this.tableCount;\n        const bucketsPerTable = this.bucketsPerTable;\n        const bucketSize = this.bucketCapacity * LSH_BYTESPERPIXEL;\n        const hashSize = this.hashSize;\n        const numberOfPixels = this.tableCount * this.bucketsPerTable * this.bucketCapacity; // watch for overflow?\n        const textureWidth = Math.min(nextPot(Math.sqrt(numberOfPixels)), 4096); // 4096 is compatible with most devices according to MDN\n        const textureHeight = Math.ceil(numberOfPixels / textureWidth);\n        const numberOfDescriptors = descriptors.length;\n\n        // validate input\n        Utils.assert(hashSize <= LSH_SEQUENCE_MAXLEN);\n        Utils.assert(tableCount <= LSH_SEQUENCE_COUNT);\n        Utils.assert(numberOfPixels <= textureWidth * textureHeight);\n\n        // log\n        const MEGABYTE = 1048576;\n        Utils.log(\n            `Building ${tableCount} ${profileName} LSH tables with ${numberOfDescriptors} ` +\n            `${descriptorSize * 8}-bit descriptors each and hashSize = ${hashSize} bits ` +\n            `(${textureWidth}x${textureHeight}, with ${(this.tableSize / MEGABYTE).toFixed(2)} ` +\n            `MB per table and total size = ${(this.totalSize / MEGABYTE).toFixed(2)} MB), `\n        );\n\n        // warn the user if there are too many descriptors\n        if(numberOfDescriptors > tableCapacity) {\n            const exceedingPercentage = 100 * numberOfDescriptors / tableCapacity;\n            Utils.warning(`There are too many descriptors (${numberOfDescriptors}) for a ${profileName} LSH table. That's ${exceedingPercentage.toFixed(2)}% of its theoretical capacity. Consider increasing the hashSize (currently set to ${hashSize}) or reducing the number of descriptors to avoid degradation.`);\n        }\n\n        // create empty LSH tables\n        const buffer = new ArrayBuffer(textureWidth * textureHeight * LSH_BYTESPERPIXEL);\n        const bytes = (new Uint8Array(buffer)).fill(0xFF);\n        const data = new DataView(buffer);\n\n        // shuffle the descriptors...\n        // it seems like a good idea to handle collisions of similar descriptors,\n        // which may be located next to each other in the array\n        const permutation = Utils.shuffle(Utils.range(numberOfDescriptors));\n\n        // for each descriptor\n        // do everything in little-endian format!\n        const numberOfDiscardedDescriptorsPerTable = (new Array(tableCount)).fill(0);\n        for(let i = 0; i < numberOfDescriptors; i++) {\n            const descriptorIndex = permutation[i]; //i;\n            const hashes = this._hashCodes(descriptors[descriptorIndex], sequences);\n\n            // for each table\n            for(let table = 0; table < tableCount; table++) {\n                // compute hash & memory addresses\n                const hash = hashes[table];\n                const tableByteOffset = table * bucketsPerTable * bucketSize;\n                const bucketByteOffset = tableByteOffset + hash * bucketSize;\n\n                // find the end of the list\n                let index = END_OF_LIST;\n                for(let entryByteOffset = 0; entryByteOffset < bucketSize; entryByteOffset += LSH_BYTESPERPIXEL) {\n                    const byteOffset = bucketByteOffset + entryByteOffset;\n                    index = data.getUint32(byteOffset, true);\n\n                    // add the keypoint\n                    if(index == END_OF_LIST) {\n                        data.setUint32(byteOffset, descriptorIndex, true);\n                        break;\n                    }\n                }\n\n                // note: if the bucket is full, we just discard the entry :\\\n                // we give this event a probabilistic treatment (see above),\n                // so it happens with low probability\n                if(index != END_OF_LIST)\n                    numberOfDiscardedDescriptorsPerTable[table]++;\n            }\n        }\n\n        // log data for further study\n        const numberOfDiscardedDescriptors = numberOfDiscardedDescriptorsPerTable.reduce((sum, val) => sum + val, 0);\n        const profile = numberOfDiscardedDescriptorsPerTable.map(d => 100 * d / numberOfDescriptors);\n        Utils.log(\n            `When building ${tableCount} ${profileName} LSH tables with ${numberOfDescriptors} ` +\n            `${descriptorSize * 8}-bit descriptors each and hashSize = ${hashSize} bits, ` +\n            `I got the following discard profile: ` + profile.map(x => x.toFixed(2) + '%').join(', ') + `. ` +\n            `Average: ${(100 * numberOfDiscardedDescriptors / (tableCount * numberOfDescriptors)).toFixed(2)}%. ` +\n            `Minimum: ${Math.min(...profile).toFixed(2)}%. ` +\n            `Table capacity: ${tableCapacity}.`\n        );\n\n        // upload the LSH tables to the GPU\n        texture.resize(textureWidth, textureHeight);\n        texture.upload(bytes);\n        return texture;\n    }\n\n    /**\n     * Pick bits from a binary descriptor\n     * @param {Uint8Array} descriptor a single descriptor\n     * @param {BitSequences} sequences flattened array of tableCount sequences of LSH_SEQUENCE_MAXLEN elements each\n     * @returns {number[]} hash code for each table\n     */\n    _hashCodes(descriptor, sequences)\n    {\n        const tableCount = this.tableCount;\n        const hashSize = this.hashSize;\n        const bucketsPerTable = this.bucketsPerTable;\n        const hashes = new Array(tableCount);\n        //const descriptorSize = descriptor.length;\n\n        // just to be sure...\n        Utils.assert(\n            hashSize <= LSH_SEQUENCE_MAXLEN &&\n            sequences.length >= LSH_SEQUENCE_MAXLEN * tableCount\n        );\n\n        // for each table\n        for(let table = 0; table < tableCount; table++) {\n            const offset = LSH_SEQUENCE_MAXLEN * table;\n\n            // pick bits [ sequences[offset] .. sequences[offset + hashSize-1] ]\n            let hash = 0;\n            for(let i = 0; i < hashSize; i++) {\n                let bit = sequences[offset + i];\n                let b = bit >>> 3;\n                let m = 1 << (bit & 7);\n\n                //Utils.assert(b < descriptorSize);\n                hash = (hash << 1) | ((descriptor[b] & m) != 0);\n            }\n\n            // validate & store\n            Utils.assert(hash >= 0 && hash < bucketsPerTable);\n            hashes[table] = hash;\n        }\n\n        // done!\n        return hashes;\n    }\n}\n\n/**\n * Compute P(X <= k), where X ~ Poisson(lambda)\n * @param {number} lambda positive number\n * @param {number} k non-negative integer\n * @returns {number}\n */\nfunction cumulativePoisson(lambda, k)\n{\n    const exp = Math.exp(-lambda);\n    let sum = 1, fat = 1, pow = 1;\n\n    // k should be small!!!\n    for(let i = 1; i <= k; i++)\n        sum += (pow *= lambda) / (fat *= i);\n\n    return sum * exp;\n}\n\n/**\n * Find the maximum number of keypoint descriptors that a table can hold\n * @param {number} hashSize positive integer\n * @param {number} bucketCapacity positive integer\n * @param {number} [probability] probability of no discard events happening in the theoretical model\n * @return {number} optimal table capacity\n */\nfunction findTableCapacity(hashSize, bucketCapacity, probability = 0.99)\n{\n    const n = 1 << hashSize // number of buckets\n    const c = bucketCapacity;\n    const p = probability;\n\n    let l = 1, r = n * c; // watch for overflow!\n    let m = 0, pm = 0;\n\n    // binary search\n    while(l < r) {\n        m = Math.floor((l + r) / 2);\n        pm = cumulativePoisson(m / n, c);\n\n        if(pm > p) //if(1-pm < 1-p)\n            l = m + 1;\n        else\n            r = m;\n    }\n\n    return m;\n}\n","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-program-center.js\n * An access point to all programs that run on the GPU\n */\n\nimport { SpeedyGPU } from './speedy-gpu';\nimport { SpeedyProgramGroupUtils } from './programs/utils';\nimport { SpeedyProgramGroupFilters } from './programs/filters';\nimport { SpeedyProgramGroupKeypoints } from './programs/keypoints';\nimport { SpeedyProgramGroupPyramids } from './programs/pyramids';\nimport { SpeedyProgramGroupTransforms } from './programs/transforms';\nimport { SpeedyProgramGroup } from './speedy-program-group';\n\n/**\n * An access point to all programs that run on the CPU\n * All program groups can be accessed via this class\n */\nexport class SpeedyProgramCenter\n{\n    /**\n     * Class constructor\n     * @param {SpeedyGPU} gpu reference to SpeedyGPU\n     */\n    constructor(gpu)\n    {\n        // Note: we instantiate the program groups lazily\n\n        /** @type {SpeedyGPU} reference to SpeedyGPU */\n        this._gpu = gpu;\n\n        /** @type {SpeedyProgramGroupFilters} image filters */\n        this._filters = null;\n\n        /** @type {SpeedyProgramGroupTransforms} geometric transformations */\n        this._transforms = null;\n\n        /** @type {SpeedyProgramGroupPyramids} pyramids & scale-space */\n        this._pyramids = null;\n\n        /** @type {SpeedyProgramGroupKeypoints} keypoint routines */\n        this._keypoints = null;\n\n        /** @type {SpeedyProgramGroupUtils} utility programs */\n        this._utils = null;\n    }\n\n    /**\n     * Image filters & convolutions\n     * @returns {SpeedyProgramGroupFilters}\n     */\n    get filters()\n    {\n        return this._filters || (this._filters = new SpeedyProgramGroupFilters(this._gpu));\n    }\n\n    /**\n     * Geometric transformations\n     * @returns {SpeedyProgramGroupTransforms}\n     */\n    get transforms()\n    {\n        return this._transforms || (this._transforms = new SpeedyProgramGroupTransforms(this._gpu));\n    }\n\n    /**\n     * Image pyramids & scale-space\n     * @returns {SpeedyProgramGroupPyramids}\n     */\n    get pyramids()\n    {\n        return this._pyramids || (this._pyramids = new SpeedyProgramGroupPyramids(this._gpu));\n    }\n\n    /**\n     * Keypoint detection & description\n     * @returns {SpeedyProgramGroupKeypoints}\n     */\n    get keypoints()\n    {\n        return this._keypoints || (this._keypoints = new SpeedyProgramGroupKeypoints(this._gpu));\n    }\n\n    /**\n     * Utility programs\n     * @returns {SpeedyProgramGroupUtils}\n     */\n    get utils()\n    {\n        return this._utils || (this._utils = new SpeedyProgramGroupUtils(this._gpu));\n    }\n\n    /**\n     * Release all programs from all groups. You'll\n     * no longer be able to use any of them.\n     * @returns {null}\n     */\n    release()\n    {\n        for(const key in this) {\n            if(Object.prototype.hasOwnProperty.call(this, key) && this[key] != null) {\n                const group = this[key];\n                if(group instanceof SpeedyProgramGroup)\n                    group.release();\n            }\n        }\n\n        return null;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-program-group.js\n * An abstract group of programs that run on the GPU\n */\n\nimport { ShaderDeclaration } from './shader-declaration';\nimport { SpeedyProgram } from './speedy-program';\nimport { SpeedyGPU } from './speedy-gpu';\n\n/** @typedef {import('./speedy-program').SpeedyProgramOptions} SpeedyProgramOptions */\n\n/**\n * @typedef {object} SpeedyProgramHelpers\n * @property {function(): SpeedyProgramOptions} usesPingpongRendering\n * @property {function(): SpeedyProgramOptions} rendersToCanvas\n*/\n\n/** @const {SpeedyProgramHelpers} Program settings generator */\nconst PROGRAM_HELPERS = Object.freeze({\n\n    /**\n     * Pingpong Rendering: the output texture of a\n     * program cannot be used as an input to itself.\n     * This is a convenient helper in these situations\n     * @returns {SpeedyProgramOptions}\n     */\n    usesPingpongRendering() {\n        return {\n            pingpong: true\n        };\n    },\n\n    /**\n     * Render to canvas\n     * Use it when we're supposed to see the texture\n     * @returns {SpeedyProgramOptions}\n     */\n    rendersToCanvas() {\n        return {\n            renderToTexture: false\n        };\n    },\n\n});\n\n/**\n * SpeedyProgramGroup\n * A semantically correlated group\n * of programs that run on the GPU\n * @abstract\n */\nexport class SpeedyProgramGroup\n{\n    /**\n     * Class constructor\n     * @protected\n     * @param {SpeedyGPU} gpu\n     */\n    constructor(gpu)\n    {\n        /** @type {SpeedyGPU} GPU-accelerated routines */\n        this._gpu = gpu;\n\n        /** @type {SpeedyProgram[]} the list of all programs that belong to this group */\n        this._programs = [];\n    }\n\n    /**\n     * Declare a program\n     * @protected\n     * @param {string} name Program name\n     * @param {ShaderDeclaration} shaderdecl Shader declaration\n     * @param {SpeedyProgramOptions} [options] Program settings\n     * @returns {this}\n     */\n    declare(name, shaderdecl, options = {})\n    {\n        // lazy instantiation of kernels\n        Object.defineProperty(this, name, {\n            get: (() => {\n                // Why cast a symbol to symbol?\n                // Suppress error TS9005: Declaration emit for this file requires using private name 'key'.\n                //const key = Symbol(name);\n                const key = /** @type {symbol} */ ( Symbol(name) );\n                return () => this[key] || (this[key] = this._createProgram(shaderdecl, options));\n            })()\n        });\n\n        return this;\n    }\n\n    /**\n     * Neat helpers to be used when declaring programs\n     * @returns {SpeedyProgramHelpers}\n     */\n    get program()\n    {\n        return PROGRAM_HELPERS;\n    }\n\n    /**\n     * Releases all programs from this group\n     * @returns {null}\n     */\n    release()\n    {\n        for(let i = 0; i < this._programs.length; i++)\n            this._programs[i].release();\n\n        return null;\n    }\n\n    /**\n     * Spawn a SpeedyProgram\n     * @param {ShaderDeclaration} shaderdecl Shader declaration\n     * @param {SpeedyProgramOptions} [options] Program settings\n     * @returns {SpeedyProgram}\n     */\n    _createProgram(shaderdecl, options = {})\n    {\n        const program = new SpeedyProgram(this._gpu.gl, shaderdecl, options);\n        this._programs.push(program);\n        return program;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-program.js\n * SpeedyProgram class\n */\n\nimport { SpeedyTexture, SpeedyDrawableTexture } from './speedy-texture';\nimport { SpeedyPromise } from '../utils/speedy-promise';\nimport { ShaderDeclaration } from './shader-declaration';\nimport { Utils } from '../utils/utils';\nimport { NotSupportedError, IllegalArgumentError, IllegalOperationError, GLError } from '../utils/errors';\n\n/** @const {Object<string,string>} Map uniform type to a gl function */\nconst UNIFORM_SETTERS = Object.freeze({\n    'sampler2D': 'uniform1i',\n    'isampler2D':'uniform1i',\n    'usampler2D':'uniform1i',\n    'float':     'uniform1f',\n    'int':       'uniform1i',\n    'uint':      'uniform1ui',\n    'bool':      'uniform1i',\n    'vec2':      'uniform2f',\n    'vec3':      'uniform3f',\n    'vec4':      'uniform4f',\n    'ivec2':     'uniform2i',\n    'ivec3':     'uniform3i',\n    'ivec4':     'uniform4i',\n    'uvec2':     'uniform2ui',\n    'uvec3':     'uniform3ui',\n    'uvec4':     'uniform4ui',\n    'bvec2':     'uniform2i',\n    'bvec3':     'uniform3i',\n    'bvec4':     'uniform4i',\n    'mat2':      'uniformMatrix2fv',\n    'mat3':      'uniformMatrix3fv',\n    'mat4':      'uniformMatrix4fv',\n});\n\n/**\n * @typedef {object} SpeedyProgramOptions\n * @property {boolean} [renderToTexture] render results to a texture?\n * @property {boolean} [pingpong] alternate output texture between calls\n */\n\n/** @typedef {number|number[]|boolean|boolean[]|SpeedyTexture} SpeedyProgramUniformValue */\n\n/**\n * A SpeedyProgram is a Function that\n * runs GPU-accelerated GLSL code\n */\nexport class SpeedyProgram extends Function\n{\n    /**\n     * Creates a new SpeedyProgram\n     * @param {WebGL2RenderingContext} gl WebGL context\n     * @param {ShaderDeclaration} shaderdecl Shader declaration\n     * @param {SpeedyProgramOptions} [options] user options\n     */\n    constructor(gl, shaderdecl, options = { })\n    {\n        super('...args', 'return this._self._call(...args)');\n\n        /** @type {SpeedyProgram} this function bound to this function! */\n        this._self = this.bind(this);\n\n        this._self._init(gl, shaderdecl, options);\n        return this._self;\n    }\n\n    /**\n     * Initialize the SpeedyProgram\n     * @param {WebGL2RenderingContext} gl WebGL context\n     * @param {ShaderDeclaration} shaderdecl Shader declaration\n     * @param {SpeedyProgramOptions} options user options\n     */\n    _init(gl, shaderdecl, options)\n    {\n        // not a valid context?\n        if(gl.isContextLost())\n            throw new IllegalOperationError(`Can't initialize SpeedyProgram: lost context`);\n\n        // options object\n        options = Object.assign({\n            // default options\n            renderToTexture: true,\n            pingpong: false,\n        }, options);\n\n\n\n        /** @type {WebGL2RenderingContext} */\n        this._gl = gl;\n\n        /** @type {WebGLProgram} vertex shader + fragment shader */\n        this._program = SpeedyProgram._compile(gl, shaderdecl.vertexSource, shaderdecl.fragmentSource);\n\n        /** @type {ProgramGeometry} this is a quad */\n        this._geometry = new ProgramGeometry(gl, {\n            position: shaderdecl.locationOfAttributes.position,\n            texCoord: shaderdecl.locationOfAttributes.texCoord\n        });\n\n        /** @type {string[]} names of the arguments of the SpeedyProgram */\n        this._argnames = shaderdecl.arguments;\n\n        /** @type {boolean[]} tells whether the i-th argument of the SpeedyProgram is an array or not */\n        this._argIsArray = (new Array(this._argnames.length)).fill(false);\n\n        /** @type {UBOHelper} UBO helper (lazy instantiation) */\n        this._ubo = null;\n\n        /** @type {boolean} should we render to a texture? If false, we render to the canvas */\n        this._renderToTexture = Boolean(options.renderToTexture);\n\n        /** @type {number} width of the output */\n        this._width = 1;\n\n        /** @type {number} height of the output */\n        this._height = 1;\n\n        /** @type {SpeedyDrawableTexture[]} output texture(s) */\n        this._texture = (new Array(options.pingpong ? 2 : 1)).fill(null);\n\n        /** @type {number} used for pingpong rendering */\n        this._textureIndex = 0;\n\n        /** @type {Map<string,UniformVariable>} uniform variables */\n        this._uniform = new Map();\n\n        /** @type {ShaderDeclaration} shader declaration */\n        this._shaderdecl = shaderdecl;\n\n\n        // autodetect uniforms\n        gl.useProgram(this._program);\n        for(const name of shaderdecl.uniforms) {\n            const type = shaderdecl.uniformType(name);\n            const location = gl.getUniformLocation(this._program, name);\n            this._uniform.set(name, new UniformVariable(type, location));\n        }\n\n        // match arguments & uniforms\n        for(let j = 0; j < this._argnames.length; j++) {\n            const argname = this._argnames[j];\n            if(!this._uniform.has(argname)) {\n                this._argIsArray[j] = this._uniform.has(argname + '[0]');\n                if(!this._argIsArray[j])\n                    throw new IllegalOperationError(`Expected uniform \"${argname}\", as declared in the argument list`);\n            }\n        }\n    }\n\n    /**\n     * Run the SpeedyProgram\n     * @param  {...SpeedyProgramUniformValue} args\n     * @returns {SpeedyDrawableTexture}\n     */\n    _call(...args)\n    {\n        const gl = this._gl;\n        const argnames = this._argnames;\n\n        // matching arguments?\n        if(args.length != argnames.length)\n            throw new IllegalArgumentError(`Can't run shader: incorrect number of arguments (expected ${argnames.length}, got ${args.length})`);\n\n        // can't use the output texture as an input\n        const flatArgs = Utils.flatten(args);\n        for(let j = flatArgs.length - 1; j >= 0; j--) {\n            if(flatArgs[j] === this._texture[this._textureIndex])\n                throw new NotSupportedError(`Can't run shader: don't use its output texture as an input to itself. Consider using pingpong rendering!`);\n        }\n\n        // context loss?\n        if(gl.isContextLost())\n            return this._texture[this._textureIndex];\n\n        // use program\n        gl.useProgram(this._program);\n\n        // bind the VAO\n        gl.bindVertexArray(this._geometry.vao);\n\n        // select the render target\n        const texture = this._texture[this._textureIndex];\n        const fbo = this._renderToTexture ? texture.glFbo : null;\n\n        // update texSize uniform (available in all fragment shaders)\n        const width = this._width, height = this._height;\n        const texSize = this._uniform.get('texSize');\n        texSize.setValue(gl, [ width, height ]);\n        //gl.uniform2f(texSize.location, width, height);\n\n        // set uniforms[i] to args[i]\n        for(let i = 0, texNo = 0; i < args.length; i++) {\n            const argname = argnames[i];\n\n            if(!this._argIsArray[i]) {\n                // uniform variable matches argument name\n                const uniform = this._uniform.get(argname);\n                texNo = uniform.setValue(gl, args[i], texNo);\n            }\n            else {\n                // uniform array matches argument name\n                const array = args[i];\n                if(Array.isArray(array)) {\n                    if(this._uniform.has(`${argname}[${array.length}]`))\n                        throw new IllegalArgumentError(`Can't run shader: too few elements in the \"${argname}\" array`);\n                    for(let j = 0, uniform = undefined; (uniform = this._uniform.get(`${argname}[${j}]`)) !== undefined; j++)\n                        texNo = uniform.setValue(gl, array[j], texNo);\n                }\n                else\n                    throw new IllegalArgumentError(`Can't run shader: expected an array for \"${argname}\"`);\n            }\n        }\n\n        // set Uniform Buffer Objects (if any)\n        if(this._ubo !== null)\n            this._ubo.update();\n\n        // bind the FBO\n        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n\n        // draw call\n        gl.viewport(0, 0, width, height);\n        gl.drawArrays(gl.TRIANGLES, 0, 6); // mode, offset, count\n\n        // unbind the FBO\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\n        // unbind the VAO\n        gl.bindVertexArray(null);\n\n        // we've just changed the texture! discard the pyramid, if any\n        if(texture != null)\n            texture.discardMipmaps();\n\n        // ping-pong rendering\n        this._pingpong();\n\n        // done!\n        return texture;\n    }\n\n    /**\n     * Set the output texture(s) and its (their) shape(s)\n     * @param {number} width new width, in pixels\n     * @param {number} height new height, in pixels\n     * @param  {...SpeedyDrawableTexture|null} texture output texture(s)\n     * @returns {SpeedyProgram} this\n     */\n    outputs(width, height, ...texture)\n    {\n        this._setOutputTexture(...texture);\n        this._setOutputSize(width, height);\n        return this;\n    }\n\n    /**\n     * Set the size of the output\n     * @param {number} width new width, in pixels\n     * @param {number} height new height, in pixels\n     * @returns {SpeedyProgram} this\n     */\n    _setOutputSize(width, height)\n    {\n        Utils.assert(width > 0 && height > 0);\n\n        // update output size\n        this._width = width | 0;\n        this._height = height | 0;\n\n        // resize the output texture(s)\n        for(let i = 0; i < this._texture.length; i++) {\n            if(this._texture[i] != null)\n                this._texture[i].resize(this._width, this._height);\n        }\n\n        // done!\n        return this;\n    }\n\n    /**\n     * Use the provided texture(s) as output\n     * @param {...SpeedyDrawableTexture} texture set to null to use the internal texture(s)\n     * @returns {SpeedyProgram} this\n     */\n    _setOutputTexture(...texture)\n    {\n        Utils.assert(texture.length === this._texture.length, `Incorrect number of textures (expected ${this._texture.length})`);\n\n        // update output texture(s)\n        for(let i = 0; i < this._texture.length; i++)\n            this._texture[i] = texture[i];\n        this._textureIndex = 0;\n\n        // done!\n        return this;\n    }\n\n    /**\n     * Clear the internal textures\n     * @returns {SpeedyDrawableTexture}\n     */\n    clear()\n    {\n        const texture = this._texture[this._textureIndex];\n\n        // clear internal textures\n        for(let i = 0; i < this._texture.length; i++)\n            this._texture[i].clear();\n\n        // ping-pong rendering\n        this._pingpong();\n\n        // done!\n        return texture;\n    }\n\n    /**\n     * Set data using a Uniform Buffer Object\n     * @param {string} blockName uniform block name\n     * @param {ArrayBufferView} data\n     * @returns {SpeedyProgram} this\n     */\n    setUBO(blockName, data)\n    {\n        if(this._ubo === null)\n            this._ubo = new UBOHelper(this._gl, this._program);\n\n        this._ubo.set(blockName, data);\n        return this;\n    }\n\n    /**\n     * Release the resources associated with this SpeedyProgram\n     * @returns {null}\n     */\n    release()\n    {\n        const gl = this._gl;\n\n        // Release UBOs (if any)\n        if(this._ubo != null)\n            this._ubo = this._ubo.release();\n\n        // Unlink textures\n        this._texture.fill(null);\n\n        // Release geometry\n        this._geometry = this._geometry.release();\n\n        // Release program\n        gl.deleteProgram(this._program);\n        this._program = null;\n\n        // Need to delete the shaders as well? In sec 5.14.9 Programs and shaders\n        // of the WebGL 1.0 spec, it is mentioned that the underlying GL object\n        // will automatically be marked for deletion when the JS object is\n        // destroyed (i.e., garbage collected)\n\n        // done!\n        return null;\n    }\n\n    /**\n     * A constant #defined in the shader declaration\n     * @param {string} name\n     * @returns {number}\n     */\n    definedConstant(name)\n    {\n        return this._shaderdecl.definedConstant(name);\n    }\n\n    /**\n     * Helper method for pingpong rendering: alternates\n     * the texture index from 0 to 1 and vice-versa\n     */\n    _pingpong()\n    {\n        if(this._texture.length > 1)\n            this._textureIndex = 1 - this._textureIndex;\n    }\n\n    /**\n     * Compile and link GLSL shaders\n     * @param {WebGL2RenderingContext} gl\n     * @param {string} vertexShaderSource GLSL code of the vertex shader\n     * @param {string} fragmentShaderSource GLSL code of the fragment shader\n     * @returns {WebGLProgram}\n     */\n    static _compile(gl, vertexShaderSource, fragmentShaderSource)\n    {\n        const program = gl.createProgram();\n        const vertexShader = gl.createShader(gl.VERTEX_SHADER);\n        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n\n        // compile vertex shader\n        gl.shaderSource(vertexShader, vertexShaderSource);\n        gl.compileShader(vertexShader);\n        gl.attachShader(program, vertexShader);\n\n        // compile fragment shader\n        gl.shaderSource(fragmentShader, fragmentShaderSource);\n        gl.compileShader(fragmentShader);\n        gl.attachShader(program, fragmentShader);\n\n        // link program\n        gl.linkProgram(program);\n        gl.validateProgram(program);\n\n        // return on success\n        if(gl.getProgramParameter(program, gl.LINK_STATUS))\n            return program;\n\n        // display an error\n        const errors = [\n            gl.getShaderInfoLog(fragmentShader),\n            gl.getShaderInfoLog(vertexShader),\n            gl.getProgramInfoLog(program),\n        ];\n\n        gl.deleteProgram(program);\n        gl.deleteShader(fragmentShader);\n        gl.deleteShader(vertexShader);\n\n        // display error\n        const spaces = i => Math.max(0, 2 - Math.floor(Math.log10(i)));\n        const col = k => new Array(spaces(k)).fill(' ').join('') + k + '. ';\n        const source = errors[0] ? fragmentShaderSource : vertexShaderSource;\n        const formattedSource = source.split('\\n')\n            .map((line, no) => col(1+no) + line)\n            .join('\\n');\n\n        throw new GLError(\n            `\\n\\n---------- ERROR ----------\\n\\n` +\n            errors.filter(err => err).join('\\n') +\n            `\\n\\n---------- SOURCE CODE ----------\\n\\n` +\n            formattedSource + '\\n'\n        );\n    }\n}\n\n\n\n\n\n// ============================================================================\n//                                  HELPERS\n// ============================================================================\n\n\n\n\n\n\n/**\n * Configure and store the VAO and the VBOs\n * @param {WebGL2RenderingContext} gl\n * @param {LocationOfAttributes} location\n * @returns {ProgramGeometry}\n *\n * @typedef {Object} LocationOfAttributes\n * @property {number} position\n * @property {number} texCoord\n *\n * @typedef {Object} BufferOfAttributes\n * @property {WebGLBuffer} position\n * @property {WebGLBuffer} texCoord\n */\nfunction ProgramGeometry(gl, location)\n{\n    /** @type {WebGLVertexArrayObject} Vertex Array Object */\n    this.vao = gl.createVertexArray();\n\n    /** @type {BufferOfAttributes} Vertex Buffer Objects */\n    this.vbo = Object.freeze({\n        position: gl.createBuffer(),\n        texCoord: gl.createBuffer()\n    });\n\n    /** @type {WebGL2RenderingContext} */\n    this._gl = gl;\n\n\n\n    // bind the VAO\n    gl.bindVertexArray(this.vao);\n\n    // set the position attribute\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.position);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\n        // clip coordinates (CCW)\n        -1, -1,\n        1, -1,\n        -1, 1,\n\n        -1, 1,\n        1, -1,\n        1, 1,\n    ]), gl.STATIC_DRAW);\n    gl.enableVertexAttribArray(location.position);\n    gl.vertexAttribPointer(location.position, // attribute location\n                            2,                // 2 components per vertex (x,y)\n                            gl.FLOAT,         // type\n                            false,            // don't normalize\n                            0,                // default stride (tightly packed)\n                            0);               // offset\n\n    // set the texCoord attribute\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.texCoord);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\n        // texture coordinates (CCW)\n        0, 0,\n        1, 0,\n        0, 1,\n\n        0, 1,\n        1, 0,\n        1, 1,\n    ]), gl.STATIC_DRAW);\n    gl.enableVertexAttribArray(location.texCoord);\n    gl.vertexAttribPointer(location.texCoord, // attribute location\n                            2,                // 2 components per vertex (x,y)\n                            gl.FLOAT,         // type\n                            false,            // don't normalize\n                            0,                // default stride (tightly packed)\n                            0);               // offset\n\n    // unbind\n    gl.bindBuffer(gl.ARRAY_BUFFER, null);\n    gl.bindVertexArray(null);\n\n    // done!\n    return Object.freeze(this);\n}\n\n/**\n * Releases the internal resources\n * @returns {null}\n */\nProgramGeometry.prototype.release = function()\n{\n    const gl = this._gl;\n\n    gl.deleteVertexArray(this.vao);\n    gl.deleteBuffer(this.vbo.position);\n    gl.deleteBuffer(this.vbo.texCoord);\n\n    return null;\n}\n\n\n\n\n\n/**\n * Helper class for storing data in GLSL uniform variables\n * @param {string} type\n * @param {WebGLUniformLocation} location\n */\nfunction UniformVariable(type, location)\n{\n    /** @type {string} GLSL data type */\n    this.type = String(type);\n    if(!Object.prototype.hasOwnProperty.call(UNIFORM_SETTERS, this.type))\n        throw new NotSupportedError(`Unsupported uniform type: ${this.type}`);\n\n    /** @type {WebGLUniformLocation} uniform location in a WebGL program */\n    this.location = location;\n\n    /** @type {string} setter function */\n    this.setter = UNIFORM_SETTERS[this.type];\n    const n = Number((this.setter.match(/^uniform(Matrix)?(\\d)/))[2]) | 0;\n\n    /** @type {number} is the uniform a scalar (0), a vector (1) or a matrix (2)? */\n    this.dim = this.type.startsWith('mat') ? 2 : ((this.type.indexOf('vec') >= 0) ? 1 : 0);\n\n    /** @type {number} required number of scalars */\n    this.length = (this.dim == 2) ? n * n : n;\n\n    /** @type {SpeedyProgramUniformValue|null} cached value */\n    this._value = null;\n}\n\n/**\n * Set the value of a uniform variable\n * @param {WebGL2RenderingContext} gl\n * @param {SpeedyProgramUniformValue} value use column-major format for matrices\n * @param {number} [texNo] current texture index\n * @returns {number} new texture index\n */\nUniformVariable.prototype.setValue = function(gl, value, texNo = -1)\n{\n    const setValue = /** @type {Function} */ ( gl[this.setter] );\n\n    // check uniform type\n    if(typeof value === 'object' && this.type.endsWith('sampler2D')) {\n        // set texture\n        if(texNo >= gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS)\n            throw new NotSupportedError(`Can't activate texture unit ${texNo}: max is ${gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS}`);\n        else if(Array.isArray(value))\n            throw new NotSupportedError(`Can't pass arrays of textures to shaders`);\n        else if(value == null)\n            throw new IllegalArgumentError(`Can't run shader: cannot use ${value} as an input texture`);\n        else if(texNo < 0)\n            throw new IllegalArgumentError(`Missing texNo`);\n\n        const tex = value;\n        gl.activeTexture(gl.TEXTURE0 + texNo);\n        gl.bindTexture(gl.TEXTURE_2D, tex.glTexture);\n        gl.uniform1i(this.location, texNo);\n\n        texNo++;\n    }\n    else if(value === this._value) {\n        // do not update the uniform if it hasn't changed\n        void(0);\n    }\n    else if(typeof value === 'number' || typeof value === 'boolean') {\n        // set scalar value\n        setValue.call(gl, this.location, value);\n    }\n    else if(Array.isArray(value)) {\n        // set vector or matrix\n        if(value.length === this.length) {\n            if(this.dim == 2)\n                setValue.call(gl, this.location, false, value); // matrix\n            else\n                setValue.call(gl, this.location, ...value); // vector\n        }\n        else\n            throw new IllegalArgumentError(`Can't run shader: incorrect number of values for ${this.type}: \"${value}\"`);\n    }\n    else\n        throw new IllegalArgumentError(`Can't run shader: unrecognized argument \"${value}\"`);\n\n    // cache the value\n    this._value = value;\n\n    // done\n    return texNo;\n}\n\n\n\n\n/**\n * @typedef {object} UBOStuff\n * @property {WebGLBuffer} buffer\n * @property {number} blockBindingIndex \"global\" binding index\n * @property {number} blockIndex UBO \"location\" in the program\n * @property {ArrayBufferView|null} data user-data\n */\n\n/**\n * A helper class for handling Uniform Buffer Objects (UBOs)\n * @param {WebGL2RenderingContext} gl\n * @param {WebGLProgram} program\n */\nfunction UBOHelper(gl, program)\n{\n    /** @type {WebGL2RenderingContext} */\n    this._gl = gl;\n\n    /** @type {WebGLProgram} */\n    this._program = program;\n\n    /** @type {number} auto-increment counter */\n    this._nextIndex = 0;\n\n    /** @type {Object<string,UBOStuff>} UBO dictionary indexed by uniform block names */\n    this._ubo = Object.create(null);\n}\n\n/**\n * Set Uniform Buffer Object data\n * (the buffer will be uploaded when the program is executed)\n * @param {string} name uniform block name\n * @param {ArrayBufferView} data\n */\nUBOHelper.prototype.set = function(name, data)\n{\n    const gl = this._gl;\n\n    // create UBO entry\n    if(this._ubo[name] === undefined) {\n        this._ubo[name] = {\n            buffer: gl.createBuffer(),\n            blockBindingIndex: this._nextIndex++,\n            blockIndex: -1,\n            data: null\n        };\n    }\n\n    // get UBO entry for the given block name\n    const ubo = this._ubo[name];\n\n    // read block index & assign binding point\n    if(ubo.blockIndex < 0) {\n        const blockIndex = gl.getUniformBlockIndex(this._program, name); // GLuint\n        gl.uniformBlockBinding(this._program, blockIndex, ubo.blockBindingIndex);\n        ubo.blockIndex = blockIndex;\n    }\n\n    // store the data - we'll upload it later\n    ubo.data = data;\n}\n\n/**\n * Update UBO data\n * Called when we're using the appropriate WebGLProgram\n */\nUBOHelper.prototype.update = function()\n{\n    const gl = this._gl;\n\n    for(const name in this._ubo) {\n        const ubo = this._ubo[name];\n\n        gl.bindBuffer(gl.UNIFORM_BUFFER, ubo.buffer);\n        gl.bufferData(gl.UNIFORM_BUFFER, ubo.data, gl.DYNAMIC_DRAW);\n        gl.bindBufferBase(gl.UNIFORM_BUFFER, ubo.blockBindingIndex, ubo.buffer);\n        gl.bindBuffer(gl.UNIFORM_BUFFER, null);\n    }\n}\n\n/**\n * Release allocated buffers\n * @returns {null}\n */\nUBOHelper.prototype.release = function()\n{\n    const gl = this._gl;\n\n    for(const name in this._ubo) {\n        const ubo = this._ubo[name];\n\n        gl.deleteBuffer(ubo.buffer);\n        ubo.data = null;\n    }\n\n    return null;\n}\n","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-texture-pool.js\n * Texture pool\n */\n\nimport { Utils } from '../utils/utils';\nimport { SpeedyGPU } from './speedy-gpu';\nimport { SpeedyDrawableTexture } from './speedy-texture';\nimport { OutOfMemoryError } from '../utils/errors';\n\n// Constants\nconst DEFAULT_CAPACITY = 256;\nconst BUCKET = Symbol('Bucket');\n\n\n/*\n\n=== Heuristics to figure out the capacity of a texture pool ===\n\n1. Decide the maximum amount of VRAM you'd like to use in a pool (say, 64 MB).\n\n2. Figure out the average texture size in your application (say, 640x360 pixels).\n\n3. Figure out the average texture size in bytes (say, 921600 bytes). Each pixel\n   uses 4 bytes (RGBA format).\n\n4. Divide the maximum amount of VRAM by the average texture size in bytes\n   (say, 72). That's the capacity of the pool.\n\nNote that textures are allocated lazily, so VRAM usage is kept to a minimum.\n\nAdapted from: https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices\n\n*/\n\n\n\n/**\n * @typedef {number} TextureBucketIndex index of a bucket in a pool\n */\n\n\n\n/**\n * A bucket\n */\nclass TextureBucket\n{\n    /**\n     * Constructor\n     * @param {SpeedyDrawableTexture} texture managed texture\n     * @param {TextureBucketIndex} index index of this bucket\n     * @param {TextureBucketIndex} next index of the next bucket\n     */\n    constructor(texture, index, next)\n    {\n        /** @type {SpeedyDrawableTexture} managed texture */\n        this.texture = texture;\n\n        /** @type {TextureBucketIndex} index of this bucket */\n        this.index = index;\n\n        /** @type {TextureBucketIndex} index of the next bucket */\n        this.next = next;\n\n        /** @type {boolean} whether the texture is available or not */\n        this.free = true;\n    }\n}\n\n\n\n/**\n * Texture pool\n */\nexport class SpeedyTexturePool\n{\n    /**\n     * Constructor\n     * @param {SpeedyGPU} gpu\n     * @param {number} [capacity] number of textures in the pool\n     */\n    constructor(gpu, capacity = DEFAULT_CAPACITY)\n    {\n        Utils.assert(capacity > 0);\n\n        /** @type {TextureBucket[]} buckets */\n        this._bucket = Array.from({ length: capacity }, (_, i) => new TextureBucket(null, i, i - 1));\n\n        /** @type {TextureBucketIndex} index of an available bucket */\n        this._head = capacity - 1;\n\n        /** @type {SpeedyGPU} GPU instance */\n        this._gpu = gpu;\n    }\n\n    /**\n     * Get a texture from the pool\n     * @returns {SpeedyDrawableTexture}\n     */\n    allocate()\n    {\n        if(this._head < 0)\n            throw new OutOfMemoryError(`Exhausted pool (capacity: ${this._bucket.length})`);\n\n        const bucket = this._bucket[this._head];\n        bucket.free = false;\n        this._head = bucket.next;\n\n        if(bucket.texture == null) // lazy instantiation\n            bucket.texture = SpeedyTexturePool._createManagedTexture(this._gpu.gl, bucket);\n\n        return bucket.texture;\n    }\n\n    /**\n     * Put a texture back in the pool\n     * @param {SpeedyDrawableTexture} texture\n     * @returns {null}\n     */\n    free(texture)\n    {\n        const bucket = texture[BUCKET];\n        Utils.assert(bucket !== undefined && !bucket.free, `Unmanaged texture or double free`);\n\n        bucket.next = this._head;\n        bucket.free = true;\n        this._head = bucket.index;\n\n        return null;\n    }\n\n    /**\n     * Release the texture pool\n     * @returns {null}\n     */\n    release()\n    {\n        for(let i = 0; i < this._bucket.length; i++) {\n            if(this._bucket[i].texture != null)\n                this._bucket[i].texture = this._bucket[i].texture.release();\n        }\n\n        return null;\n    }\n\n    /**\n     * Create a texture with a reference to a bucket\n     * @param {WebGL2RenderingContext} gl\n     * @param {TextureBucket} bucket\n     * @returns {SpeedyDrawableTexture}\n     */\n    static _createManagedTexture(gl, bucket)\n    {\n        const texture = new SpeedyDrawableTexture(gl, 1, 1);\n        return Object.defineProperty(texture, BUCKET, {\n            configurable: false,\n            enumerable: false,\n            writable: false,\n            value: bucket\n        });\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-texture-reader.js\n * Reads data from textures\n */\n\nimport { Utils } from '../utils/utils';\nimport { Observable } from '../utils/observable';\nimport { SpeedyGPU } from './speedy-gpu';\nimport { SpeedyPromise } from '../utils/speedy-promise';\nimport { SpeedyDrawableTexture } from './speedy-texture';\nimport { IllegalOperationError, TimeoutError, GLError } from '../utils/errors';\n\n//const USE_TWO_BUFFERS = /Firefox|Opera|OPR\\//.test(navigator.userAgent);\n\n/**\n * @type {number} number of PBOs; used to get a performance boost in gl.readPixels()\n */\nconst DEFAULT_NUMBER_OF_BUFFERS = 2;\n//const DEFAULT_NUMBER_OF_BUFFERS = USE_TWO_BUFFERS ? 2 : 1;\n\n/**\n * @type {(fn: Function, ...args: any[]) => number} Run function fn on the \"next frame\"\n */\nconst runOnNextFrame = navigator.userAgent.includes('Firefox') ?\n    ((fn, ...args) => setTimeout(fn, 10, ...args)) : // RAF produces a warning on Firefox\n    ((fn, ...args) => requestAnimationFrame(() => fn.apply(window, args))); // reduce battery usage\n\n/**\n * A Queue that notifies observers when it's not empty\n * @template T\n */\nclass ObservableQueue extends Observable\n{\n    /**\n     * Constructor\n     */\n    constructor()\n    {\n        super();\n\n        /** @type {T[]} elements of the queue */\n        this._data = [];\n    }\n\n    /**\n     * Number of elements in the queue\n     * @returns {number}\n     */\n    get size()\n    {\n        return this._data.length;\n    }\n\n    /**\n     * Enqueue an element\n     * @param {T} x\n     */\n    enqueue(x)\n    {\n        this._data.push(x);\n        this._notify();\n    }\n\n    /**\n     * Remove and return the first element of the queue\n     * @returns {T}\n     */\n    dequeue()\n    {\n        if(this._data.length == 0)\n            throw new IllegalOperationError(`Empty queue`);\n\n        return this._data.shift();\n    }\n}\n\n/** @typedef {number} BufferIndex */\n\n/**\n * @typedef {object} Consumable helper for async GPU-CPU transfers\n * @property {BufferIndex} bufferIndex\n * @property {Uint8Array} pixelBuffer\n */\n\n/**\n * Reads data from textures\n */\nexport class SpeedyTextureReader\n{\n    /**\n     * Constructor\n     * @param {number} [numberOfBuffers]\n     */\n    constructor(numberOfBuffers = DEFAULT_NUMBER_OF_BUFFERS)\n    {\n        Utils.assert(numberOfBuffers > 0);\n\n        /** @type {Uint8Array[]} pixel buffers for data transfers (each stores RGBA data) */\n        this._pixelBuffer = (new Array(numberOfBuffers)).fill(null).map(() => new Uint8Array(0));\n\n        /** @type {WebGLBuffer[]} Pixel Buffer Objects (PBOs) */\n        this._pbo = (new Array(numberOfBuffers)).fill(null);\n\n        /** @type {ObservableQueue<Consumable>} for async data transfers */\n        this._consumer = new ObservableQueue();\n\n        /** @type {ObservableQueue<BufferIndex>} for async data transfers (stores buffer indices) */\n        this._producer = new ObservableQueue();\n\n        /** @type {boolean} is this object initialized? */\n        this._initialized = false;\n\n        /** @type {boolean} is the producer-consumer mechanism initialized? */\n        this._initializedProducerConsumer = false;\n    }\n\n    /**\n     * Initialize this object\n     * @param {SpeedyGPU} gpu\n     */\n    init(gpu)\n    {\n        this._allocatePBOs(gpu);\n        gpu.subscribe(this._allocatePBOs, this, gpu);\n\n        this._initialized = true;\n    }\n\n    /**\n     * Release resources\n     * @param {SpeedyGPU} gpu\n     * @returns {null}\n     */\n    release(gpu)\n    {\n        gpu.unsubscribe(this._allocatePBOs, this);\n        this._deallocatePBOs(gpu);\n\n        this._initialized = false;\n        return null;\n    }\n\n    /**\n     * Read pixels from a texture, synchronously.\n     * You may optionally specify a (x,y,width,height) sub-rectangle.\n     * @param {SpeedyDrawableTexture} texture a texture with a FBO\n     * @param {number} [x]\n     * @param {number} [y] \n     * @param {number} [width]\n     * @param {number} [height]\n     * @returns {Uint8Array} pixels in the RGBA format\n     */\n    readPixelsSync(texture, x = 0, y = 0, width = texture.width, height = texture.height)\n    {\n        Utils.assert(this._initialized);\n\n        const gl = texture.gl;\n        const fbo = texture.glFbo;\n\n        // clamp values\n        width = Math.max(0, Math.min(width, texture.width));\n        height = Math.max(0, Math.min(height, texture.height));\n        x = Math.max(0, Math.min(x, texture.width - width));\n        y = Math.max(0, Math.min(y, texture.height - height));\n\n        // buffer allocation\n        const sizeofBuffer = width * height * 4; // 4 bytes per pixel (RGBA)\n        this._reallocate(sizeofBuffer);\n\n        // lost context?\n        if(gl.isContextLost())\n            return this._pixelBuffer[0].subarray(0, sizeofBuffer);\n\n        // read pixels\n        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n        gl.readPixels(x, y, width, height, gl.RGBA, gl.UNSIGNED_BYTE, this._pixelBuffer[0]);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\n        // done!\n        return this._pixelBuffer[0].subarray(0, sizeofBuffer);\n    }\n\n    /**\n     * Read pixels from a texture, asynchronously, with PBOs.\n     * You may optionally specify a (x,y,width,height) sub-rectangle.\n     * @param {SpeedyDrawableTexture} texture a texture with a FBO\n     * @param {number} [x]\n     * @param {number} [y] \n     * @param {number} [width]\n     * @param {number} [height]\n     * @param {boolean} [useBufferedDownloads] accelerate downloads by returning pixels from the texture of the previous call (useful for streaming)\n     * @returns {SpeedyPromise<Uint8Array>} resolves to an array of pixels in the RGBA format\n     */\n    readPixelsAsync(texture, x = 0, y = 0, width = texture.width, height = texture.height, useBufferedDownloads = false)\n    {\n        Utils.assert(this._initialized);\n\n        const gl = texture.gl;\n        const fbo = texture.glFbo;\n\n        // clamp values\n        width = Math.max(0, Math.min(width, texture.width));\n        height = Math.max(0, Math.min(height, texture.height));\n        x = Math.max(0, Math.min(x, texture.width - width));\n        y = Math.max(0, Math.min(y, texture.height - height));\n\n        // buffer allocation\n        const sizeofBuffer = width * height * 4; // 4 bytes per pixel (RGBA)\n        this._reallocate(sizeofBuffer);\n\n        // lost context?\n        if(gl.isContextLost())\n            return SpeedyPromise.resolve(this._pixelBuffer[0].subarray(0, sizeofBuffer));\n\n        // do not optimize?\n        if(!useBufferedDownloads) {\n            const pixelBuffer = this._pixelBuffer[0].subarray(0, sizeofBuffer);\n            return SpeedyTextureReader._readPixelsViaPBO(gl, this._pbo[0], pixelBuffer, fbo, x, y, width, height).then(() =>\n                pixelBuffer\n            );\n        }\n\n        //console.log(\"------------- new frame\");\n\n        // GPU needs to produce data\n        this._producer.subscribe(function produce(gl, fbo, x, y, width, height, sizeofBuffer) {\n            this._producer.unsubscribe(produce, this);\n\n            const bufferIndex = this._producer.dequeue();\n            const pixelBuffer = this._pixelBuffer[bufferIndex].subarray(0, sizeofBuffer);\n\n            //console.log(\"will produce\",bufferIndex);\n            SpeedyTextureReader._readPixelsViaPBO(gl, this._pbo[bufferIndex], pixelBuffer, fbo, x, y, width, height).then(() => {\n                //console.log(\"has produced\",bufferIndex);\n                // this._pixelBuffer[bufferIndex] is ready to be consumed\n                this._consumer.enqueue({ bufferIndex, pixelBuffer });\n            });\n        }, this, gl, fbo, x, y, width, height, sizeofBuffer);\n\n        // CPU needs to consume data\n        const promise = new SpeedyPromise(resolve => {\n            function consume(resolve) {\n                this._consumer.unsubscribe(consume, this);\n\n                const obj = this._consumer.dequeue();\n                const bufferIndex = obj.bufferIndex, pixelBuffer = obj.pixelBuffer;\n\n                //console.log(\"will CONSUME\",bufferIndex);\n                resolve(pixelBuffer);\n\n                this._producer.enqueue(bufferIndex); // enqueue AFTER resolve()\n            }\n\n            if(this._consumer.size > 0)\n                consume.call(this, resolve);\n            else\n                this._consumer.subscribe(consume, this, resolve);\n        });\n\n        // initialize the producer-consumer mechanism\n        if(!this._initializedProducerConsumer) {\n            this._initializedProducerConsumer = true;\n            for(let i = this._pixelBuffer.length - 1; i >= 0; i--)\n                this._consumer.enqueue({ bufferIndex: i, pixelBuffer: this._pixelBuffer[i] });\n        }\n\n        //console.log(\"====== end of frame\");\n\n        // done!\n        return promise;\n    }\n\n    /**\n     * Reallocate the pixel buffers, so that they can hold the required number of bytes\n     * If the pixel buffers already have the required capacity, then nothing is done\n     * @param {number} size in bytes\n     */\n    _reallocate(size)\n    {\n        // no need to reallocate\n        if(size <= this._pixelBuffer[0].byteLength)\n            return;\n\n        // reallocate\n        for(let i = 0; i < this._pixelBuffer.length; i++) {\n            const newBuffer = new Uint8Array(size);\n            //newBuffer.set(this._pixelBuffer[i]); // make this optional?\n            this._pixelBuffer[i] = newBuffer;\n        }\n    }\n\n    /**\n     * Allocate PBOs\n     * @param {SpeedyGPU} gpu\n     */\n    _allocatePBOs(gpu)\n    {\n        const gl = gpu.gl;\n\n        for(let i = 0; i < this._pbo.length; i++)\n            this._pbo[i] = gl.createBuffer();\n    }\n\n    /**\n     * Deallocate PBOs\n     * @param {SpeedyGPU} gpu\n     */\n    _deallocatePBOs(gpu)\n    {\n        const gl = gpu.gl;\n\n        for(let i = this._pbo.length - 1; i >= 0; i--) {\n            gl.deleteBuffer(this._pbo[i]);\n            this._pbo[i] = null;\n        }\n    }\n\n    /**\n     * Read pixels to a Uint8Array, asynchronously, using a Pixel Buffer Object (PBO)\n     * It's assumed that the target texture is in the RGBA8 format\n     * @param {WebGL2RenderingContext} gl\n     * @param {WebGLBuffer} pbo\n     * @param {Uint8Array} outputBuffer with size >= width * height * 4\n     * @param {WebGLFramebuffer} fbo\n     * @param {GLint} x\n     * @param {GLint} y\n     * @param {GLsizei} width\n     * @param {GLsizei} height\n     * @returns {SpeedyPromise<void>}\n     */\n    static _readPixelsViaPBO(gl, pbo, outputBuffer, fbo, x, y, width, height)\n    {\n        /*\n\n        When testing Speedy on Chrome (mobile) using about:tracing with the\n        --enable-gpu-service-tracing flag, I found that A LOT of time is spent\n        in TraceGLAPI::glMapBufferRange, which takes place just after\n        GLES2DecoderImpl::HandleReadPixels and GLES2DecoderImpl::glReadPixels.\n\n        Using multiple PBOs doesn't seem to impact Chrome too much. Performance\n        is much better on Firefox. This suggests there is room for improvement.\n        I do not yet understand clearly the cause for this lag on Chrome. It\n        may be a CPU-GPU synchronization issue.\n\n        EDIT: I have found that using gl.flush() aggressively greatly improves\n              things. WebGL commands will be pushed frequently!\n\n        See also:\n        https://www.khronos.org/registry/webgl/specs/latest/2.0/#3.7.3 (Buffer objects)\n        https://github.com/chromium/chromium/blob/master/docs/gpu/debugging_gpu_related_code.md\n\n        */\n        const size = width * height * 4;\n\n        // validate outputBuffer\n        Utils.assert(outputBuffer.byteLength >= size, `Invalid buffer size`);\n\n        // read pixels into the PBO\n        gl.bindBuffer(gl.PIXEL_PACK_BUFFER, pbo);\n        gl.bufferData(gl.PIXEL_PACK_BUFFER, size, gl.DYNAMIC_READ);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n        gl.readPixels(x, y, width, height, gl.RGBA, gl.UNSIGNED_BYTE, 0);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);\n\n        // create a fence\n        const sync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);\n        gl.flush(); // make sure the sync command is read\n\n        // wait for the commands to be processed by the GPU\n        return new SpeedyPromise((resolve, reject) => {\n            // according to the WebGL2 spec sec 3.7.14 Sync objects,\n            // \"sync objects may only transition to the signaled state\n            // when the user agent's event loop is not executing a task\"\n            // in other words, it won't be signaled in the same frame\n            runOnNextFrame(SpeedyTextureReader._clientWaitAsync, gl, sync, 0, resolve, reject);\n        }).then(() => {\n            gl.bindBuffer(gl.PIXEL_PACK_BUFFER, pbo);\n            gl.getBufferSubData(gl.PIXEL_PACK_BUFFER, 0, outputBuffer);\n            gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);\n        }).catch(err => {\n            throw new IllegalOperationError(`Can't getBufferSubDataAsync(): error in clientWaitAsync()`, err);\n        }).finally(() => {\n            gl.deleteSync(sync);\n        });\n    }\n\n    /**\n     * Waits for a sync object to become signaled\n     * @param {WebGL2RenderingContext} gl\n     * @param {WebGLSync} sync\n     * @param {GLbitfield} flags may be gl.SYNC_FLUSH_COMMANDS_BIT or 0\n     * @param {Function} resolve\n     * @param {Function} reject\n     * @param {number} [pollInterval] in milliseconds\n     * @param {number} [remainingAttempts] for timeout\n     */\n    static _clientWaitAsync(gl, sync, flags, resolve, reject, pollInterval = 10, remainingAttempts = 1000)\n    {\n        (function poll() {\n            const status = gl.clientWaitSync(sync, flags, 0);\n\n            if(remainingAttempts-- <= 0) {\n                reject(new TimeoutError(`_checkStatus() is taking too long.`, GLError.from(gl)));\n            }\n            else if(status === gl.CONDITION_SATISFIED || status === gl.ALREADY_SIGNALED) {\n                resolve();\n            }\n            else {\n                //Utils.setZeroTimeout(poll); // no ~4ms delay, resource-hungry\n                //setTimeout(poll, pollInterval); // easier on the CPU\n                requestAnimationFrame(poll); // RAF is a rather unusual way to do polling at ~60 fps. Does it reduce CPU usage?\n            }\n        })();\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-texture-uploader.js\n * A utility that helps uploading data to textures\n */\n\nimport { SpeedyGPU } from './speedy-gpu';\nimport { SpeedyTexture } from './speedy-texture';\nimport { SpeedyMediaSource } from '../core/speedy-media-source';\n\n/**\n * A utility that helps uploading data to textures\n */\nexport class SpeedyTextureUploader\n{\n    /**\n     * Constructor\n     * @param {SpeedyGPU} gpu\n     */\n    constructor(gpu)\n    {\n        /** @type {SpeedyGPU} GPU instance */\n        this._gpu = gpu;\n    }\n\n    /**\n     * Upload an image to the GPU\n     * @param {SpeedyMediaSource} source\n     * @param {SpeedyTexture} outputTexture\n     * @returns {SpeedyTexture} output texture\n     */\n    upload(source, outputTexture)\n    {\n        const data = source.data;\n\n        // bugfix: if the media is a video, we can't really\n        // upload it to the GPU unless it's ready\n        //if(data.constructor.name == 'HTMLVideoElement') {\n        if(data instanceof HTMLVideoElement) {\n            if(data.readyState < 2) {\n                // this may happen when the video loops (Firefox)\n                // return the previously uploaded texture\n                //Utils.warning(`Trying to process a video that isn't ready yet`);\n                return outputTexture;\n            }\n        }\n\n        // upload to the output texture\n        return outputTexture.upload(data, source.width, source.height);\n    }\n\n    /**\n     * Release the texture uploader\n     * @returns {null}\n     */\n    release()\n    {\n        return null;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-texture.js\n * A wrapper around WebGLTexture\n */\n\nimport { SpeedyGPU } from './speedy-gpu';\nimport { Utils } from '../utils/utils';\nimport { IllegalOperationError, IllegalArgumentError, NotSupportedError, GLError } from '../utils/errors';\nimport { MAX_TEXTURE_LENGTH } from '../utils/globals';\n\n/**\n * Get a buffer filled with zeros\n * @param {number} size number of bytes\n * @returns {Uint8Array}\n */\n/*\nconst zeros = (function() {\n    let buffer = new Uint8Array(4);\n\n    return function(size) {\n        if(size > buffer.length)\n            buffer = new Uint8Array(size);\n\n        return buffer.subarray(0, size);\n    }\n})();\n*/\n\n/**\n * A wrapper around WebGLTexture\n */\nexport class SpeedyTexture\n{\n    /**\n     * Constructor\n     * @param {WebGL2RenderingContext} gl\n     * @param {number} width texture width in pixels\n     * @param {number} height texture height in pixels\n     * @param {number} [format]\n     * @param {number} [internalFormat]\n     * @param {number} [dataType]\n     * @param {number} [filter]\n     * @param {number} [wrap]\n     */\n    constructor(gl, width, height, format = gl.RGBA, internalFormat = gl.RGBA8, dataType = gl.UNSIGNED_BYTE, filter = gl.NEAREST, wrap = gl.MIRRORED_REPEAT)\n    {\n        /** @type {WebGL2RenderingContext} rendering context */\n        this._gl = gl;\n\n        /** @type {number} width of the texture */\n        this._width = Math.max(1, width | 0);\n\n        /** @type {number} height of the texture */\n        this._height = Math.max(1, height | 0);\n\n        /** @type {boolean} have we generated mipmaps for this texture? */\n        this._hasMipmaps = false;\n\n        /** @type {number} texture format */\n        this._format = format;\n\n        /** @type {number} internal format (usually a sized format) */\n        this._internalFormat = internalFormat;\n\n        /** @type {number} data type */\n        this._dataType = dataType;\n\n        /** @type {number} texture filtering (min & mag) */\n        this._filter = filter;\n\n        /** @type {number} texture wrapping */\n        this._wrap = wrap;\n\n        /** @type {WebGLTexture} internal texture object */\n        this._glTexture = SpeedyTexture._createTexture(this._gl, this._width, this._height, this._format, this._internalFormat, this._dataType, this._filter, this._wrap);\n    }\n\n    /**\n     * Releases the texture\n     * @returns {null}\n     */\n    release()\n    {\n        const gl = this._gl;\n\n        // already released?\n        if(this._glTexture == null)\n            throw new IllegalOperationError(`The SpeedyTexture has already been released`);\n\n        // release resources\n        this.discardMipmaps();\n        gl.deleteTexture(this._glTexture);\n        this._glTexture = null;\n        this._width = this._height = 0;\n\n        // done!\n        return null;\n    }\n\n    /**\n     * Upload pixel data to the texture. The texture will be resized if needed.\n     * @param {TexImageSource} pixels\n     * @param {number} [width] in pixels\n     * @param {number} [height] in pixels\n     * @return {SpeedyTexture} this\n     */\n    upload(pixels, width = this._width, height = this._height)\n    {\n        const gl = this._gl;\n        Utils.assert(width > 0 && height > 0);\n\n        this.discardMipmaps();\n        this._width = width;\n        this._height = height;\n        this._internalFormat = gl.RGBA8;\n        this._format = gl.RGBA;\n        this._dataType = gl.UNSIGNED_BYTE;\n\n        SpeedyTexture._upload(gl, this._glTexture, this._width, this._height, pixels, 0, this._format, this._internalFormat, this._dataType);\n        return this;\n    }\n\n    /**\n     * Clear the texture\n     * @returns {this}\n     */\n    clear()\n    {\n        const gl = this._gl;\n\n        // context loss?\n        if(gl.isContextLost())\n            return this;\n\n        // clear texture data\n        gl.bindTexture(gl.TEXTURE_2D, this._glTexture);\n        gl.texImage2D(gl.TEXTURE_2D, 0, this._internalFormat, this._width, this._height, 0, this._format, this._dataType, null);\n        gl.bindTexture(gl.TEXTURE_2D, null);\n\n        // no mipmaps\n        this.discardMipmaps();\n\n        // done!\n        return this;\n    }\n\n    /**\n     * Resize this texture. Its content will be lost!\n     * @param {number} width new width, in pixels\n     * @param {number} height new height, in pixels\n     * @returns {this}\n     */\n    resize(width, height)\n    {\n        const gl = this._gl;\n\n        // no need to resize?\n        if(this._width === width && this._height === height)\n            return this;\n\n        // validate size\n        width |= 0; height |= 0;\n        if(width > MAX_TEXTURE_LENGTH || height > MAX_TEXTURE_LENGTH)\n            throw new NotSupportedError(`Maximum texture size exceeded. Using ${width} x ${height}, expected up to ${MAX_TEXTURE_LENGTH} x ${MAX_TEXTURE_LENGTH}.`);\n        else if(width < 1 || height < 1)\n            throw new IllegalArgumentError(`Invalid texture size: ${width} x ${height}`);\n\n        // context loss?\n        if(gl.isContextLost())\n            return this;\n\n        // update dimensions\n        this._width = width;\n        this._height = height;\n\n        // resize\n        // Note: this is fast on Chrome, but seems slow on Firefox\n        gl.bindTexture(gl.TEXTURE_2D, this._glTexture);\n        gl.texImage2D(gl.TEXTURE_2D, 0, this._internalFormat, this._width, this._height, 0, this._format, this._dataType, null);\n        gl.bindTexture(gl.TEXTURE_2D, null);\n\n        // no mipmaps\n        this.discardMipmaps();\n\n        // done!\n        return this;\n    }\n\n    /**\n     * Generate mipmap\n     * @param {SpeedyDrawableTexture[]} [mipmap] custom texture for each mip level\n     * @returns {SpeedyTexture} this\n     */\n    generateMipmaps(mipmap = [])\n    {\n        const gl = this._gl;\n\n        // nothing to do\n        if(this._hasMipmaps)\n            return this;\n\n        // let the hardware compute the all levels of the pyramid, up to 1x1\n        // we also specify the TEXTURE_MIN_FILTER to be used from now on\n        gl.bindTexture(gl.TEXTURE_2D, this._glTexture);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST_MIPMAP_LINEAR);\n        gl.generateMipmap(gl.TEXTURE_2D);\n        gl.bindTexture(gl.TEXTURE_2D, null);\n\n        // accept custom textures\n        if(mipmap.length > 0) {\n            // expected number of mipmap levels according to the OpenGL ES 3.0 spec (sec 3.8.10.4)\n            const width = this.width, height = this.height;\n            const numMipmaps = 1 + Math.floor(Math.log2(Math.max(width, height)));\n            Utils.assert(mipmap.length <= numMipmaps);\n\n            // verify the dimensions of each level\n            for(let level = 1; level < mipmap.length; level++) {\n                // use max(1, floor(size / 2^lod)), in accordance to\n                // the OpenGL ES 3.0 spec sec 3.8.10.4 (Mipmapping)\n                const w = Math.max(1, width >>> level);\n                const h = Math.max(1, height >>> level);\n\n                // verify the dimensions of this level\n                Utils.assert(mipmap[level].width === w && mipmap[level].height === h);\n\n                // copy to mipmap\n                mipmap[level].copyTo(this, level);\n            }\n        }\n\n        // done!\n        this._hasMipmaps = true;\n        return this;\n    }\n\n    /**\n     * Invalidates previously generated mipmap, if any\n     */\n    discardMipmaps()\n    {\n        const gl = this._gl;\n\n        // nothing to do\n        if(!this._hasMipmaps)\n            return;\n\n        // reset the min filter\n        gl.bindTexture(gl.TEXTURE_2D, this._glTexture);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, this._filter);\n        gl.bindTexture(gl.TEXTURE_2D, null);\n\n        // done!\n        this._hasMipmaps = false;\n    }\n\n    /**\n     * Does this texture have a mipmap?\n     * @returns {boolean}\n     */\n    hasMipmaps()\n    {\n        return this._hasMipmaps;\n    }\n\n    /**\n     * Has this texture been released?\n     * @returns {boolean}\n     */\n    isReleased()\n    {\n        return this._glTexture == null;\n    }\n\n    /**\n     * The size of this texture, in bytes\n     * @returns {number}\n     */\n    size()\n    {\n        // RGBA8: 32 bits per pixel\n        return 4 * this._width * this._height;\n    }\n\n    /**\n     * The internal WebGLTexture\n     * @returns {WebGLTexture}\n     */\n    get glTexture()\n    {\n        return this._glTexture;\n    }\n\n    /**\n     * The width of the texture, in pixels\n     * @returns {number}\n     */\n    get width()\n    {\n        return this._width;\n    }\n\n    /**\n     * The height of the texture, in pixels\n     * @returns {number}\n     */\n    get height()\n    {\n        return this._height;\n    }\n\n    /**\n     * The WebGL Context\n     * @returns {WebGL2RenderingContext}\n     */\n    get gl()\n    {\n        return this._gl;\n    }\n\n    /**\n     * Create a WebGL texture\n     * @param {WebGL2RenderingContext} gl\n     * @param {number} width in pixels\n     * @param {number} height in pixels\n     * @param {number} format usually gl.RGBA\n     * @param {number} internalFormat usually gl.RGBA8\n     * @param {number} dataType usually gl.UNSIGNED_BYTE\n     * @param {number} filter usually gl.NEAREST or gl.LINEAR\n     * @param {number} wrap gl.REPEAT, gl.MIRRORED_REPEAT or gl.CLAMP_TO_EDGE\n     * @returns {WebGLTexture}\n     */\n    static _createTexture(gl, width, height, format, internalFormat, dataType, filter, wrap)\n    {\n        Utils.assert(width > 0 && height > 0);\n\n        // create & bind texture\n        const texture = gl.createTexture();\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n\n        // setup\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrap);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrap);\n        //gl.texStorage2D(gl.TEXTURE_2D, 1, internalFormat, width, height);\n        gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, width, height, 0, format, dataType, null);\n\n        // unbind & return\n        gl.bindTexture(gl.TEXTURE_2D, null);\n        return texture;\n    }\n    /**\n     * Upload pixel data to a WebGL texture\n     * @param {WebGL2RenderingContext} gl\n     * @param {WebGLTexture} texture\n     * @param {GLsizei} width texture width\n     * @param {GLsizei} height texture height\n     * @param {TexImageSource} pixels\n     * @param {GLint} lod mipmap level-of-detail\n     * @param {number} format\n     * @param {number} internalFormat\n     * @param {number} dataType\n     * @returns {WebGLTexture} texture\n     */\n    static _upload(gl, texture, width, height, pixels, lod, format, internalFormat, dataType)\n    {\n        // Prefer calling _upload() before gl.useProgram() to avoid the\n        // needless switching of GL programs internally. See also:\n        // https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n\n        /*\n        // slower than texImage2D, unlike the spec?\n        gl.texSubImage2D(gl.TEXTURE_2D,     // target\n                         lod,               // mip level\n                         0,                 // x-offset\n                         0,                 // y-offset\n                         width,             // texture width\n                         height,            // texture height\n                         gl.RGBA,           // source format\n                         gl.UNSIGNED_BYTE,  // source type\n                         pixels);           // source data\n        */\n\n        gl.texImage2D(gl.TEXTURE_2D,        // target\n                      lod,                  // mip level\n                      internalFormat,       // internal format\n                      width,                // texture width\n                      height,               // texture height\n                      0,                    // border\n                      format,               // source format\n                      dataType,             // source type\n                      pixels);              // source data\n\n        gl.bindTexture(gl.TEXTURE_2D, null);\n        return texture;\n    }\n}\n\n/**\n * A SpeedyTexture with a framebuffer\n */\nexport class SpeedyDrawableTexture extends SpeedyTexture\n{\n    /**\n     * Constructor\n     * @param {WebGL2RenderingContext} gl\n     * @param {number} width texture width in pixels\n     * @param {number} height texture height in pixels\n     * @param {number} [format]\n     * @param {number} [internalFormat]\n     * @param {number} [dataType]\n     * @param {number} [filter]\n     * @param {number} [wrap]\n     */\n    constructor(gl, width, height, format = undefined, internalFormat = undefined, dataType = undefined, filter = undefined, wrap = undefined)\n    {\n        super(gl, width, height, format, internalFormat, dataType, filter, wrap);\n\n        /** @type {WebGLFramebuffer} framebuffer */\n        this._glFbo = SpeedyDrawableTexture._createFramebuffer(gl, this._glTexture);\n    }\n\n    /**\n     * Releases the texture\n     * @returns {null}\n     */\n    release()\n    {\n        const gl = this._gl;\n\n        // already released?\n        if(this._glFbo == null)\n            throw new IllegalOperationError(`The SpeedyDrawableTexture has already been released`);\n\n        // release the framebuffer\n        gl.deleteFramebuffer(this._glFbo);\n        this._glFbo = null;\n\n        // release the SpeedyTexture\n        return super.release();\n    }\n\n    /**\n     * The internal WebGLFramebuffer\n     * @returns {WebGLFramebuffer}\n     */\n    get glFbo()\n    {\n        return this._glFbo;\n    }\n\n    /**\n     * Copy this texture into another\n     * (you may have to discard the mipmaps after calling this function)\n     * @param {SpeedyTexture} texture target texture\n     * @param {number} [lod] level-of-detail of the target texture\n     */\n    copyTo(texture, lod = 0)\n    {\n        const gl = this._gl;\n\n        // context loss?\n        if(gl.isContextLost())\n            return;\n\n        // compute texture size as max(1, floor(size / 2^lod)),\n        // in accordance to the OpenGL ES 3.0 spec sec 3.8.10.4\n        // (Mipmapping)\n        const pot = 1 << (lod |= 0);\n        const expectedWidth = Math.max(1, Math.floor(texture.width / pot));\n        const expectedHeight = Math.max(1, Math.floor(texture.height / pot));\n\n        // validate\n        Utils.assert(this._width === expectedWidth && this._height === expectedHeight);\n\n        // copy to texture\n        SpeedyDrawableTexture._copyToTexture(gl, this._glFbo, texture.glTexture, 0, 0, this._width, this._height, lod);\n    }\n\n    /*\n     * Resize this texture\n     * @param {number} width new width, in pixels\n     * @param {number} height new height, in pixels\n     * @param {boolean} [preserveContent] should we preserve the content of the texture? EXPENSIVE!\n     * @returns {this}\n     */\n    /*resize(width, height, preserveContent = false)\n    {\n        const gl = this._gl;\n\n        // no need to preserve the content?\n        if(!preserveContent)\n            return super.resize(width, height);\n\n        // no need to resize?\n        if(this._width === width && this._height === height)\n            return this;\n\n        // validate size\n        width |= 0; height |= 0;\n        Utils.assert(width > 0 && height > 0);\n\n        // context loss?\n        if(gl.isContextLost())\n            return this;\n\n        // allocate new texture\n        const newTexture = SpeedyTexture._createTexture(gl, width, height);\n\n        // initialize the new texture with zeros to avoid a\n        // warning when calling copyTexSubImage2D() on Firefox\n        // this may not be very efficient?\n        SpeedyTexture._upload(gl, newTexture, width, height, zeros(width * height * 4)); // RGBA: 4 bytes per pixel\n\n        // copy the old texture to the new one\n        const oldWidth = this._width, oldHeight = this._height;\n        SpeedyDrawableTexture._copyToTexture(gl, this._glFbo, newTexture, 0, 0, Math.min(width, oldWidth), Math.min(height, oldHeight), 0);\n\n        // bind FBO\n        gl.bindFramebuffer(gl.FRAMEBUFFER, this._glFbo);\n\n        // invalidate old data (is this needed?)\n        gl.invalidateFramebuffer(gl.FRAMEBUFFER, [gl.COLOR_ATTACHMENT0]);\n\n        // attach the new texture to the existing framebuffer\n        gl.framebufferTexture2D(gl.FRAMEBUFFER,         // target\n                                gl.COLOR_ATTACHMENT0,   // color buffer\n                                gl.TEXTURE_2D,          // tex target\n                                newTexture,             // texture\n                                0);                     // mipmap level\n\n        // unbind FBO\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\n        // release the old texture and replace it\n        gl.deleteTexture(this._glTexture);\n        this._glTexture = newTexture;\n\n        // update dimensions & discard mipmaps\n        this.discardMipmaps();\n        this._width = width;\n        this._height = height;\n\n        // done!\n        return this;\n    }\n    */\n\n    /**\n     * Clear the texture\n     * @returns {this}\n     */\n    clear()\n    {\n        //\n        // When we pass null to texImage2D(), it seems that Firefox\n        // doesn't clear the texture. Instead, it displays this warning:\n        //\n        // \"WebGL warning: drawArraysInstanced:\n        //  Tex image TEXTURE_2D level 0 is incurring lazy initialization.\"\n        //\n        // Here is a workaround:\n        //\n        return this.clearToColor(0, 0, 0, 0);\n    }\n\n    /**\n     * Clear the texture to a color\n     * @param {number} r red component, a value in [0,1]\n     * @param {number} g green component, a value in [0,1]\n     * @param {number} b blue component, a value in [0,1]\n     * @param {number} a alpha component, a value in [0,1]\n     * @returns {this}\n     */\n    clearToColor(r, g, b, a)\n    {\n        const gl = this._gl;\n\n        // context loss?\n        if(gl.isContextLost())\n            return this;\n\n        // clamp parameters\n        r = Math.max(0.0, Math.min(+r, 1.0));\n        g = Math.max(0.0, Math.min(+g, 1.0));\n        b = Math.max(0.0, Math.min(+b, 1.0));\n        a = Math.max(0.0, Math.min(+a, 1.0));\n\n        // discard mipmaps, if any\n        this.discardMipmaps();\n\n        // clear the texture\n        gl.bindFramebuffer(gl.FRAMEBUFFER, this._glFbo);\n        gl.viewport(0, 0, this._width, this._height);\n        gl.clearColor(r, g, b, a);\n        gl.clear(gl.COLOR_BUFFER_BIT);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\n        // done!\n        return this;\n    }\n\n    /**\n     * Create a FBO associated with an existing texture\n     * @param {WebGL2RenderingContext} gl\n     * @param {WebGLTexture} texture\n     * @returns {WebGLFramebuffer}\n     */\n    static _createFramebuffer(gl, texture)\n    {\n        const fbo = gl.createFramebuffer();\n\n        // setup framebuffer\n        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n        gl.framebufferTexture2D(gl.FRAMEBUFFER,         // target\n                                gl.COLOR_ATTACHMENT0,   // color buffer\n                                gl.TEXTURE_2D,          // tex target\n                                texture,                // texture\n                                0);                     // mipmap level\n\n        // check for errors\n        const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n        if(status != gl.FRAMEBUFFER_COMPLETE) {\n            const error = (() => (([\n                'FRAMEBUFFER_UNSUPPORTED',\n                'FRAMEBUFFER_INCOMPLETE_ATTACHMENT',\n                'FRAMEBUFFER_INCOMPLETE_DIMENSIONS',\n                'FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT',\n                'FRAMEBUFFER_INCOMPLETE_MULTISAMPLE'\n            ].filter(err => gl[err] === status))[0] || 'unknown error'))();\n            throw new GLError(`Can't create framebuffer: ${error} (${status})`);\n        }\n\n        // unbind & return\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        return fbo;\n    }\n\n    /**\n     * Copy data from a framebuffer to a texture\n     * @param {WebGL2RenderingContext} gl\n     * @param {WebGLFramebuffer} fbo we'll read the data from this\n     * @param {WebGLTexture} texture destination texture\n     * @param {GLint} x xpos (where to start copying)\n     * @param {GLint} y ypos (where to start copying)\n     * @param {GLsizei} width width of the texture\n     * @param {GLsizei} height height of the texture\n     * @param {GLint} [lod] mipmap level-of-detail\n     * @returns {WebGLTexture} texture\n     */\n    static _copyToTexture(gl, fbo, texture, x, y, width, height, lod = 0)\n    {\n        //gl.activeTexture(gl.TEXTURE0);\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n\n        gl.copyTexSubImage2D(\n            gl.TEXTURE_2D, // target\n            lod, // mipmap level\n            0, // xoffset\n            0, // yoffset\n            x, // xpos (where to start copying)\n            y, // ypos (where to start copying)\n            width, // width of the texture\n            height // height of the texture\n        );\n\n        /*\n        gl.copyTexImage2D(\n            gl.TEXTURE_2D, // target\n            lod, // mipmap level\n            gl.RGBA, // internal format\n            x, // xpos (where to start copying)\n            y, // ypos (where to start copying)\n            width, // width of the texture\n            height, // height of the texture\n            0 // border\n        );\n        */\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        gl.bindTexture(gl.TEXTURE_2D, null);\n\n        return texture;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * errors.js\n * Error classes\n */\n\n/** @typedef {SpeedyError|Error|null} SpeedyErrorCause */\n\n/**\n * Generic error class for Speedy\n */\nexport class SpeedyError extends Error\n{\n    /**\n     * Class constructor\n     * @param {string} message message text\n     * @param {SpeedyErrorCause} [cause] cause of the error\n     */\n    constructor(message, cause = null)\n    {\n        super([\n            message,\n            cause ? cause.toString() : '[speedy-vision.js]'\n        ].join('\\n-> '));\n\n        /** @type {SpeedyErrorCause} cause of the error */\n        this._cause = cause;\n    }\n\n    /**\n     * Error name\n     * @returns {string}\n     */\n    get name()\n    {\n        return this.constructor.name;\n    }\n\n    /**\n     * Set error name (ignored)\n     * @param {string} _ ignored\n     */\n    set name(_)\n    {\n        void(0);\n    }\n\n    /**\n     * Get the cause of the error. Available if\n     * it has been specified in the constructor\n     * @returns {SpeedyErrorCause}\n     */\n    get cause()\n    {\n        return this._cause;\n    }\n}\n\n/**\n * Unsupported operation error\n * The requested operation is not supported\n */\nexport class NotSupportedError extends SpeedyError\n{\n    /**\n     * Class constructor\n     * @param {string} [message] additional text\n     * @param {SpeedyErrorCause} [cause] cause of the error\n     */\n    constructor(message = '', cause = null)\n    {\n        super(`Unsupported operation. ${message}`, cause);\n    }\n}\n\n/**\n * Not implemented error\n * The called method is not implemented\n */\nexport class NotImplementedError extends SpeedyError\n{\n    /**\n     * Class constructor\n     * @param {string} [message] additional text\n     * @param {SpeedyErrorCause} [cause] cause of the error\n     */\n    constructor(message = '', cause = null)\n    {\n        super(`Method not implemented. ${message}`, cause);\n    }\n}\n\n/**\n * WebGL error\n */\nexport class GLError extends SpeedyError\n{\n    /**\n     * Class constructor\n     * @param {string} [message] additional text\n     * @param {SpeedyErrorCause} [cause] cause of the error\n     */\n    constructor(message = '', cause = null)\n    {\n        super(`WebGL error. ${message}`, cause);\n    }\n\n    /**\n     * Get an error object describing the latest WebGL error\n     * @param {WebGL2RenderingContext} gl\n     * @returns {GLError}\n     */\n    static from(gl)\n    {\n        const recognizedErrors = [\n            'NO_ERROR',\n            'INVALID_ENUM',\n            'INVALID_VALUE',\n            'INVALID_OPERATION',\n            'INVALID_FRAMEBUFFER_OPERATION',\n            'OUT_OF_MEMORY',\n            'CONTEXT_LOST_WEBGL',\n        ];\n\n        const glError = gl.getError();\n        const message = recognizedErrors.find(error => gl[error] == glError) || 'Unknown';\n        return new GLError(message);\n    }\n}\n\n/**\n * AbstractMethodError\n * Thrown when one tries to call an abstract method\n */\nexport class AbstractMethodError extends SpeedyError\n{\n    /**\n     * Class constructor\n     * @param {string} [message] additional text\n     * @param {SpeedyErrorCause} [cause] cause of the error\n     */\n    constructor(message = '', cause = null)\n    {\n        super(`Can't call abstract method. ${message}`, cause);\n    }\n}\n\n/**\n * Illegal argument error\n * A method has received one or more illegal arguments\n */\nexport class IllegalArgumentError extends SpeedyError\n{\n    /**\n     * Class constructor\n     * @param {string} [message] additional text\n     * @param {SpeedyErrorCause} [cause] cause of the error\n     */\n    constructor(message = '', cause = null)\n    {\n        super(`Illegal argument. ${message}`, cause);\n    }\n}\n\n/**\n * Illegal operation error\n * The method arguments are valid, but the method can't\n * be called due to the current the state of the object\n */\nexport class IllegalOperationError extends SpeedyError\n{\n    /**\n     * Class constructor\n     * @param {string} [message] additional text\n     * @param {SpeedyErrorCause} [cause] cause of the error\n     */\n    constructor(message = '', cause = null)\n    {\n        super(`Illegal operation. ${message}`, cause);\n    }\n}\n\n/**\n * Out of memory\n */\nexport class OutOfMemoryError extends SpeedyError\n{\n    /**\n     * Class constructor\n     * @param {string} [message] additional text\n     * @param {SpeedyErrorCause} [cause] cause of the error\n     */\n    constructor(message = '', cause = null)\n    {\n        super(`Out of memory. ${message}`, cause);\n    }\n}\n\n/**\n * File not found error\n */\nexport class FileNotFoundError extends SpeedyError\n{\n    /**\n     * Class constructor\n     * @param {string} [message] additional text\n     * @param {SpeedyErrorCause} [cause] cause of the error\n     */\n    constructor(message = '', cause = null)\n    {\n        super(`File not found. ${message}`, cause);\n    }\n}\n\n/**\n * Timeout error\n */\nexport class TimeoutError extends SpeedyError\n{\n    /**\n     * Class constructor\n     * @param {string} [message] additional text\n     * @param {SpeedyErrorCause} [cause] cause of the error\n     */\n    constructor(message = '', cause = null)\n    {\n        super(`Timeout error. ${message}`, cause);\n    }\n}\n\n/**\n * Parse error\n */\nexport class ParseError extends SpeedyError\n{\n    /**\n     * Class constructor\n     * @param {string} [message] additional text\n     * @param {SpeedyErrorCause} [cause] cause of the error\n     */\n    constructor(message = '', cause = null)\n    {\n        super(`Parse error. ${message}`, cause);\n    }\n}\n\n/**\n * Assertion error\n */\nexport class AssertionError extends SpeedyError\n{\n    /**\n     * Class constructor\n     * @param {string} [message] additional text\n     * @param {SpeedyErrorCause} [cause] cause of the error\n     */\n    constructor(message = '', cause = null)\n    {\n        super(`Assertion failed. ${message}`, cause);\n    }\n}\n\n/**\n * Access denied\n */\nexport class AccessDeniedError extends SpeedyError\n{\n    /**\n     * Class constructor\n     * @param {string} [message] additional text\n     * @param {SpeedyErrorCause} [cause] cause of the error\n     */\n    constructor(message = '', cause = null)\n    {\n        super(`Access denied. ${message}`, cause);\n    }\n}\n\n/**\n * WebAssembly error\n */\nexport class WebAssemblyError extends SpeedyError\n{\n    /**\n     * Class constructor\n     * @param {string} [message] additional text\n     * @param {SpeedyErrorCause} [cause] cause of the error\n     */\n    constructor(message = '', cause = null)\n    {\n        super(`WebAssembly error. ${message}`, cause);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * fps-counter.js\n * A FPS counter\n */\n\nimport { IllegalOperationError } from './errors';\n\n/** @const {number} update interval in milliseconds */\nconst UPDATE_INTERVAL = 500;\n\n/** @type {FPSCounter|null} Singleton */\nlet instance = null;\n\n/**\n * FPS counter\n */\nexport class FPSCounter\n{\n    /**\n     * Creates a new FPSCounter\n     * @private\n     */\n    constructor()\n    {\n        /** @type {number} current FPS rate */\n        this._fps = 60;\n\n        /** @type {number} frame counter */\n        this._frames = 0;\n\n        /** @type {number} update interval in milliseconds */\n        this._updateInterval = UPDATE_INTERVAL;\n\n        /** @type {number} time of the last update */\n        this._lastUpdate = performance.now();\n\n        /** @type {function(): void} bound update function */\n        this._boundUpdate = this._update.bind(this);\n\n\n\n        // this should never happen...\n        if(instance !== null)\n            throw new IllegalOperationError(`Can't have multiple instances of FPSCounter`);\n\n        // start FPS counter\n        this._boundUpdate();\n    }\n\n    /**\n     * Gets an instance of the FPS counter.\n     * We use lazy loading, i.e., we will not\n     * create a FPS counter unless we need to!\n     * @returns {FPSCounter}\n     */\n    static get instance()\n    {\n        if(instance === null)\n            instance = new FPSCounter();\n\n        return instance;\n    }\n\n    /**\n     * Get the FPS rate\n     * @returns {number} frames per second\n     */\n    get fps()\n    {\n        return this._fps;\n    }\n\n    /**\n     * Updates the FPS counter\n     */\n    _update()\n    {\n        const now = performance.now();\n        const deltaTime = now - this._lastUpdate;\n\n        if(deltaTime >= this._updateInterval) {\n            this._fps = Math.round(this._frames / (deltaTime * 0.001));\n            this._frames = 0;\n            this._lastUpdate = now;\n        }\n\n        this._frames++;\n        requestAnimationFrame(this._boundUpdate);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * globals.js\n * Global constants\n */\n\n// -----------------------------------------------------------------\n// IMAGE PYRAMIDS & SCALE-SPACE\n// -----------------------------------------------------------------\n\n/** @type {number} The maximum number of levels in a pyramid, considering a scale factor of 2x between levels */\nexport const PYRAMID_MAX_LEVELS = 8;\n\n/** @type {number} The base-2 logarithm of PYRAMID_MAX_SCALE */\nexport const LOG2_PYRAMID_MAX_SCALE = 0;\n\n/** @type {number} The maximum supported scale for a pyramid level */\nexport const PYRAMID_MAX_SCALE = 1 << LOG2_PYRAMID_MAX_SCALE;\n\n\n\n// -----------------------------------------------------------------\n// FIXED-POINT MATH\n// -----------------------------------------------------------------\n\n/** @type {number} How many bits do we use to store fractional data? */\nexport const FIX_BITS = 3; // step size: 0.125 = 1/2^FIX_BITS\n\n/** @type {number} Fixed-point resolution */\nexport const FIX_RESOLUTION = 1 << FIX_BITS; // float(2^(FIX_BITS))\n\n\n\n// -----------------------------------------------------------------\n// TEXTURE LIMITS\n// -----------------------------------------------------------------\n\n/** @type {number} Maximum texture length (width, height) */\nexport const MAX_TEXTURE_LENGTH = (1 << (16 - FIX_BITS)) - 1; // must be 2^n - 1 due to keypoint encoding\n\n\n\n// -----------------------------------------------------------------\n// KEYPOINTS\n// -----------------------------------------------------------------\n\n/** @type {number} Size of a keypoint header, in bytes (must be divisible by 4) */\nexport const MIN_KEYPOINT_SIZE = 8;\n\n/** @type {number} Minimum length of a keypoint encoder, in pixels (encodes at least 1 keypoint) */\nexport const MIN_ENCODER_LENGTH = 2; // capacity computations are based on this // Math.ceil(Math.sqrt(MIN_KEYPOINT_SIZE / 4));\n\n/** @type {number} Maximum number of keypoints we can encode (the actual length of the encoder may vary) */\nexport const MAX_ENCODER_CAPACITY = 8192;\n\n/** @type {number} Default capacity of a keypoint encoder (64x64 texture with 2 pixels per keypoint) */\nexport const DEFAULT_ENCODER_CAPACITY = 2048;\n\n/** @type {number} log2 of MAX_DESCRIPTOR_SIZE */\nexport const LOG2_MAX_DESCRIPTOR_SIZE = 6;\n\n/** @type {number} maximum size of a keypoint descriptor, in bytes */\nexport const MAX_DESCRIPTOR_SIZE = 1 << LOG2_MAX_DESCRIPTOR_SIZE;\n\n/** @type {number} How many bits will we use when encoding the index of a keypoint match? */\nexport const MATCH_INDEX_BITS = 32 - (LOG2_MAX_DESCRIPTOR_SIZE + 3); // 32 - log2(MAX_DESCRIPTOR_SIZE * 8)\n\n/** @type {number} Bitwise mask to extract a keypoint index from an encoded match */\nexport const MATCH_INDEX_MASK = (1 << MATCH_INDEX_BITS) - 1;\n\n/** @type {number} Maximum size of the database of keypoints for matching */\nexport const MATCH_MAX_INDEX = (1 << MATCH_INDEX_BITS) - 1;\n\n/** @type {number} The maximum distance that can be stored in a match */\nexport const MATCH_MAX_DISTANCE = (1 << (32 - MATCH_INDEX_BITS)) - 1;\n\n\n\n// -----------------------------------------------------------------\n// MISC\n// -----------------------------------------------------------------\n\n/** @type {boolean} Are we in a little-endian machine? */\nexport const LITTLE_ENDIAN = (function() {\n    return 0xCAFE === (new Uint16Array(new Uint8Array([0xFE, 0xCA]).buffer))[0];\n})();","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * observable.js\n * Observer design pattern\n */\n\n/**\n * Implementation of the Observer design pattern\n * @abstract\n */\nexport class Observable\n{\n    /**\n     * Constructor\n     */\n    constructor()\n    {\n        /** @type {Function[]} subscribers / callbacks */\n        this._subscribers = [];\n\n        /** @type {object[]} \"this\" pointers */\n        this._thisptr = [];\n\n        /** @type {Array<any[]>} function arguments */\n        this._args = [];\n    }\n\n    /**\n     * Add subscriber\n     * @param {Function} fn callback\n     * @param {object} [thisptr] \"this\" pointer to be used when invoking the callback\n     * @param {...any} args arguments to be passed to the callback\n     */\n    subscribe(fn, thisptr, ...args)\n    {\n        this._subscribers.push(fn);\n        this._thisptr.push(thisptr);\n        this._args.push(args);\n    }\n\n    /**\n     * Remove subscriber\n     * @param {Function} fn previously added callback\n     * @param {object} [thisptr] \"this\" pointer\n     */\n    unsubscribe(fn, thisptr)\n    {\n        for(let j = this._subscribers.length - 1; j >= 0; j--) {\n            if(this._subscribers[j] === fn && this._thisptr[j] === thisptr) {\n                this._subscribers.splice(j, 1);\n                this._thisptr.splice(j, 1);\n                this._args.splice(j, 1);\n                break;\n            }\n        }\n    }\n\n    /**\n     * Notify all subscribers about a state change\n     * @protected\n     */\n    _notify()\n    {\n        for(let i = 0; i < this._subscribers.length; i++)\n            this._subscribers[i].call(this._thisptr[i], ...(this._args[i]));\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-promise.js\n * Speedy Promises: a fast implementation of Promises\n */\n\nconst PENDING = 0;\nconst FULFILLED = 1;\nconst REJECTED = 2;\n\nconst SUSPEND_ASYNC = 1;\nconst asap = (typeof queueMicrotask !== 'undefined' && queueMicrotask) || // browsers\n             (typeof process !== 'undefined' && process.nextTick) || // node.js\n             (f => Promise.resolve().then(() => f())); // most compatible\n\n/**\n * SpeedyPromise: Super Fast Promises. SpeedyPromises can\n * interoperate with ES6 Promises. This implementation is\n * based on the Promises/A+ specification.\n * @template T\n */\nexport class SpeedyPromise\n{\n    /**\n     * Constructor\n     * @param {function(function(T=): void, function(Error): void): void} callback\n     */\n    constructor(callback)\n    {\n        this._state = PENDING;\n        this._value = undefined;\n\n        this._onFulfillment = null;\n        this._onRejection = null;\n        this._children = 0;\n        this[0] = this;\n        this._parent = undefined;\n        this._flags = 0;\n\n        this._fulfill = this._fulfill.bind(this);\n        this._reject = this._reject.bind(this);\n        this._resolve = this._resolve.bind(this);\n        this._broadcastIfAsync = this._broadcastIfAsync.bind(this);\n\n        callback(this._fulfill, this._reject);\n    }\n\n    /**\n     * Setup handlers\n     * @template U, V=never\n     * @param {null|undefined|(function(T): U|PromiseLike<U>|SpeedyPromise<U>)} onFulfillment called when the SpeedyPromise is fulfilled\n     * @param {null|undefined|(function(Error): V|PromiseLike<V>|SpeedyPromise<V>)} [onRejection] called when the SpeedyPromise is rejected\n     * @returns {SpeedyPromise<U>}\n     */\n    then(onFulfillment, onRejection = null)\n    {\n        const child = new SpeedyPromise(this._nop);\n        child._onFulfillment = typeof onFulfillment === 'function' && onFulfillment;\n        child._onRejection = typeof onRejection === 'function' && onRejection;\n        child._parent = this;\n\n        this[this._children++] = child; // attach child\n        this._flags &= ~SUSPEND_ASYNC; // restore the async behavior\n        this._notify();\n\n        return child;\n    }\n\n    /**\n     * Setup rejection handler\n     * @template U, V=never\n     * @param {null|undefined|(function(Error): V|PromiseLike<V>|SpeedyPromise<V>)} [onRejection] called when the SpeedyPromise is rejected\n     * @returns {SpeedyPromise<V>}\n     */\n    catch(onRejection)\n    {\n        return this.then(null, onRejection);\n    }\n\n    /**\n     * Execute a callback when the promise is settled\n     * (i.e., fulfilled or rejected)\n     * @param {function(): void} onFinally\n     * @returns {SpeedyPromise<T>}\n     */\n    finally(onFinally)\n    {\n        const fn = val => { onFinally(); return val; };\n        return this.then(fn, fn);\n    }\n\n    /**\n     * Start the computation immediately, synchronously.\n     * Can't afford to spend any time at all waiting for micro-tasks, etc.\n     * @returns {SpeedyPromise<T>} this\n     */\n    turbocharge()\n    {\n        let my = this;\n\n        // suspend the async behavior\n        this._flags |= SUSPEND_ASYNC;\n        while(my._parent !== undefined) {\n            my = my._parent;\n            my._flags |= SUSPEND_ASYNC;\n        }\n\n        // notify the children of the root\n        my._notify(); // will be synchronous\n\n        // return this SpeedyPromise\n        return this;\n    }\n\n    /**\n     * Convert to string\n     * @returns {string}\n     */\n    toString()\n    {\n        switch(this._state) {\n            case PENDING:\n                return `SpeedyPromise { <pending> }`;\n            case FULFILLED:\n                return `SpeedyPromise { <fulfilled> ${this._value} }`;\n            case REJECTED:\n                return `SpeedyPromise { <rejected> ${this._value} }`;\n            default:\n                return '';\n        }\n    }\n\n    /**\n     * Symbol.toStringTag\n     * @returns {string}\n     */\n    get [Symbol.toStringTag]()\n    {\n        return 'SpeedyPromise';\n    }\n\n    /**\n     * Creates a resolved SpeedyPromise\n     * @template U\n     * @param {U} [value]\n     * @returns {SpeedyPromise<U>}\n     */\n    static resolve(value)\n    {\n        const promise = new SpeedyPromise(this._snop);\n\n        if((typeof value === 'object' && value !== null && 'then' in value) || (typeof value === 'function' && 'then' in value)) {\n            // resolve asynchronously\n            promise._resolve(value);\n        }\n        else {\n            // fulfill synchronously\n            promise._value = value;\n            promise._state = FULFILLED;\n        }\n\n        return promise;\n    }\n\n    /**\n     * Creates a rejected SpeedyPromise\n     * @template U\n     * @param {Error} reason\n     * @returns {SpeedyPromise<U>}\n     */\n    static reject(reason)\n    {\n        const promise = new SpeedyPromise(this._snop);\n        promise._value = reason;\n        promise._state = REJECTED;\n        return promise;\n    }\n\n    /**\n     * Returns a SpeedyPromise that resolves to an array\n     * containing the results of the input promises/values,\n     * in their given order. The returned SpeedyPromise will\n     * resolve if all input promises resolve, or reject if\n     * any input promise rejects.\n     * @template U\n     * @param {Iterable<U>|Iterable<SpeedyPromise<U>>|Iterable<Promise<U>>} iterable e.g., a SpeedyPromise[], a thenable[]\n     * @returns {SpeedyPromise<U[]>}\n     *\n     * FIXME iterables need not be all <U>\n     */\n    static all(iterable)\n    {\n        return new SpeedyPromise((resolve, reject) => {\n            const input = [];\n\n            // get elements\n            for(const element of iterable)\n                input.push(element);\n\n            // resolve synchronously if there are no elements\n            const length = input.length;\n            if(length == 0) {\n                resolve([]);\n                return;\n            }\n\n            // resolve asynchronously\n            let counter = length;\n            const output = new Array(length);\n            const partialResolve = i => (val => { output[i] = val; if(0 == --counter) resolve(output); });\n            for(let i = 0; i < length; i++) {\n                const element = input[i];\n                if(element.__proto__ === SpeedyPromise.prototype || element.__proto__ === Promise.prototype)\n                    element.then(partialResolve(i), reject);\n                else\n                    SpeedyPromise.resolve(element).then(partialResolve(i), reject);\n            }\n        });\n    }\n\n    /**\n     * Returns a promise that gets fulfilled or rejected as soon\n     * as the first promise in the iterable gets fulfilled or\n     * rejected (with its value/reason).\n     * @template U\n     * @param {Iterable<U>|Iterable<SpeedyPromise<U>>|Iterable<Promise<U>>} iterable e.g., a SpeedyPromise[], a thenable[]\n     * @returns {SpeedyPromise<U>}\n     */\n    static race(iterable)\n    {\n        return new SpeedyPromise((resolve, reject) => {\n            const input = [];\n\n            // get elements\n            for(const element of iterable)\n                input.push(element);\n\n            // if the iterable is empty, the promise\n            // will be pending forever...\n\n            // resolve asynchronously\n            const length = input.length;\n            for(let i = 0; i < length; i++) {\n                const element = input[i];\n                if(element.__proto__ === SpeedyPromise.prototype || element.__proto__ === Promise.prototype)\n                    element.then(resolve, reject);\n                else\n                    SpeedyPromise.resolve(element).then(resolve, reject);\n            }\n        });\n    }\n\n    /**\n     * Fulfill this promise with a value\n     * @param {T} value\n     */\n    _fulfill(value)\n    {\n        this._setState(FULFILLED, value);\n    }\n\n    /**\n     * Reject this promise with a reason\n     * @param {Error} reason\n     */\n    _reject(reason)\n    {\n        this._setState(REJECTED, reason);\n    }\n\n    /**\n     * Set the state and the value of this promise\n     * @param {number} state\n     * @param {T|Error} value\n     */\n    _setState(state, value)\n    {\n        // the promise is already fulfilled or rejected\n        if(this._state != PENDING)\n            return;\n\n        // set the new state\n        this._state = state;\n        this._value = value;\n        this._notify();\n    }\n\n    /**\n     * Notify my children that this promise is no\n     * longer pending. This is an async operation:\n     * my childen will be notified \"as soon\n     * as possible\" (it will be scheduled).\n     * We may force this to be synchronous, though\n     */\n    _notify()\n    {\n        // nothing to do\n        if(this._state == PENDING)\n            return;\n\n        // have we turbocharged this promise?\n        if(this._flags & SUSPEND_ASYNC) {\n            this._broadcast(); // execute synchronously\n            return;\n        }\n\n        // install a timer (default behavior)\n        asap(this._broadcastIfAsync);\n    }\n\n    /**\n     * Helper method\n     */\n    _broadcastIfAsync()\n    {\n        // we may have installed a timer at some\n        // point, but turbocharged the promise later\n        if(!(this._flags & SUSPEND_ASYNC))\n            this._broadcast();\n    }\n\n    /**\n     * Tell my children that this promise\n     * is either fulfilled or rejected.\n     * This is a synchronous operation\n     */\n    _broadcast()\n    {\n        const children = this._children;\n        const state = this._state;\n\n        if(state === FULFILLED) {\n            for(let i = 0; i < children; i++) {\n                const child = this[i];\n                const callback = child._onFulfillment;\n\n                try {\n                    if(callback) {\n                        if(callback !== child._nop) {\n                            child._resolve(callback(this._value)); // promise resolution procedure\n                            child._onFulfillment = child._nop; // will not be called again\n                        }\n                    }\n                    else\n                        child._fulfill(this._value);\n                }\n                catch(e) {\n                    child._reject(e);\n                }\n            }\n        }\n        else if(state === REJECTED) {\n            for(let i = 0; i < children; i++) {\n                const child = this[i];\n                const callback = child._onRejection;\n\n                try {\n                    if(callback) {\n                        if(callback !== child._nop) {\n                            child._resolve(callback(this._value)); // promise resolution procedure\n                            child._onRejection = child._nop; // will not be called again\n                        }\n                    }\n                    else\n                        child._reject(this._value);\n                }\n                catch(e) {\n                    child._reject(e);\n                }\n            }\n        }\n    }\n\n    /**\n     * Promise Resolution Procedure\n     * based on the Promises/A+ spec\n     * @param {T} x\n     */\n    _resolve(x)\n    {\n        if((typeof x !== 'object' && typeof x !== 'function') || (x === null)) { // if(x !== Object(x))\n            this._fulfill(x);\n            return;\n        }\n\n        if(x === this)\n            throw new TypeError(); // Circular reference\n\n        if(x.__proto__ === SpeedyPromise.prototype || x.__proto__ === Promise.prototype) {\n            x.then(this._resolve, this._reject);\n            return;\n        }\n\n        try {\n            const then = x.then;\n            if(typeof then === 'function') {\n                let resolve = this._resolve, reject = this._reject;\n                try {\n                    then.call(x,\n                        y => { resolve(y); resolve = reject = this._nop; },\n                        r => { reject(r); resolve = reject = this._nop; }\n                    );\n                }\n                catch(e) {\n                    if(resolve !== this._nop && reject !== this._nop)\n                        this._reject(e);\n                }\n            }\n            else {\n                this._fulfill(x);\n            }\n        }\n        catch(e) {\n            this._reject(e);\n        }\n    }\n\n    /**\n     * No-operation\n     */\n    _nop()\n    {\n    }\n\n    /**\n     * Static no-operation\n     */\n    static _snop()\n    {\n    }\n}\n\n//module.exports = { SpeedyPromise };\n\n/*\n// Uncomment to test performance with regular Promises\nmodule.exports = { SpeedyPromise: Promise };\nPromise.prototype.turbocharge = function() { return this };\n*/\n","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * types.js\n * Types & formats\n */\n\n/**\n * Media types\n * @enum {Symbol}\n */\nexport const MediaType = Object.freeze({\n    Image: Symbol('Image'),\n    Video: Symbol('Video'),\n    Canvas: Symbol('Canvas'),\n    Bitmap: Symbol('Bitmap'),\n});\n\n/**\n * Image formats\n * @enum {Symbol}\n */\nexport const ImageFormat = Object.freeze({\n    RGBA: Symbol('RGBA'),\n    GREY: Symbol('GREY'),\n});\n\n/**\n * Pixel component (bitwise flags)\n * @typedef {number} PixelComponent\n */\nexport const PixelComponent = Object.freeze({\n    RED:   1,\n    GREEN: 2,\n    BLUE:  4,\n    ALPHA: 8,\n    ALL:   15 // = RED | GREEN | BLUE | ALPHA\n});\n\n/**\n * Component ID utility\n */\nexport const ColorComponentId = Object.freeze({\n    [PixelComponent.RED]:   0,\n    [PixelComponent.GREEN]: 1,\n    [PixelComponent.BLUE]:  2,\n    [PixelComponent.ALPHA]: 3\n});","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * utils.js\n * Generic utilities\n */\n\nimport { IllegalArgumentError, ParseError, AssertionError, AccessDeniedError, NotSupportedError } from './errors'\nimport { SpeedyPromise } from './speedy-promise';\n\n/** @typedef {{fn: Function, args: any[]}} ZeroTimeoutCallback */\n/** @typedef {Map<string,ZeroTimeoutCallback>} ZeroTimeoutContext */\n\n/** @type {function(): ZeroTimeoutContext} helper for setZeroTimeout */\nconst zeroTimeoutContext = (() => {\n    const callbacks = /** @type {ZeroTimeoutContext} */ ( new Map() );\n    let initialized = false;\n\n    return (function() {\n        if(!initialized) {\n            initialized = true;\n            window.addEventListener('message', ev => {\n                if(ev.source === window) {\n                    const msgId = ev.data;\n                    const obj = callbacks.get(msgId);\n                    if(obj !== undefined) {\n                        obj.fn.apply(window, obj.args);\n                        callbacks.delete(msgId);\n                    }\n                }\n            });\n        }\n\n        return callbacks;\n    });\n})();\n\n\n\n/**\n * Generic utilities\n */\nexport class Utils\n{\n    /**\n     * Generates a warning\n     * @param {string} text message text\n     * @param  {...string} args optional text\n     */\n    static warning(text, ...args)\n    {\n        console.warn('[speedy-vision]', text, ...args);\n    }\n\n    /**\n     * Logs a message\n     * @param {string} text message text\n     * @param  {...string} args optional text\n     */\n    static log(text, ...args)\n    {\n        console.log('[speedy-vision]', text, ...args);\n    }\n\n    /**\n     * Assertion\n     * @param {boolean} expr expression\n     * @param {string} [text] error message\n     * @throws {AssertionError}\n     */\n    static assert(expr, text = '')\n    {\n        if(!expr)\n            throw new AssertionError(text);\n    }\n\n    /**\n     * Similar to setTimeout(fn, 0), but without the ~4ms delay.\n     * Although much faster than setTimeout, this may be resource-hungry\n     * (heavy on battery) if used in a loop. Use with caution.\n     * Implementation based on David Baron's, but adapted for ES6 classes\n     * @param {Function} fn\n     * @param {any[]} args optional arguments to be passed to fn\n     */\n    static setZeroTimeout(fn, ...args)\n    {\n        const ctx = zeroTimeoutContext();\n        const msgId = '0%' + String(Math.random());\n\n        ctx.set(msgId, { fn, args });\n        window.postMessage(msgId, '*');\n    }\n\n    /**\n     * Gets the names of the arguments of the specified function\n     * @param {Function} fun \n     * @returns {string[]}\n     */\n    static functionArguments(fun)\n    {\n        const code = fun.toString();\n        const regex = code.startsWith('function') ? 'function\\\\s.*\\\\(([^)]*)\\\\)' :\n                     (code.startsWith('(') ? '\\\\(([^)]*)\\\\).*=>' : '([^=]+).*=>');\n        const match = new RegExp(regex).exec(code);\n\n        if(match !== null) {\n            const args = match[1].replace(/\\/\\*.*?\\*\\//g, ''); // remove comments\n            return args.split(',').map(argname =>\n                argname.replace(/=.*$/, '').trim() // remove default params & trim\n            ).filter(argname =>\n                argname // handle trailing commas\n            );\n        }\n        else\n            throw new ParseError(`Can't detect function arguments of ${code}`);\n    }\n\n    /**\n     * Get all property descriptors from an object,\n     * traversing its entire prototype chain\n     * @param {object} obj \n     * @returns {object}\n     */\n    static getAllPropertyDescriptors(obj)\n    {\n        if(obj) {\n            const proto = Object.getPrototypeOf(obj);\n\n            return {\n                ...(Utils.getAllPropertyDescriptors(proto)),\n                ...Object.getOwnPropertyDescriptors(obj)\n            };\n        }\n        else\n            return Object.create(null);\n    }\n\n    /**\n     * Creates a HTMLCanvasElement with the given dimensions\n     * @param {number} width in pixels\n     * @param {number} height in pixels\n     * @returns {HTMLCanvasElement}\n     */\n    static createCanvas(width, height)\n    {\n        const canvas = document.createElement('canvas');\n        canvas.width = width;\n        canvas.height = height;\n        return canvas;\n    }\n\n    /**\n     * Generates a random number with\n     * Gaussian distribution (mu, sigma)\n     * @param {number} mu mean\n     * @param {number} sigma standard deviation\n     * @returns {number} random number\n     */\n    static gaussianNoise(mu = 0, sigma = 1)\n    {\n        // Box-Muller transformation\n        const TWO_PI = 2.0 * Math.PI;\n        \n        let a, b = Math.random();\n        do { a = Math.random(); } while(a <= Number.EPSILON);\n        let z = Math.sqrt(-2 * Math.log(a)) * Math.sin(TWO_PI * b);\n\n        return z * sigma + mu;\n    }\n\n    /**\n     * Generate a 1D gaussian kernel with custom sigma\n     * Tip: use kernelSize >= (5 * sigma), kernelSize odd\n     * @param {number} sigma gaussian sigma\n     * @param {number} [kernelSize] kernel size, odd number\n     * @param {boolean} [normalized] normalize entries so that their sum is 1\n     * @returns {number[]}\n     */\n    static gaussianKernel(sigma, kernelSize = 0, normalized = true)\n    {\n        /*\n         * Let G(x) be a Gaussian function centered at 0 with fixed sigma:\n         *\n         * G(x) = (1 / (sigma * sqrt(2 * pi))) * exp(-(x / (sqrt(2) * sigma))^2)\n         * \n         * In addition, let f(p) be a kernel value at pixel p, -k/2 <= p <= k/2:\n         * \n         * f(p) = \\int_{p - 0.5}^{p + 0.5} G(x) dx (integrate around p)\n         *      = \\int_{0}^{p + 0.5} G(x) dx - \\int_{0}^{p - 0.5} G(x) dx\n         * \n         * Setting a constant c := sqrt(2) * sigma, it follows that:\n         * \n         * f(p) = (1 / 2c) * (erf((p + 0.5) / c) - erf((p - 0.5) / c))\n         */\n\n        // default kernel size\n        if(kernelSize == 0) {\n            kernelSize = Math.ceil(5.0 * sigma) | 0;\n            kernelSize += 1 - (kernelSize % 2);\n        }\n\n        // validate input\n        kernelSize |= 0;\n        if(kernelSize < 1 || kernelSize % 2 == 0)\n            throw new IllegalArgumentError(`Invalid kernel size given to gaussianKernel: ${kernelSize} x 1`);\n        else if(sigma <= 0.0)\n            throw new IllegalArgumentError(`Invalid sigma given to gaussianKernel: ${sigma}`);\n\n        // function erf(x) = -erf(-x) can be approximated numerically. See:\n        // https://en.wikipedia.org/wiki/Error_function#Numerical_approximations\n        const kernel = new Array(kernelSize);\n\n        // set constants\n        const N  =  kernelSize >> 1; // integer (floor, div 2)\n        const c  =  (+sigma) * 1.4142135623730951; // sigma * sqrt(2)\n        const m  =  0.3275911;\n        const a1 =  0.254829592;\n        const a2 = -0.284496736;\n        const a3 =  1.421413741;\n        const a4 = -1.453152027;\n        const a5 =  1.061405429;\n\n        // compute the kernel\n        let sum = 0.0;\n        for(let j = 0; j < kernelSize; j++) {\n            let xa = (j - N + 0.5) / c;\n            let xb = (j - N - 0.5) / c;\n            let sa = 1.0, sb = 1.0;\n\n            if(xa < 0.0) { sa = -1.0; xa = -xa; }\n            if(xb < 0.0) { sb = -1.0; xb = -xb; }\n\n            const ta = 1.0 / (1.0 + m * xa);\n            const tb = 1.0 / (1.0 + m * xb);\n            const pa = ((((a5 * ta + a4) * ta + a3) * ta + a2) * ta + a1) * ta;\n            const pb = ((((a5 * tb + a4) * tb + a3) * tb + a2) * tb + a1) * tb;\n            const ya = 1.0 - pa * Math.exp(-xa * xa);\n            const yb = 1.0 - pb * Math.exp(-xb * xb);\n\n            const erfa = sa * ya;\n            const erfb = sb * yb;\n            const fp = (erfa - erfb) / (2.0 * c);\n\n            kernel[j] = fp;\n            sum += fp;\n        }\n\n        // normalize the kernel\n        if(normalized) {\n            for(let j = 0; j < kernelSize; j++)\n                kernel[j] /= sum;\n        }\n\n        // done!\n        return kernel;\n    }\n\n    /**\n     * Generate a 2D kernel in column-major format using two separable 1D kernels\n     * @param {number[]} ka 1D kernel\n     * @param {number[]} [kb]\n     * @returns {number[]}\n     */\n    static kernel2d(ka, kb = ka)\n    {\n        const ksize = ka.length;\n        Utils.assert(ka.length == ka.length);\n        Utils.assert(ksize >= 1 && ksize % 2 == 1);\n\n        // compute the outer product ka x kb\n        let kernel2d = new Array(ksize * ksize), k = 0;\n        for(let col = 0; col < ksize; col++) {\n            for(let row = 0; row < ksize; row++)\n                kernel2d[k++] = ka[row] * kb[col];\n        }\n\n        return kernel2d;\n    }\n\n    /**\n     * Cartesian product a x b: [ [ai, bj] for all i, j ]\n     * @param {number[]} a\n     * @param {number[]} b\n     * @returns {Array<[number,number]>}\n     */\n    static cartesian(a, b)\n    {\n        return [].concat(...a.map(a => b.map(b => [a, b])));\n    }\n\n    /**\n     * Symmetric range\n     * @param {number} n non-negative integer\n     * @returns {number[]} [ -n, ..., n ]\n     */\n    static symmetricRange(n)\n    {\n        if((n |= 0) < 0)\n            throw new IllegalArgumentError(`Expected a non-negative integer as input`);\n\n        return [...(Array(2*n + 1).keys())].map(x => x - n);\n    }\n\n    /**\n     * Compute the [0, n) range of integers\n     * @param {number} n positive integer\n     * @returns {number[]} [ 0, 1, ..., n-1 ]\n     */\n    static range(n)\n    {\n        if((n |= 0) <= 0)\n            throw new IllegalArgumentError(`Expected a positive integer as input`);\n\n        return [...(Array(n).keys())];\n    }\n\n    /**\n     * Shuffle in-place\n     * @template T\n     * @param {T[]} arr\n     * @returns {T[]} arr\n     */\n    static shuffle(arr)\n    {\n        const len = arr.length;\n        const m = len - 1;\n\n        // Fisher-Yattes\n        for(let i = 0; i < m; i++) {\n            const j = i + ((Math.random() * (len - i)) | 0); // i <= j < arr.length\n\n            if(i !== j) {\n                const t = arr[i];\n                arr[i] = arr[j];\n                arr[j] = t;\n            }\n        }\n\n        return arr;\n    }\n\n    /**\n     * Flatten an array (1 level only)\n     * @template U\n     * @param {U[]} array\n     * @returns {U[]}\n     */\n    static flatten(array)\n    {\n        //return array.flat();\n        //return array.reduce((arr, val) => arr.concat(val), []);\n\n        const flat = [];\n\n        for(let i = 0, n = array.length; i < n; i++) {\n            const entry = array[i];\n\n            if(Array.isArray(entry)) {\n                for(let j = 0, m = entry.length; j < m; j++)\n                    flat.push(entry[j]);\n            }\n            else\n                flat.push(entry);\n        }\n\n        return flat;\n    }\n\n    /**\n     * Decode a 16-bit float from a\n     * unsigned 16-bit integer\n     * @param {number} uint16\n     * @returns {number}\n     */\n    static decodeFloat16(uint16)\n    {\n        // decode according to sec 2.1.2\n        // 16-Bit Floating Point Numbers\n        // of the OpenGL ES 3 spec\n        const s = (uint16 & 0xFFFF) >> 15; // sign bit\n        const e = (uint16 & 0x7FFF) >> 10; // exponent\n        const m = (uint16 & 0x3FF); // mantissa\n        const sign = 1 - 2 * s; // (-1)^s\n\n        if(e == 0)\n            return m == 0 ? sign * 0.0 : sign * m * 5.960464477539063e-8; // zero / subnormal\n        else if(e == 31)\n            return m == 0 ? sign * Number.POSITIVE_INFINITY : Number.NaN;\n\n        const f = e >= 15 ? (1 << (e-15)) : 1.0 / (1 << (15-e)); // 2^(e-15)\n        return sign * f * (1.0 + m * 0.0009765625); // normal\n    }\n\n    /**\n     * Wrapper around getUserMedia()\n     * @param {MediaStreamConstraints} [constraints] will be passed to getUserMedia()\n     * @returns {SpeedyPromise<HTMLVideoElement>}\n     */\n    static requestCameraStream(constraints = { audio: false, video: true })\n    {\n        Utils.log('Accessing the webcam...');\n\n        if(!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia)\n            throw new NotSupportedError('Unsupported browser: no mediaDevices.getUserMedia()');\n\n        return new SpeedyPromise((resolve, reject) => {\n            navigator.mediaDevices.getUserMedia(constraints).then(stream => {\n                const video = document.createElement('video');\n                video.onloadedmetadata = () => {\n                    video.play();\n                    Utils.log(`The camera is on! Resolution: ${video.videoWidth} x ${video.videoHeight}`);\n                    resolve(video);\n                };\n                video.srcObject = stream;\n            })\n            .catch(err => {\n                reject(new AccessDeniedError(\n                    `Please give access to the camera and reload the page`,\n                    err\n                ));\n            });\n        });\n    }\n}\n","module.exports = \"#if !defined(KERNEL_SIZE) || !defined(AXIS) || (AXIS != 0 && AXIS != 1)\\n#error Undefined KERNEL_SIZE / AXIS\\n#endif\\nuniform sampler2D image;\\nuniform float kernel[@KERNEL_SIZE@];\\nconst ivec2 axis = ivec2(1-AXIS, AXIS);\\n#define S(x,k) result += pixelAtShortOffset(image, ivec2((x),(x)) * axis) * kernel[k]\\nvoid main()\\n{\\nvec4 result = vec4(0.0f);\\n#if KERNEL_SIZE == 3\\nS(-1, 2);\\nS( 0, 1);\\nS( 1, 0);\\n#elif KERNEL_SIZE == 5\\nS(-2, 4);\\nS(-1, 3);\\nS( 0, 2);\\nS( 1, 1);\\nS( 2, 0);\\n#elif KERNEL_SIZE == 7\\nS(-3, 6);\\nS(-2, 5);\\nS(-1, 4);\\nS( 0, 3);\\nS( 1, 2);\\nS( 2, 1);\\nS( 3, 0);\\n#elif KERNEL_SIZE == 9\\nS(-4, 8);\\nS(-3, 7);\\nS(-2, 6);\\nS(-1, 5);\\nS( 0, 4);\\nS( 1, 3);\\nS( 2, 2);\\nS( 3, 1);\\nS( 4, 0);\\n#elif KERNEL_SIZE == 11\\nS(-5, 10);\\nS(-4, 9);\\nS(-3, 8);\\nS(-2, 7);\\nS(-1, 6);\\nS( 0, 5);\\nS( 1, 4);\\nS( 2, 3);\\nS( 3, 2);\\nS( 4, 1);\\nS( 5, 0);\\n#elif KERNEL_SIZE == 13\\nS(-6, 12);\\nS(-5, 11);\\nS(-4, 10);\\nS(-3, 9);\\nS(-2, 8);\\nS(-1, 7);\\nS( 0, 6);\\nS( 1, 5);\\nS( 2, 4);\\nS( 3, 3);\\nS( 4, 2);\\nS( 5, 1);\\nS( 6, 0);\\n#elif KERNEL_SIZE == 15\\nS(-7, 14);\\nS(-6, 13);\\nS(-5, 12);\\nS(-4, 11);\\nS(-3, 10);\\nS(-2, 9);\\nS(-1, 8);\\nS( 0, 7);\\nS( 1, 6);\\nS( 2, 5);\\nS( 3, 4);\\nS( 4, 3);\\nS( 5, 2);\\nS( 6, 1);\\nS( 7, 0);\\n#else\\n#error Invalid parameters\\n#endif\\ncolor = vec4(result.rgb, 1.0f);\\n}\"","module.exports = \"#ifndef KERNEL_SIZE_SQUARED\\n#define Must define KERNEL_SIZE_SQUARED\\n#endif\\nuniform sampler2D image;\\nuniform float kernel[@KERNEL_SIZE_SQUARED@];\\n#define S(x,y,k) result += pixelAtShortOffset(image, ivec2((x),(y))) * kernel[k]\\nvoid main()\\n{\\nvec4 result = vec4(0.0f);\\n#if KERNEL_SIZE_SQUARED == 9\\nS(-1,-1, 8);\\nS(-1, 0, 7);\\nS(-1, 1, 6);\\nS( 0,-1, 5);\\nS( 0, 0, 4);\\nS( 0, 1, 3);\\nS( 1,-1, 2);\\nS( 1, 0, 1);\\nS( 1, 1, 0);\\n#elif KERNEL_SIZE_SQUARED == 25\\nS(-2,-2, 24);\\nS(-2,-1, 23);\\nS(-2, 0, 22);\\nS(-2, 1, 21);\\nS(-2, 2, 20);\\nS(-1,-2, 19);\\nS(-1,-1, 18);\\nS(-1, 0, 17);\\nS(-1, 1, 16);\\nS(-1, 2, 15);\\nS( 0,-2, 14);\\nS( 0,-1, 13);\\nS( 0, 0, 12);\\nS( 0, 1, 11);\\nS( 0, 2, 10);\\nS( 1,-2, 9);\\nS( 1,-1, 8);\\nS( 1, 0, 7);\\nS( 1, 1, 6);\\nS( 1, 2, 5);\\nS( 2,-2, 4);\\nS( 2,-1, 3);\\nS( 2, 0, 2);\\nS( 2, 1, 1);\\nS( 2, 2, 0);\\n#elif KERNEL_SIZE_SQUARED == 49\\nS(-3,-3, 48);\\nS(-3,-2, 47);\\nS(-3,-1, 46);\\nS(-3, 0, 45);\\nS(-3, 1, 44);\\nS(-3, 2, 43);\\nS(-3, 3, 42);\\nS(-2,-3, 41);\\nS(-2,-2, 40);\\nS(-2,-1, 39);\\nS(-2, 0, 38);\\nS(-2, 1, 37);\\nS(-2, 2, 36);\\nS(-2, 3, 35);\\nS(-1,-3, 34);\\nS(-1,-2, 33);\\nS(-1,-1, 32);\\nS(-1, 0, 31);\\nS(-1, 1, 30);\\nS(-1, 2, 29);\\nS(-1, 3, 28);\\nS( 0,-3, 27);\\nS( 0,-2, 26);\\nS( 0,-1, 25);\\nS( 0, 0, 24);\\nS( 0, 1, 23);\\nS( 0, 2, 22);\\nS( 0, 3, 21);\\nS( 1,-3, 20);\\nS( 1,-2, 19);\\nS( 1,-1, 18);\\nS( 1, 0, 17);\\nS( 1, 1, 16);\\nS( 1, 2, 15);\\nS( 1, 3, 14);\\nS( 2,-3, 13);\\nS( 2,-2, 12);\\nS( 2,-1, 11);\\nS( 2, 0, 10);\\nS( 2, 1, 9);\\nS( 2, 2, 8);\\nS( 2, 3, 7);\\nS( 3,-3, 6);\\nS( 3,-2, 5);\\nS( 3,-1, 4);\\nS( 3, 0, 3);\\nS( 3, 1, 2);\\nS( 3, 2, 1);\\nS( 3, 3, 0);\\n#else\\n#error Invalid KERNEL_SIZE_SQUARED\\n#endif\\ncolor = vec4(result.rgb, 1.0f);\\n}\"","module.exports = \"uniform sampler2D image;\\n#define X(i,j) t = vec2(min(p[i], p[j]), max(p[i], p[j])); p[i] = t.x; p[j] = t.y;\\n#define S(i,x,y) p[i] = pixelAtShortOffset(image, ivec2((x),(y))).g\\nvoid main()\\n{\\nfloat median;\\nvec2 t;\\n#if !defined(KERNEL_SIZE)\\n#error Must define KERNEL_SIZE\\n#elif KERNEL_SIZE == 3\\nfloat p[9];\\nS(0,-1,-1);\\nS(1, 0,-1);\\nS(2, 1,-1);\\nS(3,-1, 0);\\nS(4, 0, 0);\\nS(5, 1, 0);\\nS(6,-1, 1);\\nS(7, 0, 1);\\nS(8, 1, 1);\\nX(1,2);X(4,5);X(7,8);X(0,1);X(3,4);X(6,7);X(1,2);X(4,5);X(7,8);X(0,3);X(5,8);X(4,7);X(3,6);X(1,4);X(2,5);X(4,7);X(4,2);X(6,4);X(4,2);\\nmedian = p[4];\\n#elif KERNEL_SIZE == 5\\nfloat p[25];\\nS( 0,-2,-2);\\nS( 1,-1,-2);\\nS( 2, 0,-2);\\nS( 3, 1,-2);\\nS( 4, 2,-2);\\nS( 5,-2,-1);\\nS( 6,-1,-1);\\nS( 7, 0,-1);\\nS( 8, 1,-1);\\nS( 9, 2,-1);\\nS(10,-2, 0);\\nS(11,-1, 0);\\nS(12, 0, 0);\\nS(13, 1, 0);\\nS(14, 2, 0);\\nS(15,-2, 1);\\nS(16,-1, 1);\\nS(17, 0, 1);\\nS(18, 1, 1);\\nS(19, 2, 1);\\nS(20,-2, 2);\\nS(21,-1, 2);\\nS(22, 0, 2);\\nS(23, 1, 2);\\nS(24, 2, 2);\\nX(0,1);X(3,4);X(2,4);X(2,3);X(6,7);X(5,7);X(5,6);X(9,10);X(8,10);X(8,9);X(12,13);X(11,13);X(11,12);X(15,16);X(14,16);X(14,15);X(18,19);X(17,19);X(17,18);X(21,22);X(20,22);X(20,21);X(23,24);X(2,5);X(3,6);X(0,6);X(0,3);X(4,7);X(1,7);X(1,4);X(11,14);X(8,14);X(8,11);X(12,15);X(9,15);X(9,12);X(13,16);X(10,16);X(10,13);X(20,23);X(17,23);X(17,20);X(21,24);X(18,24);X(18,21);X(19,22);X(8,17);X(9,18);X(0,18);X(0,9);X(10,19);X(1,19);X(1,10);X(11,20);X(2,20);X(2,11);X(12,21);X(3,21);X(3,12);X(13,22);X(4,22);X(4,13);X(14,23);X(5,23);X(5,14);X(15,24);X(6,24);X(6,15);X(7,16);X(7,19);X(13,21);X(15,23);X(7,13);X(7,15);X(1,9);X(3,11);X(5,17);X(11,17);X(9,17);X(4,10);X(6,12);X(7,14);X(4,6);X(4,7);X(12,14);X(10,14);X(6,7);X(10,12);X(6,10);X(6,17);X(12,17);X(7,17);X(7,10);X(12,18);X(7,12);X(10,18);X(12,20);X(10,20);X(10,12);\\nmedian = p[12];\\n#elif KERNEL_SIZE == 7\\nfloat p[49];\\nS( 0,-3,-3);\\nS( 1,-2,-3);\\nS( 2,-1,-3);\\nS( 3, 0,-3);\\nS( 4, 1,-3);\\nS( 5, 2,-3);\\nS( 6, 3,-3);\\nS( 7,-3,-2);\\nS( 8,-2,-2);\\nS( 9,-1,-2);\\nS(10, 0,-2);\\nS(11, 1,-2);\\nS(12, 2,-2);\\nS(13, 3,-2);\\nS(14,-3,-1);\\nS(15,-2,-1);\\nS(16,-1,-1);\\nS(17, 0,-1);\\nS(18, 1,-1);\\nS(19, 2,-1);\\nS(20, 3,-1);\\nS(21,-3, 0);\\nS(22,-2, 0);\\nS(23,-1, 0);\\nS(24, 0, 0);\\nS(25, 1, 0);\\nS(26, 2, 0);\\nS(27, 3, 0);\\nS(28,-3, 1);\\nS(29,-2, 1);\\nS(30,-1, 1);\\nS(31, 0, 1);\\nS(32, 1, 1);\\nS(33, 2, 1);\\nS(34, 3, 1);\\nS(35,-3, 2);\\nS(36,-2, 2);\\nS(37,-1, 2);\\nS(38, 0, 2);\\nS(39, 1, 2);\\nS(40, 2, 2);\\nS(41, 3, 2);\\nS(42,-3, 3);\\nS(43,-2, 3);\\nS(44,-1, 3);\\nS(45, 0, 3);\\nS(46, 1, 3);\\nS(47, 2, 3);\\nS(48, 3, 3);\\nX(0,1);X(2,3);X(0,2);X(1,3);X(1,2);X(4,5);X(6,7);X(4,6);X(5,7);X(5,6);X(0,4);X(2,6);X(2,4);X(1,5);X(3,7);X(3,5);X(1,2);X(3,4);X(5,6);X(8,9);X(10,11);X(8,10);X(9,11);X(9,10);X(12,13);X(14,15);X(12,14);X(13,15);X(13,14);X(8,12);X(10,14);X(10,12);X(9,13);X(11,15);X(11,13);X(9,10);X(11,12);X(13,14);X(0,8);X(4,12);X(4,8);X(2,10);X(6,14);X(6,10);X(2,4);X(6,8);X(10,12);X(1,9);X(5,13);X(5,9);X(3,11);X(7,15);X(7,11);X(3,5);X(7,9);X(11,13);X(1,2);X(3,4);X(5,6);X(7,8);X(9,10);X(11,12);X(13,14);X(16,17);X(18,19);X(16,18);X(17,19);X(17,18);X(20,21);X(22,23);X(20,22);X(21,23);X(21,22);X(16,20);X(18,22);X(18,20);X(17,21);X(19,23);X(19,21);X(17,18);X(19,20);X(21,22);X(24,25);X(26,27);X(24,26);X(25,27);X(25,26);X(28,29);X(30,31);X(28,30);X(29,31);X(29,30);X(24,28);X(26,30);X(26,28);X(25,29);X(27,31);X(27,29);X(25,26);X(27,28);X(29,30);X(16,24);X(20,28);X(20,24);X(18,26);X(22,30);X(22,26);X(18,20);X(22,24);X(26,28);X(17,25);X(21,29);X(21,25);X(19,27);X(23,31);X(23,27);X(19,21);X(23,25);X(27,29);X(17,18);X(19,20);X(21,22);X(23,24);X(25,26);X(27,28);X(29,30);X(0,16);X(8,24);X(8,16);X(4,20);X(12,28);X(12,20);X(4,8);X(12,16);X(20,24);X(2,18);X(10,26);X(10,18);X(6,22);X(14,30);X(14,22);X(6,10);X(14,18);X(22,26);X(2,4);X(6,8);X(10,12);X(14,16);X(18,20);X(22,24);X(26,28);X(1,17);X(9,25);X(9,17);X(5,21);X(13,29);X(13,21);X(5,9);X(13,17);X(21,25);X(3,19);X(11,27);X(11,19);X(7,23);X(15,31);X(15,23);X(7,11);X(15,19);X(23,27);X(3,5);X(7,9);X(11,13);X(15,17);X(19,21);X(23,25);X(27,29);X(1,2);X(3,4);X(5,6);X(7,8);X(9,10);X(11,12);X(13,14);X(15,16);X(17,18);X(19,20);X(21,22);X(23,24);X(25,26);X(27,28);X(29,30);X(32,33);X(34,35);X(32,34);X(33,35);X(33,34);X(36,37);X(38,39);X(36,38);X(37,39);X(37,38);X(32,36);X(34,38);X(34,36);X(33,37);X(35,39);X(35,37);X(33,34);X(35,36);X(37,38);X(40,41);X(42,43);X(40,42);X(41,43);X(41,42);X(44,45);X(46,47);X(44,46);X(45,47);X(45,46);X(40,44);X(42,46);X(42,44);X(41,45);X(43,47);X(43,45);X(41,42);X(43,44);X(45,46);X(32,40);X(36,44);X(36,40);X(34,42);X(38,46);X(38,42);X(34,36);X(38,40);X(42,44);X(33,41);X(37,45);X(37,41);X(35,43);X(39,47);X(39,43);X(35,37);X(39,41);X(43,45);X(33,34);X(35,36);X(37,38);X(39,40);X(41,42);X(43,44);X(45,46);X(32,48);X(40,48);X(36,40);X(44,48);X(38,42);X(34,36);X(38,40);X(42,44);X(46,48);X(37,41);X(39,43);X(35,37);X(39,41);X(43,45);X(33,34);X(35,36);X(37,38);X(39,40);X(41,42);X(43,44);X(45,46);X(47,48);X(0,32);X(16,48);X(16,32);X(8,40);X(24,40);X(8,16);X(24,32);X(40,48);X(4,36);X(20,36);X(12,44);X(28,44);X(12,20);X(28,36);X(4,8);X(12,16);X(20,24);X(28,32);X(36,40);X(44,48);X(2,34);X(18,34);X(10,42);X(26,42);X(10,18);X(26,34);X(6,38);X(22,38);X(14,46);X(30,46);X(14,22);X(30,38);X(6,10);X(14,18);X(22,26);X(30,34);X(38,42);X(2,4);X(6,8);X(10,12);X(14,16);X(18,20);X(22,24);X(26,28);X(30,32);X(34,36);X(38,40);X(42,44);X(46,48);X(1,33);X(17,33);X(9,41);X(25,41);X(9,17);X(25,33);X(5,37);X(21,37);X(13,45);X(29,45);X(13,21);X(29,37);X(5,9);X(13,17);X(21,25);X(29,33);X(37,41);X(3,35);X(19,35);X(11,43);X(27,43);X(11,19);X(27,35);X(7,39);X(23,39);X(15,47);X(31,47);X(15,23);X(31,39);X(7,11);X(15,19);X(23,27);X(31,35);X(39,43);X(3,5);X(7,9);X(11,13);X(15,17);X(19,21);X(23,25);X(27,29);X(31,33);X(35,37);X(39,41);X(43,45);X(1,2);X(3,4);X(5,6);X(7,8);X(9,10);X(11,12);X(13,14);X(15,16);X(17,18);X(19,20);X(21,22);X(23,24);\\nmedian = p[24];\\n#else\\n#error Unsupported kernel size\\n#endif\\ncolor = vec4(median, median, median, 1.0f);\\n}\"","module.exports = \"uniform sampler2D image;\\nuniform sampler2D illuminationMap;\\nuniform float gain;\\nuniform float offset;\\nuniform float decay;\\n#ifndef GREYSCALE\\n#error Must define GREYSCALE\\n#endif\\n#if GREYSCALE == 0\\nconst mat3 rgb2yuv = mat3(\\n0.299f, -0.14713f, 0.615f,\\n0.587f, -0.28886f, -0.51499f,\\n0.114f, 0.436f, -0.10001f\\n);\\nconst mat3 yuv2rgb = mat3(\\n1.0f, 1.0f, 1.0f,\\n0.0f, -0.39465f, 2.03211f,\\n1.13983f, -0.58060f, 0.0f\\n);\\n#endif\\nconst float eps = 0.0001f;\\nconst float sqrt2 = 1.4142135623730951f;\\nconst float magic = 20.0f;\\nconst vec2 center = vec2(0.5f);\\nvoid main()\\n{\\nvec4 pixel = threadPixel(image);\\nvec4 imapPixel = threadPixel(illuminationMap);\\nfloat lambda = -sqrt2 * log(max(1.0f - decay, eps));\\nfloat dist = length(texCoord - center);\\nfloat vgain = gain * exp(-lambda * dist);\\nfloat normalizedGain = 2.0f * vgain;\\nfloat normalizedOffset = 2.0f * offset - 1.0f;\\n#if GREYSCALE != 0\\nfloat luma = 1.0 / (1.0 + exp(-normalizedGain * magic * (pixel.g - imapPixel.g)));\\nluma = clamp(luma + normalizedOffset, 0.0f, 1.0f);\\ncolor = vec4(luma, luma, luma, 1.0f);\\n#else\\nvec3 yuvPixel = rgb2yuv * pixel.rgb;\\nvec3 yuvImapPixel = rgb2yuv * imapPixel.rgb;\\nfloat luma = 1.0 / (1.0 + exp(-normalizedGain * magic * (yuvPixel.r - yuvImapPixel.r)));\\nluma += normalizedOffset;\\nvec3 rgbCorrectedPixel = yuv2rgb * vec3(luma, yuvPixel.gb);\\nrgbCorrectedPixel = clamp(rgbCorrectedPixel, 0.0f, 1.0f);\\ncolor = vec4(rgbCorrectedPixel, 1.0f);\\n#endif\\n}\"","module.exports = \"#ifndef GREYSCALE\\n#error Must define GREYSCALE\\n#endif\\n#if GREYSCALE != 0\\nuniform sampler2D minmax2d;\\n#else\\nuniform sampler2D minmax2dRGB[3];\\n#endif\\nuniform float minValue;\\nuniform float maxValue;\\nconst float eps = 1.0f / 255.0f;\\nvoid main()\\n{\\nvec2 minmax = clamp(vec2(minValue, maxValue), 0.0f, 255.0f) / 255.0f;\\nvec4 newMin = vec4(minmax.x);\\nvec4 newRange = vec4(minmax.y - minmax.x);\\nvec4 alpha = vec4(1.0f, newMin.x, newRange.x, 1.0f);\\n#if GREYSCALE != 0\\nvec4 pixel = threadPixel(minmax2d);\\nmat4 channel = mat4(pixel, pixel, pixel, alpha);\\n#else\\nmat4 channel = mat4(\\nthreadPixel(minmax2dRGB[0]),\\nthreadPixel(minmax2dRGB[1]),\\nthreadPixel(minmax2dRGB[2]),\\nalpha\\n);\\n#endif\\nvec4 oldMin = vec4(channel[0].g, channel[1].g, channel[2].g, channel[3].g);\\nvec4 oldRange = max(vec4(channel[0].b, channel[1].b, channel[2].b, channel[3].b), eps);\\nvec4 oldIntensity = vec4(channel[0].a, channel[1].a, channel[2].a, channel[3].a);\\nvec4 newIntensity = (oldIntensity - oldMin) * newRange / oldRange + newMin;\\ncolor = newIntensity;\\n}\"","module.exports = \"const vec4 grey = vec4(0.299f, 0.587f, 0.114f, 0.0f);\\nuniform sampler2D image;\\nvoid main()\\n{\\nvec4 pixel = threadPixel(image);\\nfloat g = dot(pixel, grey);\\ncolor = vec4(g, g, g, 1.0f);\\n}\"","module.exports = \"#ifndef _COLORS_GLSL\\n#define _COLORS_GLSL\\n#define PIXELCOMPONENT_RED   @PIXELCOMPONENT_RED@\\n#define PIXELCOMPONENT_GREEN @PIXELCOMPONENT_GREEN@\\n#define PIXELCOMPONENT_BLUE  @PIXELCOMPONENT_BLUE@\\n#define PIXELCOMPONENT_ALPHA @PIXELCOMPONENT_ALPHA@\\n#endif\"","module.exports = \"#ifndef _FILTERS_GLSL\\n#define _FILTERS_GLSL\\nfloat laplacian(sampler2D pyramid, vec2 position, float lod)\\n{\\nfloat pot = exp2(lod);\\nivec2 pyrBaseSize = textureSize(pyramid, 0);\\nconst vec3 ones = vec3(1.0f);\\nconst mat3 kernel = mat3(\\n0,-1, 0,\\n-1, 4,-1,\\n0,-1, 0\\n);\\n#define LPC(x,y) pyrSubpixelAtExOffset(pyramid, position, lod, pot, ivec2((x),(y)), pyrBaseSize).g\\nmat3 neighborhood = mat3(\\n0.0f, LPC(0,-1), 0.0f,\\nLPC(-1,0), LPC(0,0), LPC(1,0),\\n0.0f, LPC(0,1), 0.0f\\n);\\nmat3 m = matrixCompMult(neighborhood, kernel);\\nreturn dot(ones, vec3(\\ndot(m[0], ones),\\ndot(m[1], ones),\\ndot(m[2], ones)\\n)) * (1.0f + lod);\\n}\\n#endif\"","module.exports = \"#ifndef _FIXEDPOINT_GLSL\\n#define _FIXEDPOINT_GLSL\\n#define fixed_t int\\n#define fixed2_t ivec2\\nconst int FIX_BITS = int(@FIX_BITS@);\\nconst float FIX_RESOLUTION = float(@FIX_RESOLUTION@);\\n#define itofix(x) fixed_t((x) << FIX_BITS)\\n#define fixtoi(f) int((x) >> FIX_BITS)\\n#define ftofix(x) fixed_t((x) * FIX_RESOLUTION + 0.5f)\\n#define fixtof(f) (float(f) / FIX_RESOLUTION)\\n#define ivec2tofix(x) fixed2_t((x) << FIX_BITS)\\n#define fixtoivec2(f) ivec2((f) >> FIX_BITS)\\n#define vec2tofix(v) fixed2_t((v) * FIX_RESOLUTION + vec2(0.5f))\\n#define fixtovec2(f) (vec2(f) / FIX_RESOLUTION)\\n#endif\"","module.exports = \"#ifndef _FLOAT16_GLSL\\n#define _FLOAT16_GLSL\\n#define encodeFloat16(f) (vec2(packf16(f)) / 255.0f)\\n#define decodeFloat16(v) unpackf16(uvec2((v) * 255.0f))\\n#define encodePairOfFloat16(f) vec4(encodeFloat16((f).x), encodeFloat16((f).y))\\n#define decodePairOfFloat16(v) vec2(decodeFloat16((v).rg), decodeFloat16((v).ba))\\n#define encodeNullPairOfFloat16() vec4(1.0f)\\n#define isNullPairOfFloat16(v) all(equal((v), encodeNullPairOfFloat16()))\\n#define encodeDiscardedPairOfFloat16() vec4(0.0f, 1.0f, 0.0f, 1.0f)\\n#define isDiscardedPairOfFloat16(v) all(equal((v), encodeDiscardedPairOfFloat16()))\\n#define encodeFloat16NaN() vec2(0.5f, 1.0f)\\n#define isEncodedFloat16NaN(v) all(equal((v), encodeFloat16NaN()))\\nuvec2 packf16( float f)\\n{\\nuint y = packHalf2x16(vec2(f, 0.0f));\\nreturn uvec2(y, y >> 8u) & 0xFFu;\\n}\\nfloat unpackf16(uvec2 v)\\n{\\nv &= 0xFFu;\\nreturn unpackHalf2x16(v.x | (v.y << 8u)).x;\\n}\\nbool isEncodedFloat16Zero(vec2 v)\\n{\\nuvec2 w = uvec2(v * 255.0f);\\nreturn 0u == w.x + w.y * (0x80u - w.y);\\n}\\n#endif\"","module.exports = \"#ifndef _GLOBAL_GLSL\\n#define _GLOBAL_GLSL\\n#define threadLocation() ivec2(texCoord * texSize)\\n#define outputSize() ivec2(texSize)\\n#define threadPixel(img) textureLod((img), texCoord, 0.0f)\\n#define pixelAt(img, pos) texelFetch((img), (pos), 0)\\n#define pixelAtShortOffset(img, offset) textureLodOffset((img), texCoord, 0.0f, (offset))\\n#define pixelAtLongOffset(img, offset) textureLod((img), texCoord + vec2(offset) / texSize, 0.0f)\\n#endif\"","module.exports = \"#ifndef _INT32_GLSL\\n#define _INT32_GLSL\\nuint decodeUint32(vec4 rgba)\\n{\\nuvec4 v = uvec4(rgba * 255.0f) & 255u;\\nreturn v.x | (v.y << 8u) | (v.z << 16u) | (v.w << 24u);\\n}\\nvec4 encodeUint32(uint value)\\n{\\nuvec4 v = uvec4(value, value >> 8u, value >> 16u, value >> 24u) & 255u;\\nreturn vec4(v) / 255.0f;\\n}\\n#endif\"","module.exports = \"#ifndef _KEYPOINT_DESCRIPTORS_GLSL\\n#define _KEYPOINT_DESCRIPTORS_GLSL\\n#if !defined(DESCRIPTOR_SIZE)\\n#error Must define DESCRIPTOR_SIZE\\n#elif !defined(_KEYPOINTS_GLSL)\\n#error Must include keypoints.glsl\\n#endif\\nuint[DESCRIPTOR_SIZE] readKeypointDescriptor(sampler2D encodedKeypoints, int descriptorSize, int extraSize, int encoderLength, KeypointAddress address)\\n{\\nint descriptorOffset = sizeofEncodedKeypoint(0, extraSize) / 4;\\nKeypointAddress descriptorAddress = KeypointAddress(address.base, descriptorOffset);\\nuint[DESCRIPTOR_SIZE] descriptor;\\nvec4 pixel; uvec4 bytes;\\n@unroll\\nfor(int i = 0; i < DESCRIPTOR_SIZE; i += 4) {\\npixel = readKeypointData(encodedKeypoints, encoderLength, descriptorAddress);\\nbytes = uvec4(pixel * 255.0f);\\ndescriptor[i]   = bytes.r;\\ndescriptor[i+1] = bytes.g;\\ndescriptor[i+2] = bytes.b;\\ndescriptor[i+3] = bytes.a;\\ndescriptorAddress.offset++;\\n}\\nreturn descriptor;\\n}\\nuint[DESCRIPTOR_SIZE] readKeypointDescriptorFromDB(sampler2D descriptorDB, int descriptorDBStride, int index)\\n{\\nuint[DESCRIPTOR_SIZE] descriptor;\\nint rasterIndex = index * (DESCRIPTOR_SIZE / 4) * int(index >= 0);\\nvec4 pixel; uvec4 bytes; ivec2 pos;\\n@unroll\\nfor(int i = 0; i < DESCRIPTOR_SIZE; i += 4) {\\npos = ivec2(rasterIndex % descriptorDBStride, rasterIndex / descriptorDBStride);\\npixel = (index >= 0) ? texelFetch(descriptorDB, pos, 0) : vec4(0.0f);\\nbytes = uvec4(pixel * 255.0f);\\ndescriptor[i]   = bytes.r;\\ndescriptor[i+1] = bytes.g;\\ndescriptor[i+2] = bytes.b;\\ndescriptor[i+3] = bytes.a;\\nrasterIndex++;\\n}\\nreturn descriptor;\\n}\\nint distanceBetweenKeypointDescriptors(uint[DESCRIPTOR_SIZE] a, uint[DESCRIPTOR_SIZE] b)\\n{\\nconst int[256] POPCNT = int[256](0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,4,5,5,6,5,6,6,7,5,6,6,7,6,7,7,8);\\nuvec4 xor, u, v;\\nint dist = 0;\\nivec4 bits;\\n@unroll\\nfor(int i = 0; i < DESCRIPTOR_SIZE; i += 4) {\\nu = uvec4(a[i], a[i+1], a[i+2], a[i+3]);\\nv = uvec4(b[i], b[i+1], b[i+2], b[i+3]);\\nxor = (u ^ v) & 255u;\\nbits = ivec4(POPCNT[xor.x], POPCNT[xor.y], POPCNT[xor.z], POPCNT[xor.w]);\\ndist += bits.x + bits.y + bits.z + bits.w;\\n}\\nreturn dist;\\n}\\n#endif\"","module.exports = \"#ifndef _KEYPOINT_MATCHES_GLSL\\n#define _KEYPOINT_MATCHES_GLSL\\n@include \\\"int32.glsl\\\"\\nconst int MATCH_INDEX_BITS = int(@MATCH_INDEX_BITS@);\\nconst int MATCH_INDEX_MASK = int(@MATCH_INDEX_MASK@);\\nconst int MATCH_MAX_INDEX = int(@MATCH_MAX_INDEX@);\\nconst int MATCH_MAX_DISTANCE = int(@MATCH_MAX_DISTANCE@);\\nstruct KeypointMatch\\n{\\nint index;\\nint dist;\\n};\\nvec4 encodeKeypointMatch(KeypointMatch candidate)\\n{\\nuint index = uint(candidate.index & MATCH_INDEX_MASK);\\nuint dist = uint(clamp(candidate.dist, 0, MATCH_MAX_DISTANCE));\\nuint u32 = index | (dist << MATCH_INDEX_BITS);\\nreturn encodeUint32(u32);\\n}\\nKeypointMatch decodeKeypointMatch(vec4 rgba)\\n{\\nuint u32 = decodeUint32(rgba);\\nint dist = int(u32 >> MATCH_INDEX_BITS);\\nint index = int(u32 & uint(MATCH_INDEX_MASK));\\nreturn KeypointMatch(index, dist);\\n}\\nconst KeypointMatch MATCH_NOT_FOUND = KeypointMatch(MATCH_MAX_INDEX, MATCH_MAX_DISTANCE);\\n#endif\"","module.exports = \"#ifndef _KEYPOINTS_GLSL\\n#define _KEYPOINTS_GLSL\\n@include \\\"math.glsl\\\"\\n@include \\\"fixed-point.glsl\\\"\\n@include \\\"float16.glsl\\\"\\n@include \\\"pyramids.glsl\\\"\\nstruct Keypoint\\n{\\nvec2 position;\\nfloat lod;\\nfloat orientation;\\nfloat score;\\nuint flags;\\n};\\nstruct KeypointAddress\\n{\\nint base;\\nint offset;\\n};\\nconst int MIN_KEYPOINT_SIZE = int(@MIN_KEYPOINT_SIZE@);\\nconst int MAX_DESCRIPTOR_SIZE = int(@MAX_DESCRIPTOR_SIZE@);\\nconst uint KPF_NONE = 0u;\\nconst uint KPF_NULL = 1u;\\nconst uint KPF_DISCARDED = 2u;\\n#define encodeKeypointScore(score) encodeFloat16(score)\\n#define decodeKeypointScore(encodedScore) decodeFloat16(encodedScore)\\n#define encodeKeypointOrientation(angle) ((angle) * INV_PI_OVER_2 + 0.5f)\\n#define decodeKeypointOrientation(value) ((value) * TWO_PI - PI)\\n#define encodeNullKeypoint() (vec4(1.0f))\\n#define encodeDiscardedKeypoint() (vec4(0.0f))\\n#define isNullKeypoint(keypoint) ((((keypoint).flags) & KPF_NULL) != 0u)\\n#define isDiscardedKeypoint(keypoint) ((((keypoint).flags) & KPF_DISCARDED) != 0u)\\n#define isBadKeypoint(keypoint) ((keypoint).score < 0.0f)\\n#define sizeofEncodedKeypoint(descriptorSize, extraSize) (MIN_KEYPOINT_SIZE + (descriptorSize) + (extraSize))\\n#define sizeofEncodedKeypointHeader() sizeofEncodedKeypoint(0,0)\\n#define findKeypointIndex(address, descriptorSize, extraSize) ((address).base / ((sizeofEncodedKeypoint((descriptorSize), (extraSize))) / 4))\\nvec4 readKeypointData(sampler2D encodedKeypoints, int encoderLength, KeypointAddress address)\\n{\\nint rasterIndex = address.base + address.offset;\\nvec4 data = pixelAt(encodedKeypoints, ivec2(rasterIndex % encoderLength, rasterIndex / encoderLength));\\nreturn rasterIndex < encoderLength * encoderLength ? data : encodeNullKeypoint();\\n}\\nKeypointAddress findKeypointAddress(ivec2 thread, int encoderLength, int descriptorSize, int extraSize)\\n{\\nint threadRaster = thread.y * encoderLength + thread.x;\\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\\nint keypointIndex = int(threadRaster / pixelsPerKeypoint);\\nKeypointAddress address = KeypointAddress(\\nkeypointIndex * pixelsPerKeypoint,\\nthreadRaster % pixelsPerKeypoint\\n);\\nreturn address;\\n}\\nKeypoint decodeKeypoint(sampler2D encodedKeypoints, int encoderLength, KeypointAddress address)\\n{\\nKeypoint keypoint;\\nKeypointAddress positionAddress = KeypointAddress(address.base, 0);\\nKeypointAddress propertiesAddress = KeypointAddress(address.base, 1);\\nvec4 rawEncodedPosition = readKeypointData(encodedKeypoints, encoderLength, positionAddress);\\nivec4 encodedPosition = ivec4(rawEncodedPosition * 255.0f);\\nkeypoint.position = fixtovec2(fixed2_t(\\nencodedPosition.r | (encodedPosition.g << 8),\\nencodedPosition.b | (encodedPosition.a << 8)\\n));\\nvec4 rawEncodedProperties = readKeypointData(encodedKeypoints, encoderLength, propertiesAddress);\\nkeypoint.lod = decodeLod(rawEncodedProperties.r);\\nkeypoint.orientation = decodeKeypointOrientation(rawEncodedProperties.g);\\nkeypoint.score = decodeKeypointScore(rawEncodedProperties.ba);\\nbool isNull = all(equal(rawEncodedPosition, vec4(1)));\\nbool isDiscarded = all(equal(rawEncodedPosition + rawEncodedProperties, vec4(0)));\\nkeypoint.score = (isNull || isDiscarded) ? -1.0f : keypoint.score;\\nkeypoint.flags = KPF_NONE;\\nkeypoint.flags |= KPF_NULL * uint(isNull);\\nkeypoint.flags |= KPF_DISCARDED * uint(isDiscarded);\\nreturn keypoint;\\n}\\nvec4 encodeKeypointPosition(vec2 position)\\n{\\nconst vec2 zeros = vec2(0.0f);\\nfixed2_t pos = vec2tofix(max(position, zeros));\\nfixed2_t lo = pos & 255;\\nfixed2_t hi = (pos >> 8) & 255;\\nreturn vec4(lo.x, hi.x, lo.y, hi.y) / 255.0f;\\n}\\n#endif\"","module.exports = \"#ifndef _MATH_GLSL\\n#define _MATH_GLSL\\n#define TWO_PI          6.28318530718f\\n#define PI              3.14159265359f\\n#define PI_OVER_2       1.57079632679f\\n#define PI_OVER_4       0.78539816339f\\n#define INV_PI          0.3183098861837907f\\n#define INV_PI_OVER_2   0.15915494309189535f\\nconst highp float INFINITY = 1.0f / 0.0f;\\nfloat fastAtan(float x)\\n{\\nfloat w = 1.0f - abs(x);\\nreturn (w >= 0.0f) ? ((PI_OVER_4 + 0.273f * w) * x) :\\n(sign(x) * PI_OVER_2 - (PI_OVER_4 + 0.273f * (1.0f - abs(1.0f / x))) / x);\\n}\\nfloat fastAtan2(float y, float x)\\n{\\nreturn (x == 0.0f) ? PI_OVER_2 * sign(y) : fastAtan(y / x) + float(x < 0.0f) * PI * sign(y);\\n}\\n#endif\"","module.exports = \"#ifndef _PYRAMIDS_GLSL\\n#define _PYRAMIDS_GLSL\\n#define pyrPixel(pyr, lod) textureLod((pyr), texCoord, (lod))\\n#define pyrPixelAtOffset(pyr, lod, pot, offset) textureLod((pyr), texCoord + ((pot) * vec2(offset)) / texSize, (lod))\\n#define pyrPixelAt(pyr, pos, lod) textureLod((pyr), (vec2(pos) + vec2(0.5f)) / texSize, (lod))\\n#define pyrPixelAtEx(pyr, pos, lod, pyrBaseSize) textureLod((pyr), (vec2(pos) + vec2(0.5f)) / vec2(pyrBaseSize), (lod))\\n#define pyrSubpixelAtEx(pyr, pos, lod, pyrBaseSize) textureLod((pyr), ((pos) + vec2(0.5f)) / vec2(pyrBaseSize), (lod))\\n#define pyrSubpixelAtExOffset(pyr, pos, lod, pot, offset, pyrBaseSize) textureLod((pyr), (((pos) + vec2(0.5f)) + ((pot) * vec2(offset))) / vec2(pyrBaseSize), (lod))\\nconst int PYRAMID_MAX_LEVELS = int(@PYRAMID_MAX_LEVELS@);\\nconst float F_PYRAMID_MAX_LEVELS = float(@PYRAMID_MAX_LEVELS@);\\nconst float LOG2_PYRAMID_MAX_SCALE = float(@LOG2_PYRAMID_MAX_SCALE@);\\n#define encodeLod(lod) ((LOG2_PYRAMID_MAX_SCALE + (lod)) / (LOG2_PYRAMID_MAX_SCALE + F_PYRAMID_MAX_LEVELS))\\nfloat decodeLod(float encodedLod)\\n{\\nfloat lod = encodedLod * (LOG2_PYRAMID_MAX_SCALE + F_PYRAMID_MAX_LEVELS) - LOG2_PYRAMID_MAX_SCALE;\\nreturn lod - lod * step(1.0f, encodedLod);\\n}\\n#define LOD_EPS 0.0625f\\nconst float ENCODED_LOD_EPS = (LOD_EPS / (LOG2_PYRAMID_MAX_SCALE + F_PYRAMID_MAX_LEVELS));\\n#define isSameLod(lod1, lod2) (abs((lod1) - (lod2)) < LOD_EPS)\\n#define isSameEncodedLod(alpha1, alpha2) (abs((alpha1) - (alpha2)) < ENCODED_LOD_EPS)\\n#endif\"","module.exports = \"#ifndef _SUBPIXEL_GLSL\\n#define _SUBPIXEL_GLSL\\n#define subpixelAt(image, pos) textureLod((image), ((pos) + vec2(0.5f)) / texSize, 0.0f)\\nvec4 subpixelAtBI(sampler2D image, vec2 pos)\\n{\\nvec2 frc = fract(pos);\\nvec2 ifrc = vec2(1.0f) - frc;\\nvec2 p = (floor(pos) + vec2(0.5f)) / vec2(textureSize(image, 0));\\nvec4 pix00 = textureLod(image, p, 0.0f);\\nvec4 pix10 = textureLodOffset(image, p, 0.0f, ivec2(1,0));\\nvec4 pix01 = textureLodOffset(image, p, 0.0f, ivec2(0,1));\\nvec4 pix11 = textureLodOffset(image, p, 0.0f, ivec2(1,1));\\nmat4 pix = mat4(pix00, pix10, pix01, pix11);\\nvec4 mul = vec4(ifrc.x * ifrc.y, frc.x * ifrc.y, ifrc.x * frc.y, frc.x * frc.y);\\nreturn pix * mul;\\n}\\n#endif\"","module.exports = \"@include \\\"keypoints.glsl\\\"\\nuniform sampler2D inputEncodedKeypoints;\\nuniform int inputDescriptorSize;\\nuniform int inputExtraSize;\\nuniform int inputEncoderLength;\\nuniform int outputDescriptorSize;\\nuniform int outputExtraSize;\\nuniform int outputEncoderLength;\\nconst vec4 EMPTY_DESCRIPTOR = vec4(0.0f);\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nKeypointAddress myAddress = findKeypointAddress(thread, outputEncoderLength, outputDescriptorSize, outputExtraSize);\\nint myIndex = findKeypointIndex(myAddress, outputDescriptorSize, outputExtraSize);\\nint headerSize = sizeofEncodedKeypointHeader();\\nbool isDescriptor = (myAddress.offset >= (headerSize + outputExtraSize) / 4);\\nint addressOffset = myAddress.offset;\\nint pixelsPerKeypoint = sizeofEncodedKeypoint(inputDescriptorSize, inputExtraSize) / 4;\\nKeypointAddress otherAddress = KeypointAddress(myIndex * pixelsPerKeypoint, addressOffset);\\ncolor = isDescriptor ? EMPTY_DESCRIPTOR : readKeypointData(inputEncodedKeypoints, inputEncoderLength, otherAddress);\\n}\"","module.exports = \"@include \\\"keypoints.glsl\\\"\\nuniform sampler2D inputEncodedKeypoints;\\nuniform int inputDescriptorSize;\\nuniform int inputExtraSize;\\nuniform int inputEncoderLength;\\nuniform int outputDescriptorSize;\\nuniform int outputExtraSize;\\nuniform int outputEncoderLength;\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nKeypointAddress myAddress = findKeypointAddress(thread, outputEncoderLength, outputDescriptorSize, outputExtraSize);\\nint myIndex = findKeypointIndex(myAddress, outputDescriptorSize, outputExtraSize);\\nint headerSize = sizeofEncodedKeypointHeader();\\nbool isHead = (myAddress.offset < headerSize / 4);\\nbool isDescriptor = (myAddress.offset >= (headerSize + outputExtraSize) / 4);\\nbool isExtra = (!isHead && !isDescriptor);\\nint numberOfExtraPixels = outputExtraSize / 4;\\nint addressOffset = myAddress.offset - int(isDescriptor) * numberOfExtraPixels;\\nint pixelsPerKeypoint = sizeofEncodedKeypoint(inputDescriptorSize, inputExtraSize) / 4;\\nKeypointAddress otherAddress = KeypointAddress(myIndex * pixelsPerKeypoint, addressOffset);\\ncolor = isExtra ? vec4(0.0f) : readKeypointData(inputEncodedKeypoints, inputEncoderLength, otherAddress);\\n}\"","module.exports = \"@include \\\"keypoints.glsl\\\"\\nuniform mat3 homography;\\nuniform sampler2D encodedKeypoints;\\nuniform int descriptorSize;\\nuniform int extraSize;\\nuniform int encoderLength;\\nvoid main()\\n{\\nvec4 pixel = threadPixel(encodedKeypoints);\\nivec2 thread = threadLocation();\\nKeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\\ncolor = pixel;\\nif(address.offset != 0)\\nreturn;\\nKeypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, address);\\nif(isBadKeypoint(keypoint))\\nreturn;\\nvec3 pos3 = homography * vec3(keypoint.position, 1.0f);\\ncolor = encodeKeypointPosition(pos3.xy / pos3.z);\\n}\"","module.exports = \"@include \\\"keypoints.glsl\\\"\\n@include \\\"keypoint-descriptors.glsl\\\"\\n@include \\\"keypoint-matches.glsl\\\"\\nuniform sampler2D encodedMatches;\\nuniform sampler2D encodedFilters;\\nuniform int matcherLength;\\nuniform sampler2D dbEncodedKeypoints;\\nuniform int dbDescriptorSize;\\nuniform int dbExtraSize;\\nuniform int dbEncoderLength;\\nuniform sampler2D encodedKeypoints;\\nuniform int descriptorSize;\\nuniform int extraSize;\\nuniform int encoderLength;\\nuniform int passId;\\n#ifndef NUMBER_OF_KEYPOINTS_PER_PASS\\n#error Undefined NUMBER_OF_KEYPOINTS_PER_PASS\\n#endif\\nconst int INFINITE_DISTANCE = MATCH_MAX_DISTANCE + 1;\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nint keypointIndex = thread.x + thread.y * matcherLength;\\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\\nKeypointAddress address = KeypointAddress(keypointIndex * pixelsPerKeypoint, 0);\\nKeypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, address);\\ncolor = encodeKeypointMatch(MATCH_NOT_FOUND);\\nif(isBadKeypoint(keypoint))\\nreturn;\\nKeypointMatch bestMatch = decodeKeypointMatch(threadPixel(encodedMatches));\\nKeypointMatch filterMatch = decodeKeypointMatch(threadPixel(encodedFilters));\\nuint[DESCRIPTOR_SIZE] descriptor = readKeypointDescriptor(encodedKeypoints, descriptorSize, extraSize, encoderLength, address);\\nuint[DESCRIPTOR_SIZE] dbDescriptor;\\nint dbPixelsPerKeypoint = sizeofEncodedKeypoint(dbDescriptorSize, dbExtraSize) / 4;\\nfor(int i = 0; i < NUMBER_OF_KEYPOINTS_PER_PASS; i++) {\\nint dbKeypointIndex = passId * NUMBER_OF_KEYPOINTS_PER_PASS + i;\\nKeypointAddress dbAddress = KeypointAddress(dbKeypointIndex * dbPixelsPerKeypoint, 0);\\nKeypoint dbKeypoint = decodeKeypoint(dbEncodedKeypoints, dbEncoderLength, dbAddress);\\ndbDescriptor = readKeypointDescriptor(dbEncodedKeypoints, dbDescriptorSize, dbExtraSize, dbEncoderLength, dbAddress);\\nint dist = !isBadKeypoint(dbKeypoint) ? distanceBetweenKeypointDescriptors(descriptor, dbDescriptor) : INFINITE_DISTANCE;\\nbestMatch.index = all(bvec2(\\ndist < bestMatch.dist || (dist == bestMatch.dist && dbKeypointIndex > bestMatch.index),\\ndist > filterMatch.dist || (dist == filterMatch.dist && dbKeypointIndex < filterMatch.index)\\n)) ? dbKeypointIndex : bestMatch.index;\\nbestMatch.dist = dbKeypointIndex == bestMatch.index ? dist : bestMatch.dist;\\n}\\ncolor = encodeKeypointMatch(bestMatch);\\n}\"","module.exports = \"@include \\\"keypoints.glsl\\\"\\nuniform int imageWidth;\\nuniform int imageHeight;\\nuniform int borderTop;\\nuniform int borderRight;\\nuniform int borderBottom;\\nuniform int borderLeft;\\nuniform sampler2D encodedKeypoints;\\nuniform int descriptorSize;\\nuniform int extraSize;\\nuniform int encoderLength;\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nKeypointAddress addr = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\\nKeypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, addr);\\nvec2 p = keypoint.position;\\nbool withinBorder = any(lessThan(\\nvec4(p.x, p.y, -p.x, -p.y),\\nvec4(borderLeft, borderTop, borderRight - (imageWidth - 1), borderBottom - (imageHeight - 1))\\n));\\nvec4 pixel = threadPixel(encodedKeypoints);\\nvec4 nullPixel = encodeNullKeypoint();\\ncolor = withinBorder ? nullPixel : pixel;\\n}\"","module.exports = \"@include \\\"keypoints.glsl\\\"\\nuniform sampler2D encodedKeypoints;\\nuniform int descriptorSize;\\nuniform int extraSize;\\nuniform int encoderLength;\\nuniform int maxKeypoints;\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nint newEncoderLength = outputSize().x;\\nKeypointAddress address = findKeypointAddress(thread, newEncoderLength, descriptorSize, extraSize);\\nint index = findKeypointIndex(address, descriptorSize, extraSize);\\nvec4 pixel = readKeypointData(encodedKeypoints, encoderLength, address);\\ncolor = index < maxKeypoints ? pixel : encodeNullKeypoint();\\n}\"","module.exports = \"@include \\\"keypoints.glsl\\\"\\nuniform sampler2D encodedKeypointsA;\\nuniform int encoderLengthA;\\nuniform sampler2D encodedKeypointsB;\\nuniform int encoderLengthB;\\nuniform int descriptorSize;\\nuniform int extraSize;\\nuniform int encoderLength;\\nuniform float threshold;\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nKeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\\nint index = findKeypointIndex(address, descriptorSize, extraSize);\\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\\nvec4 data = readKeypointData(encodedKeypointsA, encoderLengthA, address);\\ncolor = data;\\nif(address.offset >= sizeofEncodedKeypointHeader() / 4)\\nreturn;\\nKeypoint keypointA = decodeKeypoint(encodedKeypointsA, encoderLengthA, address);\\nKeypoint keypointB = decodeKeypoint(encodedKeypointsB, encoderLengthB, address);\\ncolor = encodeNullKeypoint();\\nif(isNullKeypoint(keypointA) && isNullKeypoint(keypointB))\\nreturn;\\ncolor = encodeDiscardedKeypoint();\\nif(isDiscardedKeypoint(keypointA) || isDiscardedKeypoint(keypointB))\\nreturn;\\ncolor = encodeDiscardedKeypoint();\\nif(isNullKeypoint(keypointA) || isNullKeypoint(keypointB))\\nreturn;\\nvec2 delta = keypointA.position - keypointB.position;\\nbool shouldKeep = (dot(delta, delta) <= threshold * threshold);\\ncolor = shouldKeep ? data : encodeDiscardedKeypoint();\\n}\"","module.exports = \"@include \\\"float16.glsl\\\"\\nuniform sampler2D offsetsImage;\\nuniform ivec2 imageSize;\\n#ifndef MAX_ITERATIONS\\n#error Undefined MAX_ITERATIONS\\n#endif\\n#define decodeSkipOffset(pixel) (int((pixel).g * 255.0f) | (int((pixel).a * 255.0f) << 8))\\n#define encodeSkipOffset(offset) (vec2((offset) & 255, (offset) >> 8) / 255.0f)\\nvoid main()\\n{\\nvec4 pixel = threadPixel(offsetsImage);\\nivec2 thread = threadLocation();\\nint rasterIndex = thread.y * imageSize.x + thread.x;\\nint offset = decodeSkipOffset(pixel);\\nint totalOffset = offset;\\nvec2 encodedScore = pixel.rb;\\nivec2 pos = thread; int allow = 1;\\n@unroll\\nfor(int i = 0; i < MAX_ITERATIONS; i++) {\\nallow *= int(pos.y < imageSize.y) * int(isEncodedFloat16Zero(pixel.rb));\\nrasterIndex += allow * offset;\\npos = ivec2(rasterIndex % imageSize.x, rasterIndex / imageSize.x);\\npixel = pixelAt(offsetsImage, pos);\\noffset = decodeSkipOffset(pixel);\\ntotalOffset += allow * offset;\\n}\\ntotalOffset = min(totalOffset, 65535);\\ncolor.rb = encodedScore;\\ncolor.ga = encodeSkipOffset(totalOffset);\\n}\"","module.exports = \"@include \\\"float16.glsl\\\"\\nuniform sampler2D corners;\\nuniform ivec2 imageSize;\\nvoid main()\\n{\\nvec4 pixel = threadPixel(corners);\\nivec2 pos = threadLocation();\\nvec2 encodedScore = pixel.rb;\\nint offset = 0, allow = 1, jumped = 0;\\n#define READ(j) ; \\\\\\nallow *= int(pos.y < imageSize.y) * int(isEncodedFloat16Zero(pixel.rb)); \\\\\\noffset += allow; \\\\\\npos.x = (pos.x + 1) % imageSize.x; \\\\\\npos.y += int(pos.x == 0); \\\\\\npixel = (0 != (jumped |= int(pos.x == 0))) ? pixelAtShortOffset(corners, ivec2((j),1)) : pixelAtShortOffset(corners, ivec2((j),0))\\nREAD(1); READ(2); READ(3); READ(4); READ(5); READ(6); READ(7);\\ncolor.rb = encodedScore;\\ncolor.ga = vec2(offset, 0) / 255.0f;\\n}\"","module.exports = \"@include \\\"keypoints.glsl\\\"\\nuniform sampler2D offsetsImage;\\nuniform ivec2 imageSize;\\nuniform int passId;\\nuniform int numPasses;\\nuniform int keypointLimit;\\nuniform sampler2D encodedKeypoints;\\nuniform int descriptorSize;\\nuniform int extraSize;\\nuniform int encoderLength;\\n#define decodeSkipOffset(pixel) (int((pixel).g * 255.0f) | (int((pixel).a * 255.0f) << 8))\\nbool findQthKeypoint(int q, int p, inout ivec2 position, out vec4 pixel)\\n{\\nint notFirstPass = int(passId > 0);\\nposition *= notFirstPass;\\np |= -(1 - notFirstPass);\\np -= notFirstPass;\\nint rasterIndex = position.y * imageSize.x + position.x;\\nwhile(position.y < imageSize.y && p != q) {\\nposition = ivec2(rasterIndex % imageSize.x, rasterIndex / imageSize.x);\\npixel = texelFetch(offsetsImage, position, 0);\\np += int(!isEncodedFloat16Zero(pixel.rb));\\nrasterIndex += max(1, decodeSkipOffset(pixel));\\n}\\nreturn (p == q);\\n}\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\\nKeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\\nint q = findKeypointIndex(address, descriptorSize, extraSize);\\ncolor = vec4(0.0f);\\nif(address.offset != 0)\\nreturn;\\ncolor = threadPixel(encodedKeypoints);\\nint numPixels = encoderLength * encoderLength;\\nint maxKeypoints = numPixels / pixelsPerKeypoint;\\nint maxKeypointsPerPass = maxKeypoints / numPasses + int(maxKeypoints % numPasses != 0);\\nint targetPassId = q / maxKeypointsPerPass;\\nif(passId != targetPassId)\\nreturn;\\nint lastIndexFromPrevPass = passId * maxKeypointsPerPass - 1;\\nKeypointAddress lastAddressFromPrevPass = KeypointAddress(max(0, lastIndexFromPrevPass) * pixelsPerKeypoint, 0);\\nKeypoint lastKeypointFromPrevPass = decodeKeypoint(encodedKeypoints, encoderLength, lastAddressFromPrevPass);\\nivec2 position = passId > 0 ? ivec2(lastKeypointFromPrevPass.position) : ivec2(0);\\nvec4 pixel;\\ncolor = encodeNullKeypoint();\\nif(q >= min(maxKeypoints, keypointLimit) || !findQthKeypoint(q, lastIndexFromPrevPass, position, pixel))\\nreturn;\\ncolor = encodeKeypointPosition(vec2(position));\\n}\"","module.exports = \"@include \\\"keypoints.glsl\\\"\\nuniform sampler2D corners;\\nuniform sampler2D encodedKeypoints;\\nuniform int descriptorSize;\\nuniform int extraSize;\\nuniform int encoderLength;\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nvec4 pixel = threadPixel(encodedKeypoints);\\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\\nKeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\\nint q = findKeypointIndex(address, descriptorSize, extraSize);\\ncolor = pixel;\\nif(address.offset != 1)\\nreturn;\\nKeypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, address);\\nvec4 kpix = pixelAt(corners, ivec2(keypoint.position));\\nkeypoint.score = decodeFloat16(kpix.rb);\\ncolor.r = kpix.a;\\ncolor.g = encodeKeypointOrientation(0.0f);\\ncolor.ba = encodeKeypointScore(keypoint.score);\\n}\"","module.exports = \"@include \\\"keypoints.glsl\\\"\\nuniform sampler2D corners;\\nuniform mediump usampler2D lookupTable;\\nuniform int stride;\\nuniform int descriptorSize;\\nuniform int extraSize;\\nuniform int encoderLength;\\nuniform int encoderCapacity;\\nconst uvec2 NULL_ELEMENT = uvec2(0xFFFFu);\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nKeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\\nint index = findKeypointIndex(address, descriptorSize, extraSize);\\nivec2 pos = ivec2(index % stride, index / stride);\\nuvec4 entry = texelFetch(lookupTable, pos, 0);\\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\\nint rasterIndex = address.base + address.offset;\\nint numberOfPixels = encoderLength * encoderLength;\\nint numberOfValidPixels = numberOfPixels - (numberOfPixels % pixelsPerKeypoint);\\nint maxEncoderCapacity = numberOfValidPixels / pixelsPerKeypoint;\\ncolor = encodeNullKeypoint();\\nif(all(equal(entry.xy, NULL_ELEMENT)) || index >= min(encoderCapacity, maxEncoderCapacity))\\nreturn;\\ncolor = encodeKeypointPosition(vec2(entry.xy));\\nif(address.offset == 0)\\nreturn;\\ncolor = vec4(0.0f);\\nif(address.offset >= sizeofEncodedKeypointHeader() / 4)\\nreturn;\\nvec4 pixel = texelFetch(corners, ivec2(entry.xy), 0);\\nvec2 encodedScore = encodeKeypointScore(decodeFloat16(pixel.rb));\\nfloat encodedOrientation = encodeKeypointOrientation(0.0f);\\nfloat encodedLod = pixel.a;\\ncolor = vec4(encodedLod, encodedOrientation, encodedScore);\\n}\"","module.exports = \"@include \\\"keypoints.glsl\\\"\\nvoid main()\\n{\\ncolor = encodeNullKeypoint();\\n}\"","module.exports = \"@include \\\"pyramids.glsl\\\"\\n@include \\\"float16.glsl\\\"\\nuniform sampler2D corners;\\nuniform sampler2D pyramid;\\nuniform float lod;\\nuniform int threshold;\\n#define USE_VARYINGS 1\\n#if !defined(FAST_TYPE)\\n#error Undefined FAST_TYPE\\n#elif FAST_TYPE == 916\\nin vec2 v_pix0, v_pix1, v_pix2, v_pix3, v_pix4, v_pix5, v_pix6, v_pix7,\\nv_pix8, v_pix9, v_pix10,v_pix11,v_pix12,v_pix13,v_pix14,v_pix15;\\n#else\\n#error Invalid FAST_TYPE\\n#endif\\n#define PIX(x,y) pyrPixelAtOffset(pyramid, lod, pot, ivec2((x),(y))).g\\n#define XIP(v) textureLod(pyramid, (v), lod).g\\nvoid main()\\n{\\nfloat pixel = threadPixel(pyramid).g;\\nvec4 prev = threadPixel(corners);\\nivec2 thread = threadLocation();\\nivec2 size = outputSize();\\nfloat pot = exp2(lod);\\nfloat t = float(clamp(threshold, 0, 255)) / 255.0f;\\nfloat ct = pixel + t, c_t = pixel - t;\\ncolor = vec4(prev.r, pixel, prev.ba);\\n#if FAST_TYPE == 916\\nconst ivec4 margin = ivec4(3, 3, 4, 4);\\nif(any(lessThan(ivec4(thread, size - thread), margin)))\\nreturn;\\n#if USE_VARYINGS\\nfloat p0 = XIP(v_pix0), p4 = XIP(v_pix4), p8 = XIP(v_pix8), p12 = XIP(v_pix12);\\n#else\\nfloat p0 = PIX(0,3), p4 = PIX(3,0), p8 = PIX(0,-3), p12 = PIX(-3,0);\\n#endif\\nbvec4 brighter = bvec4(p0 > ct, p4 > ct, p8 > ct, p12 > ct);\\nbvec4 darker = bvec4(p0 < c_t, p4 < c_t, p8 < c_t, p12 < c_t);\\nbvec4 bpairs = bvec4(all(brighter.xy), all(brighter.yz), all(brighter.zw), all(brighter.wx));\\nbvec4 dpairs = bvec4(all(darker.xy), all(darker.yz), all(darker.zw), all(darker.wx));\\nif(!(any(bpairs) || any(dpairs)))\\nreturn;\\n#if USE_VARYINGS\\nfloat p1 = XIP(v_pix1), p2 = XIP(v_pix2), p3 = XIP(v_pix3),\\np5 = XIP(v_pix5), p6 = XIP(v_pix6), p7 = XIP(v_pix7),\\np9 = XIP(v_pix9), p10 = XIP(v_pix10), p11 = XIP(v_pix11),\\np13 = XIP(v_pix13), p14 = XIP(v_pix14), p15 = XIP(v_pix15);\\n#else\\nfloat p1 = PIX(1,3), p2 = PIX(2,2), p3 = PIX(3,1),\\np5 = PIX(3,-1), p6 = PIX(2,-2), p7 = PIX(1,-3),\\np9 = PIX(-1,-3), p10 = PIX(-2,-2), p11 = PIX(-3,-1),\\np13 = PIX(-3,1), p14 = PIX(-2,2), p15 = PIX(-1,3);\\n#endif\\nbool A=(p0>ct),B=(p1>ct),C=(p2>ct),D=(p3>ct),E=(p4>ct),F=(p5>ct),G=(p6>ct),H=(p7>ct),I=(p8>ct),J=(p9>ct),K=(p10>ct),L=(p11>ct),M=(p12>ct),N=(p13>ct),O=(p14>ct),P=(p15>ct),a=(p0<c_t),b=(p1<c_t),c=(p2<c_t),d=(p3<c_t),e=(p4<c_t),f=(p5<c_t),g=(p6<c_t),h=(p7<c_t),i=(p8<c_t),j=(p9<c_t),k=(p10<c_t),l=(p11<c_t),m=(p12<c_t),n=(p13<c_t),o=(p14<c_t),p=(p15<c_t);\\nbool isCorner=A&&(B&&(K&&L&&J&&(M&&N&&O&&P||G&&H&&I&&(M&&N&&O||F&&(M&&N||E&&(M||D))))||C&&(K&&L&&M&&(N&&O&&P||G&&H&&I&&J&&(N&&O||F&&(N||E)))||D&&(N&&(L&&M&&(K&&G&&H&&I&&J&&(O||F)||O&&P)||k&&l&&m&&e&&f&&g&&h&&i&&j)||E&&(O&&(M&&N&&(K&&L&&G&&H&&I&&J||P)||k&&l&&m&&n&&f&&g&&h&&i&&j)||F&&(P&&(N&&O||k&&l&&m&&n&&o&&g&&h&&i&&j)||G&&(O&&P||H&&(P||I)||k&&l&&m&&n&&o&&p&&h&&i&&j)||k&&l&&m&&n&&o&&h&&i&&j&&(p||g))||k&&l&&m&&n&&h&&i&&j&&(o&&(p||g)||f&&(o&&p||g)))||k&&l&&m&&h&&i&&j&&(n&&(o&&p||g&&(o||f))||e&&(n&&o&&p||g&&(n&&o||f))))||k&&l&&h&&i&&j&&(m&&(n&&o&&p||g&&(n&&o||f&&(n||e)))||d&&(m&&n&&o&&p||g&&(m&&n&&o||f&&(m&&n||e)))))||k&&h&&i&&j&&(l&&(m&&n&&o&&p||g&&(m&&n&&o||f&&(m&&n||e&&(m||d))))||c&&(l&&m&&n&&o&&p||g&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d))))))||K&&I&&J&&(L&&M&&N&&O&&P||G&&H&&(L&&M&&N&&O||F&&(L&&M&&N||E&&(L&&M||D&&(L||C)))))||h&&i&&j&&(b&&(k&&l&&m&&n&&o&&p||g&&(k&&l&&m&&n&&o||f&&(k&&l&&m&&n||e&&(k&&l&&m||d&&(k&&l||c)))))||k&&(l&&m&&n&&o&&p||g&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c)))))))||B&&(H&&I&&J&&(K&&L&&M&&N&&O&&P&&a||G&&(K&&L&&M&&N&&O&&a||F&&(K&&L&&M&&N&&a||E&&(K&&L&&M&&a||D&&(K&&L&&a||C)))))||a&&k&&i&&j&&(l&&m&&n&&o&&p||g&&h&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c))))))||C&&(K&&H&&I&&J&&(L&&M&&N&&O&&P&&a&&b||G&&(L&&M&&N&&O&&a&&b||F&&(L&&M&&N&&a&&b||E&&(L&&M&&a&&b||D))))||a&&b&&k&&l&&j&&(m&&n&&o&&p||g&&h&&i&&(m&&n&&o||f&&(m&&n||e&&(m||d)))))||D&&(K&&L&&H&&I&&J&&(M&&N&&O&&P&&a&&b&&c||G&&(M&&N&&O&&a&&b&&c||F&&(M&&N&&a&&b&&c||E)))||a&&b&&k&&l&&m&&c&&(n&&o&&p||g&&h&&i&&j&&(n&&o||f&&(n||e))))||E&&(K&&L&&M&&H&&I&&J&&(N&&O&&P&&a&&b&&c&&d||G&&(N&&O&&a&&b&&c&&d||F))||a&&b&&l&&m&&n&&c&&d&&(k&&g&&h&&i&&j&&(o||f)||o&&p))||F&&(K&&L&&M&&N&&H&&I&&J&&(O&&P&&a&&b&&c&&d&&e||G)||a&&b&&m&&n&&o&&c&&d&&e&&(k&&l&&g&&h&&i&&j||p))||G&&(K&&L&&M&&N&&O&&H&&I&&J||a&&b&&n&&o&&p&&c&&d&&e&&f)||H&&(K&&L&&M&&N&&O&&P&&I&&J||a&&b&&o&&p&&c&&d&&e&&f&&g)||a&&(b&&(k&&l&&j&&(m&&n&&o&&p||g&&h&&i&&(m&&n&&o||f&&(m&&n||e&&(m||d))))||c&&(k&&l&&m&&(n&&o&&p||g&&h&&i&&j&&(n&&o||f&&(n||e)))||d&&(l&&m&&n&&(k&&g&&h&&i&&j&&(o||f)||o&&p)||e&&(m&&n&&o&&(k&&l&&g&&h&&i&&j||p)||f&&(n&&o&&p||g&&(o&&p||h&&(p||i)))))))||k&&i&&j&&(l&&m&&n&&o&&p||g&&h&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c))))))||h&&i&&j&&(k&&l&&m&&n&&o&&p||g&&(k&&l&&m&&n&&o||f&&(k&&l&&m&&n||e&&(k&&l&&m||d&&(k&&l||c&&(b||k))))));\\nif(!isCorner)\\nreturn;\\nmat4 mp = mat4(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15);\\nmat4 mct = mp - mat4(ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct);\\nmat4 mc_t = mat4(c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t) - mp;\\nconst vec4 zeros = vec4(0.0f), ones = vec4(1.0f);\\nvec4 bs = max(mct[0], zeros), ds = max(mc_t[0], zeros);\\nbs += max(mct[1], zeros);     ds += max(mc_t[1], zeros);\\nbs += max(mct[2], zeros);     ds += max(mc_t[2], zeros);\\nbs += max(mct[3], zeros);     ds += max(mc_t[3], zeros);\\nfloat thisScore = max(dot(bs, ones), dot(ds, ones)) / 16.0f;\\nfloat prevScore = decodeFloat16(prev.rb);\\nvec3 thisResult = vec3(encodeFloat16(thisScore), encodeLod(lod));\\ncolor.rba = thisScore > prevScore ? thisResult : color.rba;\\n#endif\\n}\"","module.exports = \"uniform mediump float lod;\\n#if !defined(FAST_TYPE)\\n#error Undefined FAST_TYPE\\n#elif FAST_TYPE == 916\\nout vec2 v_pix0, v_pix1, v_pix2, v_pix3, v_pix4, v_pix5, v_pix6, v_pix7,\\nv_pix8, v_pix9, v_pix10,v_pix11,v_pix12,v_pix13,v_pix14,v_pix15;\\n#else\\n#error Invalid FAST_TYPE\\n#endif\\n#define PIX(x,y) (texCoord + ((pot) * vec2((x),(y))) / texSize)\\nvoid vsmain()\\n{\\nfloat pot = exp2(lod);\\n#if FAST_TYPE == 916\\nv_pix0 = PIX(0,3); v_pix1 = PIX(1,3), v_pix2 = PIX(2,2), v_pix3 = PIX(3,1);\\nv_pix4 = PIX(3,0); v_pix5 = PIX(3,-1), v_pix6 = PIX(2,-2), v_pix7 = PIX(1,-3);\\nv_pix8 = PIX(0,-3); v_pix9 = PIX(-1,-3), v_pix10 = PIX(-2,-2), v_pix11 = PIX(-3,-1);\\nv_pix12 = PIX(-3,0); v_pix13 = PIX(-3,1), v_pix14 = PIX(-2,2), v_pix15 = PIX(-1,3);\\n#endif\\n}\"","module.exports = \"@include \\\"keypoints.glsl\\\"\\n@include \\\"keypoint-descriptors.glsl\\\"\\nuniform sampler2D encodedKeypointsA;\\nuniform int encoderLengthA;\\nuniform sampler2D encodedKeypointsB;\\nuniform int encoderLengthB;\\nuniform int descriptorSize;\\nuniform int extraSize;\\nuniform int encoderLength;\\nuniform int threshold;\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nKeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\\nint index = findKeypointIndex(address, descriptorSize, extraSize);\\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\\nvec4 data = readKeypointData(encodedKeypointsA, encoderLengthA, address);\\ncolor = data;\\nif(address.offset >= sizeofEncodedKeypointHeader() / 4)\\nreturn;\\nKeypoint keypointA = decodeKeypoint(encodedKeypointsA, encoderLengthA, address);\\nKeypoint keypointB = decodeKeypoint(encodedKeypointsB, encoderLengthB, address);\\ncolor = encodeNullKeypoint();\\nif(isNullKeypoint(keypointA) && isNullKeypoint(keypointB))\\nreturn;\\ncolor = encodeDiscardedKeypoint();\\nif(isDiscardedKeypoint(keypointA) || isDiscardedKeypoint(keypointB))\\nreturn;\\ncolor = encodeDiscardedKeypoint();\\nif(isNullKeypoint(keypointA) || isNullKeypoint(keypointB))\\nreturn;\\nuint[DESCRIPTOR_SIZE] descriptorA, descriptorB;\\ndescriptorA = readKeypointDescriptor(encodedKeypointsA, descriptorSize, extraSize, encoderLengthA, address);\\ndescriptorB = readKeypointDescriptor(encodedKeypointsB, descriptorSize, extraSize, encoderLengthB, address);\\nint dist = distanceBetweenKeypointDescriptors(descriptorA, descriptorB);\\nbool shouldKeep = (dist <= threshold);\\ncolor = shouldKeep ? data : encodeDiscardedKeypoint();\\n}\"","module.exports = \"@include \\\"float16.glsl\\\"\\nuniform sampler2D corners;\\nuniform sampler2D maxScore;\\nuniform float quality;\\nvoid main()\\n{\\nvec4 pixel = threadPixel(corners);\\nfloat score = decodeFloat16(pixel.rb);\\nfloat maxval = decodeFloat16(threadPixel(maxScore).rb);\\nfloat threshold = maxval * clamp(quality, 0.0f, 1.0f);\\ncolor = pixel;\\ncolor.rb = score >= threshold ? color.rb : encodeFloat16(0.0f);\\n}\"","module.exports = \"@include \\\"pyramids.glsl\\\"\\n@include \\\"float16.glsl\\\"\\n@include \\\"filters.glsl\\\"\\n#if !defined(WINDOW_SIZE)\\n#error Undefined WINDOW_SIZE\\n#endif\\n#define WINDOW_RADIUS ((WINDOW_SIZE - 1) / 2)\\nuniform sampler2D corners;\\nuniform sampler2D pyramid;\\nuniform sampler2D derivatives;\\nuniform float lod;\\nuniform float lodStep;\\nuniform float gaussian[@WINDOW_SIZE@];\\n#define G(x) gaussian[(x) + WINDOW_RADIUS]\\n#define W(x,y) (G(x) * G(y))\\n#define H(ox,oy) dpix = pixelAtShortOffset(derivatives, ivec2((ox),(oy))); \\\\\\ndf = (1.0f + lod) * decodePairOfFloat16(dpix); \\\\\\nh += vec3(df.x * df.x, df.x * df.y, df.y * df.y) * W((ox),(oy))\\nvoid main()\\n{\\nfloat intensity = 0.0f;\\nivec2 thread = threadLocation();\\nvec4 pixel = threadPixel(corners);\\nvec4 dpix = vec4(0.0f);\\nvec2 df = vec2(0.0f);\\nvec3 h = vec3(0.0f);\\ncolor = pixel;\\n#if WINDOW_SIZE == 1\\nH(0,0);\\n#elif WINDOW_SIZE == 3\\nH(-1,-1); H(0,-1); H(1,-1);\\nH(-1,0); H(0,0); H(1,0);\\nH(-1,1); H(0,1); H(1,1);\\n#elif WINDOW_SIZE == 5\\nH(-2,-2); H(-1,-2); H(0,-2); H(1,-2); H(2,-2);\\nH(-2,-1); H(-1,-1); H(0,-1); H(1,-1); H(2,-1);\\nH(-2,0); H(-1,0); H(0,0); H(1,0); H(2,0);\\nH(-2,1); H(-1,1); H(0,1); H(1,1); H(2,1);\\nH(-2,2); H(-1,2); H(0,2); H(1,2); H(2,2);\\n#elif WINDOW_SIZE == 7\\nH(-3,-3); H(-2,-3); H(-1,-3); H(0,-3); H(1,-3); H(2,-3); H(3,-3);\\nH(-3,-2); H(-2,-2); H(-1,-2); H(0,-2); H(1,-2); H(2,-2); H(3,-2);\\nH(-3,-1); H(-2,-1); H(-1,-1); H(0,-1); H(1,-1); H(2,-1); H(3,-1);\\nH(-3,0); H(-2,0); H(-1,0); H(0,0); H(1,0); H(2,0); H(3,0);\\nH(-3,1); H(-2,1); H(-1,1); H(0,1); H(1,1); H(2,1); H(3,1);\\nH(-3,2); H(-2,2); H(-1,2); H(0,2); H(1,2); H(2,2); H(3,2);\\nH(-3,3); H(-2,3); H(-1,3); H(0,3); H(1,3); H(2,3); H(3,3);\\n#else\\n#error Invalid WINDOW_SIZE\\n#endif\\nfloat response = 0.5f * (h.x + h.z - sqrt((h.x - h.z) * (h.x - h.z) + 4.0f * h.y * h.y));\\nresponse /= float(WINDOW_SIZE * WINDOW_SIZE);\\nfloat lodPlus = min(float(PYRAMID_MAX_LEVELS - 1), lod + lodStep);\\nfloat currentScaleStrength = abs(laplacian(pyramid, vec2(thread), lod));\\nfloat previousScaleStrength = abs(laplacian(pyramid, vec2(thread), lodPlus));\\nfloat previousResponse = decodeFloat16(pixel.rb);\\nvec4 result = vec4(encodeFloat16(response), encodeLod(lod), intensity);\\ncolor.rbag = (currentScaleStrength >= previousScaleStrength || previousResponse == 0.0f) ? result : pixel.rbag;\\n}\"","module.exports = \"@include \\\"keypoint-matches.glsl\\\"\\nvoid main()\\n{\\n#if ENCODE_FILTERS != 0\\nKeypointMatch initial = KeypointMatch(MATCH_MAX_INDEX, 0);\\n#else\\nKeypointMatch initial = KeypointMatch(MATCH_MAX_INDEX, MATCH_MAX_DISTANCE);\\n#endif\\ncolor = encodeKeypointMatch(initial);\\n}\"","module.exports = \"@include \\\"keypoint-matches.glsl\\\"\\nuniform sampler2D encodedMatches;\\nuniform sampler2D encodedKthMatches;\\nuniform int numberOfMatchesPerKeypoint;\\nuniform int kthMatch;\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nivec2 matcherSize = textureSize(encodedMatches, 0);\\nivec2 kthMatcherSize = textureSize(encodedKthMatches, 0);\\nint rasterIndex = thread.y * matcherSize.x + thread.x;\\nint matchIndex = rasterIndex / numberOfMatchesPerKeypoint;\\nint matchCell = rasterIndex % numberOfMatchesPerKeypoint;\\ncolor = threadPixel(encodedMatches);\\nif(matchCell != kthMatch)\\nreturn;\\ncolor = encodeKeypointMatch(MATCH_NOT_FOUND);\\nif(matchIndex >= kthMatcherSize.x * kthMatcherSize.y)\\nreturn;\\nivec2 pos = ivec2(matchIndex % kthMatcherSize.x, matchIndex / kthMatcherSize.x);\\ncolor = texelFetch(encodedKthMatches, pos, 0);\\n}\"","module.exports = \"@include \\\"pyramids.glsl\\\"\\n@include \\\"float16.glsl\\\"\\n@include \\\"filters.glsl\\\"\\nuniform sampler2D corners;\\nuniform sampler2D pyramid;\\nuniform float lodStep;\\nuniform float lodOffset;\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nvec4 pixel = threadPixel(corners);\\nfloat lod = decodeLod(pixel.a);\\nfloat lodMinus = max(0.0f, lod - lodStep + lodOffset);\\nfloat lodPlus = min(float(PYRAMID_MAX_LEVELS - 1), lod + lodStep + lodOffset);\\nfloat lapMinus = laplacian(pyramid, vec2(thread), lodMinus);\\nfloat lapPlus = abs(lodPlus - lodMinus) < 1e-5 ? lapMinus : laplacian(pyramid, vec2(thread), lodPlus);\\ncolor = encodePairOfFloat16(vec2(lapMinus, lapPlus));\\n}\"","module.exports = \"@include \\\"keypoints.glsl\\\"\\n@include \\\"float16.glsl\\\"\\nuniform sampler2D nextPyramid;\\nuniform sampler2D prevPyramid;\\nuniform sampler2D encodedFlow;\\nuniform sampler2D prevKeypoints;\\nuniform int level;\\nuniform int depth;\\nuniform int numberOfIterations;\\nuniform float discardThreshold;\\nuniform float epsilon;\\nuniform int descriptorSize;\\nuniform int extraSize;\\nuniform int encoderLength;\\n#ifndef WINDOW_SIZE\\n#error Undefined WINDOW_SIZE\\n#endif\\n#define NEXT_IMAGE 1\\n#define PREV_IMAGE 0\\nconst int WINDOW_RADIUS = (WINDOW_SIZE - 1) / 2;\\nconst int WINDOW_SIZE_SQUARED = (WINDOW_SIZE) * (WINDOW_SIZE);\\nconst int WINDOW_SIZE_PLUS = (WINDOW_SIZE) + 2;\\nconst int WINDOW_SIZE_PLUS_SQUARED = WINDOW_SIZE_PLUS * WINDOW_SIZE_PLUS;\\nconst int DBL_WINDOW_SIZE_PLUS_SQUARED = 2 * WINDOW_SIZE_PLUS_SQUARED;\\nconst int WINDOW_RADIUS_PLUS = (WINDOW_SIZE_PLUS - 1) / 2;\\nconst highp float FLT_SCALE = 9.5367431640625e-7;\\nconst highp float FLT_EPSILON = 0.00000011920929f;\\nint pixelBuffer[DBL_WINDOW_SIZE_PLUS_SQUARED];\\n#define prevPixel(index) pixelBuffer[(index)]\\n#define nextPixel(index) pixelBuffer[WINDOW_SIZE_PLUS_SQUARED + (index)]\\n#define pixelIndex(i, j) (((j) + WINDOW_RADIUS_PLUS) * WINDOW_SIZE_PLUS + ((i) + WINDOW_RADIUS_PLUS))\\nivec2 derivBuffer[WINDOW_SIZE_SQUARED];\\n#define derivativesAt(x, y) derivBuffer[((y) + WINDOW_RADIUS) * WINDOW_SIZE + ((x) + WINDOW_RADIUS)]\\nvoid readWindow(vec2 center, float lod)\\n{\\nconst int r = WINDOW_RADIUS;\\nivec2 pyrBaseSize = textureSize(prevPyramid, 0);\\nfloat pot = exp2(lod);\\nivec2 offset; int idx;\\n#define readPixelsAt(ox, oy) offset = ivec2((ox), (oy)); \\\\\\nidx = pixelIndex(offset.x, offset.y); \\\\\\nnextPixel(idx) = int(255.0f * pyrSubpixelAtExOffset(nextPyramid, center, lod, pot, offset, pyrBaseSize).g); \\\\\\nprevPixel(idx) = int(255.0f * pyrSubpixelAtExOffset(prevPyramid, center, lod, pot, offset, pyrBaseSize).g)\\nfor(int j = 0; j < WINDOW_SIZE; j++) {\\nfor(int i = 0; i < WINDOW_SIZE; i++) {\\nreadPixelsAt(i-r, j-r);\\n}\\n}\\nint r1 = r+1;\\nfor(int k = 0; k < WINDOW_SIZE; k++) {\\nreadPixelsAt(-r1, k-r);\\nreadPixelsAt( r1, k-r);\\nreadPixelsAt(k-r,-r1);\\nreadPixelsAt(k-r, r1);\\n}\\nreadPixelsAt(-r1,-r1);\\nreadPixelsAt( r1,-r1);\\nreadPixelsAt(-r1, r1);\\nreadPixelsAt( r1, r1);\\n}\\nivec2 computeDerivatives(int imageCode, ivec2 offset)\\n{\\nconst mat3 dx = mat3(\\n3, 0, -3,\\n10, 0, -10,\\n3, 0, -3\\n);\\nconst mat3 dy = mat3(\\n3, 10, 3,\\n0, 0, 0,\\n-3, -10, -3\\n);\\nint indexOffset = imageCode * WINDOW_SIZE_PLUS_SQUARED;\\nmat3 window = mat3(\\npixelBuffer[indexOffset + pixelIndex(offset.x-1, offset.y-1)],\\npixelBuffer[indexOffset + pixelIndex(offset.x+0, offset.y-1)],\\npixelBuffer[indexOffset + pixelIndex(offset.x+1, offset.y-1)],\\npixelBuffer[indexOffset + pixelIndex(offset.x-1, offset.y+0)],\\n0.0f,\\npixelBuffer[indexOffset + pixelIndex(offset.x+1, offset.y+0)],\\npixelBuffer[indexOffset + pixelIndex(offset.x-1, offset.y+1)],\\npixelBuffer[indexOffset + pixelIndex(offset.x+0, offset.y+1)],\\npixelBuffer[indexOffset + pixelIndex(offset.x+1, offset.y+1)]\\n);\\nmat3 fx = matrixCompMult(dx, window);\\nmat3 fy = matrixCompMult(dy, window);\\nconst vec3 ones = vec3(1.0f);\\nreturn ivec2(\\ndot(fx[0], ones) + dot(fx[1], ones) + dot(fx[2], ones),\\ndot(fy[0], ones) + dot(fy[1], ones) + dot(fy[2], ones)\\n);\\n}\\nint readBufferedPixel(int imageCode, ivec2 offset)\\n{\\nconst int r = WINDOW_RADIUS;\\noffset = clamp(offset, -r, r);\\nint indexOffset = imageCode * WINDOW_SIZE_PLUS_SQUARED;\\nreturn pixelBuffer[indexOffset + pixelIndex(offset.x, offset.y)];\\n}\\nint readBufferedSubpixel(int imageCode, vec2 offset)\\n{\\nivec2 p = ivec2(floor(offset));\\nvec2 frc = fract(offset);\\nvec2 ifrc = vec2(1.0f) - frc;\\nvec4 pix = vec4(\\nreadBufferedPixel(imageCode, p),\\nreadBufferedPixel(imageCode, p + ivec2(1,0)),\\nreadBufferedPixel(imageCode, p + ivec2(0,1)),\\nreadBufferedPixel(imageCode, p + ivec2(1,1))\\n);\\nvec4 sub = vec4(\\nifrc.x * ifrc.y,\\nfrc.x * ifrc.y,\\nifrc.x * frc.y,\\nfrc.x * frc.y\\n);\\nreturn int(0.5f + dot(sub*pix, vec4(1.0f)));\\n}\\nvec2 computeMismatch(vec2 pyrGuess, vec2 localGuess)\\n{\\nconst int r = WINDOW_RADIUS;\\nint timeDerivative;\\nivec2 mismatch = ivec2(0);\\nint x, y, _x, _y;\\nvec2 d = pyrGuess + localGuess;\\n#define innerLoop() \\\\\\nfor(_x = 0; _x < WINDOW_SIZE; _x++) { \\\\\\nx = _x - r; y = _y - r; \\\\\\ntimeDerivative = ( \\\\\\nreadBufferedSubpixel(NEXT_IMAGE, vec2(x, y) + d) - \\\\\\nreadBufferedPixel(PREV_IMAGE, ivec2(x, y)) \\\\\\n); \\\\\\nmismatch += derivativesAt(x, y) * timeDerivative; \\\\\\n}\\n@unroll\\nfor(_y = 0; _y < WINDOW_SIZE; _y++) {\\ninnerLoop();\\n}\\nreturn vec2(mismatch) * FLT_SCALE;\\n}\\nbool isInsideImage(vec2 position)\\n{\\nvec2 imageSize = vec2(textureSize(nextPyramid, 0));\\nvec2 border = vec2(WINDOW_SIZE);\\nreturn all(bvec4(\\ngreaterThanEqual(position, border),\\nlessThan(position, imageSize - border)\\n));\\n}\\nvoid main()\\n{\\nvec4 pixel = threadPixel(encodedFlow);\\nivec2 thread = threadLocation();\\nfloat windowArea = float(WINDOW_SIZE * WINDOW_SIZE);\\nconst int r = WINDOW_RADIUS;\\nint keypointIndex = thread.x + thread.y * outputSize().x;\\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\\nKeypointAddress address = KeypointAddress(keypointIndex * pixelsPerKeypoint, 0);\\nKeypoint keypoint = decodeKeypoint(prevKeypoints, encoderLength, address);\\ncolor = encodeNullPairOfFloat16();\\nif(isNullKeypoint(keypoint))\\nreturn;\\ncolor = encodeDiscardedPairOfFloat16();\\nif(isBadKeypoint(keypoint))\\nreturn;\\nvec2 pyrGuess = (level < depth - 1) ? decodePairOfFloat16(pixel) : vec2(0.0f);\\npyrGuess *= 2.0f;\\nreadWindow(keypoint.position, float(level));\\nivec2 derivatives;\\nivec3 harris3i = ivec3(0);\\nfor(int j = 0; j < WINDOW_SIZE; j++) {\\nfor(int i = 0; i < WINDOW_SIZE; i++) {\\nderivatives = computeDerivatives(PREV_IMAGE, ivec2(i-r, j-r));\\nharris3i += ivec3(\\nderivatives.x * derivatives.x,\\nderivatives.x * derivatives.y,\\nderivatives.y * derivatives.y\\n);\\nderivativesAt(i-r, j-r) = derivatives;\\n}\\n}\\nhighp vec3 harris = vec3(harris3i) * FLT_SCALE;\\nhighp mat2 invHarris = mat2(harris.z, -harris.y, -harris.y, harris.x);\\nhighp float det = harris.x * harris.z - harris.y * harris.y;\\nhighp float invDet = abs(det) >= FLT_EPSILON ? 1.0f / det : 0.0f;\\nhighp float minEigenvalue = 0.5f * ((harris.x + harris.z) - sqrt(\\n(harris.x - harris.z) * (harris.x - harris.z) + 4.0f * (harris.y * harris.y)\\n));\\nint niceNumbers = int(abs(det) >= FLT_EPSILON && minEigenvalue >= discardThreshold * windowArea);\\nbool goodKeypoint = (level > 0) || (niceNumbers != 0);\\nhighp float eps2 = epsilon * epsilon;\\nhighp vec2 mismatch, delta, localGuess = vec2(0.0f);\\nfor(int k = 0; k < numberOfIterations; k++) {\\nmismatch = niceNumbers != 0 ? computeMismatch(pyrGuess, localGuess) : vec2(0.0f);\\ndelta = mismatch * invHarris * invDet;\\nniceNumbers *= int(eps2 <= dot(delta, delta));\\nlocalGuess += float(niceNumbers) * delta;\\n}\\nvec2 opticalFlow = pyrGuess + localGuess;\\nbool mustDiscard = (level == 0) && any(bvec2(\\n!goodKeypoint,\\n!isInsideImage(keypoint.position + opticalFlow)\\n));\\ncolor = !mustDiscard ? encodePairOfFloat16(opticalFlow) : encodeDiscardedPairOfFloat16();\\n}\"","module.exports = \"#if @FS_USE_CUSTOM_PRECISION@\\nprecision mediump int;\\nprecision mediump float;\\n#endif\\n#if !defined(STAGE)\\n#error Undefined STAGE\\n#elif STAGE == 1\\n@include \\\"float16.glsl\\\"\\nuniform sampler2D corners;\\n#elif STAGE < 1\\nuniform mediump usampler2D lookupTable;\\n#else\\n#define SKIP_TEXTURE_READS 1\\n#define DENSITY_FACTOR 0.10\\nuniform mediump usampler2D lookupTable;\\nuniform int blockSize;\\nuniform int width;\\nuniform int height;\\nin vec2 v_topLeft, v_top, v_topRight,\\nv_left, v_center, v_right,\\nv_bottomLeft, v_bottom, v_bottomRight;\\n#endif\\nconst uvec2 NULL_ELEMENT = uvec2(0xFFFFu);\\nvoid main()\\n{\\n#if STAGE == 1\\nuvec2 outSize = uvec2(outputSize());\\nuvec2 thread = uvec2(threadLocation());\\nuvec2 size = uvec2(textureSize(corners, 0));\\nuint location = thread.y * outSize.x + thread.x;\\nivec2 pos = ivec2(location % size.x, location / size.x);\\nvec4 pixel = location < size.x * size.y ? texelFetch(corners, pos, 0) : vec4(0.0f);\\nbool isCorner = !isEncodedFloat16Zero(pixel.rb);\\ncolor = isCorner ? uvec4(uvec2(pos), 1u, 0u) : uvec4(NULL_ELEMENT, 0u, 0u);\\n#elif STAGE > 1\\nint dblBlockSize = 2 * blockSize;\\nivec2 thread = threadLocation();\\nivec2 offset = thread % dblBlockSize;\\nivec2 delta = thread - offset;\\n#if SKIP_TEXTURE_READS\\nif(blockSize >= 8) {\\nuint sb = texture(lookupTable, texCoord).z;\\nfloat p = max((float(sb) / float(blockSize)) / float(blockSize), DENSITY_FACTOR);\\nfloat rowthr = float(dblBlockSize) * p + 3.0f * sqrt(p * (1.0f - p));\\ncolor = uvec4(NULL_ELEMENT, 4u * sb, 0u);\\nif(offset.y >= max(1, int(ceil(rowthr))))\\nreturn;\\n}\\n#endif\\n#define deltaCenter ivec2(0,0)\\n#define deltaTop ivec2(0,-blockSize)\\n#define deltaTopRight ivec2(blockSize,-blockSize)\\n#define deltaRight ivec2(blockSize,0)\\n#define deltaBottomRight ivec2(blockSize,blockSize)\\n#define deltaBottom ivec2(0,blockSize)\\n#define deltaBottomLeft ivec2(-blockSize,blockSize)\\n#define deltaLeft ivec2(-blockSize,0)\\n#define deltaTopLeft ivec2(-blockSize,-blockSize)\\nivec2 boundary = ivec2(width - 1, height - 1) / blockSize;\\nivec2 bottomRightPos = thread + deltaBottomRight;\\nuvec2 valid = uvec2(\\nbottomRightPos.x < width  || bottomRightPos.x / blockSize == boundary.x,\\nbottomRightPos.y < height || bottomRightPos.y / blockSize == boundary.y\\n);\\nuvec4 mask[4] = uvec4[4](\\nuvec4(1u, valid.x, valid.y, valid.x * valid.y),\\nuvec4(1u, 1u, valid.y, valid.y),\\nuvec4(1u, valid.x, 1u, valid.x),\\nuvec4(1u)\\n);\\n#if SKIP_TEXTURE_READS\\n#define calcSb(delta) texelFetch(lookupTable, blockSize * ((thread + (delta)) / blockSize), 0).z\\nuint center = calcSb(deltaCenter);\\nuint top = calcSb(deltaTop);\\nuint topRight = calcSb(deltaTopRight);\\nuint right = calcSb(deltaRight);\\nuint bottomRight = calcSb(deltaBottomRight);\\nuint bottom = calcSb(deltaBottom);\\nuint bottomLeft = calcSb(deltaBottomLeft);\\nuint left = calcSb(deltaLeft);\\nuint topLeft = calcSb(deltaTopLeft);\\n#else\\n#define calcSb(pos) texture(lookupTable, (pos)).z\\nuint center = calcSb(v_center);\\nuint top = calcSb(v_top);\\nuint topRight = calcSb(v_topRight);\\nuint right = calcSb(v_right);\\nuint bottomRight = calcSb(v_bottomRight);\\nuint bottom = calcSb(v_bottom);\\nuint bottomLeft = calcSb(v_bottomLeft);\\nuint left = calcSb(v_left);\\nuint topLeft = calcSb(v_topLeft);\\n#endif\\nuvec4 sums[4] = uvec4[4](\\nuvec4(center, right, bottom, bottomRight),\\nuvec4(left, center, bottomLeft, bottom),\\nuvec4(top, topRight, center, right),\\nuvec4(topLeft, top, left, center)\\n);\\nivec2 cmp = ivec2(greaterThanEqual(offset, ivec2(blockSize)));\\nint option = 2 * cmp.y + cmp.x;\\nuvec4 cdef = sums[option] * mask[option];\\nuint c2b = cdef.x, d2b = cdef.y, e2b = cdef.z, f2b = cdef.w;\\nuint sb = center;\\nuint s2b = c2b + d2b + e2b + f2b;\\ns2b = s2b < sb ? 0xFFFFu : min(0xFFFFu, s2b);\\nuint w2b = uint(min(dblBlockSize, width - delta.x));\\nuvec2 uoffset = uvec2(offset);\\nuint ceiling = s2b >= uoffset.x ? (s2b - uoffset.x) / w2b + uint((s2b - uoffset.x) % w2b > 0u) : 0u;\\ncolor = uvec4(NULL_ELEMENT, s2b, 0u);\\nif(uoffset.y >= ceiling)\\nreturn;\\nuint i2b = uoffset.y * w2b + uoffset.x;\\nuint j2b = i2b >= c2b ? i2b - c2b : 0u;\\nuint k2b = j2b >= d2b ? j2b - d2b : 0u;\\nuint l2b = k2b >= e2b ? k2b - e2b : 0u;\\nuint wl = uint(min(blockSize, width - delta.x));\\nuint wr = uint(min(blockSize, width - delta.x - blockSize));\\nivec2 magicOffset = (\\n(i2b < c2b) ? ivec2(i2b % wl, i2b / wl) : (\\n(j2b < d2b) ? ivec2(j2b % wr, j2b / wr) + ivec2(blockSize, 0) : (\\n(k2b < e2b) ? ivec2(k2b % wl, k2b / wl) + ivec2(0, blockSize) : (\\n(l2b < f2b) ? ivec2(l2b % wr, l2b / wr) + ivec2(blockSize) : ivec2(0)\\n))));\\nuvec2 a2b = texelFetch(lookupTable, delta + magicOffset, 0).xy;\\ncolor = uvec4(a2b, s2b, 0u);\\n#else\\nuvec4 pix = texture(lookupTable, texCoord);\\ncolor = all(equal(pix.xy, NULL_ELEMENT)) ? vec4(0,1,1,1) : vec4(1,0,0,1);\\n#endif\\n}\"","module.exports = \"#if !defined(STAGE) || STAGE < 1\\n#error Invalid STAGE\\n#else\\nuniform mediump int blockSize;\\nout vec2 v_topLeft, v_top, v_topRight,\\nv_left, v_center, v_right,\\nv_bottomLeft, v_bottom, v_bottomRight;\\nvoid vsmain()\\n{\\nfloat b = float(blockSize);\\n#define V(x,y) (texCoord + (vec2((x),(y)) * b) / texSize)\\nv_topLeft = V(-1,-1); v_top = V(0,-1); v_topRight = V(1,-1);\\nv_left = V(-1,0); v_center = V(0,0); v_right = V(1,0);\\nv_bottomLeft = V(-1,1); v_bottom = V(0,1); v_bottomRight = V(1,1);\\n}\\n#endif\"","module.exports = \"@include \\\"keypoints.glsl\\\"\\n@include \\\"keypoint-matches.glsl\\\"\\n@include \\\"keypoint-descriptors.glsl\\\"\\nuniform sampler2D candidates;\\nuniform sampler2D filters;\\nuniform int matcherLength;\\nuniform sampler2D tables;\\nuniform sampler2D descriptorDB;\\nuniform int tableIndex;\\nuniform int bucketCapacity;\\nuniform int bucketsPerTable;\\nuniform int tablesStride;\\nuniform int descriptorDBStride;\\nuniform sampler2D encodedKeypoints;\\nuniform int descriptorSize;\\nuniform int extraSize;\\nuniform int encoderLength;\\n#if HASH_SIZE > SEQUENCE_MAXLEN\\n#error LSH: invalid HASH_SIZE\\n#elif SEQUENCE_COUNT * SEQUENCE_MAXLEN * 4 > 16384\\n#error LSH: sequences are too large!\\n#elif (SEQUENCE_COUNT * SEQUENCE_MAXLEN) % 4 > 0\\n#error LSH: sequences of invalid size!\\n#endif\\nlayout(std140) uniform LSHSequences\\n{\\nuvec4 sequences[(SEQUENCE_COUNT * SEQUENCE_MAXLEN) / 4];\\n};\\n#if HASH_SIZE == 10\\nconst int SWAP_COUNT[3] = int[3](1, 11, 56);\\nconst int[56] SWAP = int[56](0,1,2,4,8,16,32,64,128,256,512,3,5,6,9,10,12,17,18,20,24,33,34,36,40,48,65,66,68,72,80,96,129,130,132,136,144,160,192,257,258,260,264,272,288,320,384,513,514,516,520,528,544,576,640,768);\\n#elif HASH_SIZE == 11\\nconst int SWAP_COUNT[3] = int[3](1, 12, 67);\\nconst int[67] SWAP = int[67](0,1,2,4,8,16,32,64,128,256,512,1024,3,5,6,9,10,12,17,18,20,24,33,34,36,40,48,65,66,68,72,80,96,129,130,132,136,144,160,192,257,258,260,264,272,288,320,384,513,514,516,520,528,544,576,640,768,1025,1026,1028,1032,1040,1056,1088,1152,1280,1536);\\n#elif HASH_SIZE == 12\\nconst int SWAP_COUNT[3] = int[3](1, 13, 79);\\nconst int[79] SWAP = int[79](0,1,2,4,8,16,32,64,128,256,512,1024,2048,3,5,6,9,10,12,17,18,20,24,33,34,36,40,48,65,66,68,72,80,96,129,130,132,136,144,160,192,257,258,260,264,272,288,320,384,513,514,516,520,528,544,576,640,768,1025,1026,1028,1032,1040,1056,1088,1152,1280,1536,2049,2050,2052,2056,2064,2080,2112,2176,2304,2560,3072);\\n#elif HASH_SIZE == 13\\nconst int SWAP_COUNT[3] = int[3](1, 14, 92);\\nconst int[92] SWAP = int[92](0,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,3,5,6,9,10,12,17,18,20,24,33,34,36,40,48,65,66,68,72,80,96,129,130,132,136,144,160,192,257,258,260,264,272,288,320,384,513,514,516,520,528,544,576,640,768,1025,1026,1028,1032,1040,1056,1088,1152,1280,1536,2049,2050,2052,2056,2064,2080,2112,2176,2304,2560,3072,4097,4098,4100,4104,4112,4128,4160,4224,4352,4608,5120,6144);\\n#elif HASH_SIZE == 14\\nconst int SWAP_COUNT[3] = int[3](1, 15, 106);\\nconst int[106] SWAP = int[106](0,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,3,5,6,9,10,12,17,18,20,24,33,34,36,40,48,65,66,68,72,80,96,129,130,132,136,144,160,192,257,258,260,264,272,288,320,384,513,514,516,520,528,544,576,640,768,1025,1026,1028,1032,1040,1056,1088,1152,1280,1536,2049,2050,2052,2056,2064,2080,2112,2176,2304,2560,3072,4097,4098,4100,4104,4112,4128,4160,4224,4352,4608,5120,6144,8193,8194,8196,8200,8208,8224,8256,8320,8448,8704,9216,10240,12288);\\n#elif HASH_SIZE == 15\\nconst int SWAP_COUNT[3] = int[3](1, 16, 121);\\nconst int[121] SWAP = int[121](0,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,3,5,6,9,10,12,17,18,20,24,33,34,36,40,48,65,66,68,72,80,96,129,130,132,136,144,160,192,257,258,260,264,272,288,320,384,513,514,516,520,528,544,576,640,768,1025,1026,1028,1032,1040,1056,1088,1152,1280,1536,2049,2050,2052,2056,2064,2080,2112,2176,2304,2560,3072,4097,4098,4100,4104,4112,4128,4160,4224,4352,4608,5120,6144,8193,8194,8196,8200,8208,8224,8256,8320,8448,8704,9216,10240,12288,16385,16386,16388,16392,16400,16416,16448,16512,16640,16896,17408,18432,20480,24576);\\n#elif HASH_SIZE == 16\\nconst int SWAP_COUNT[3] = int[3](1, 17, 137);\\nconst int[137] SWAP = int[137](0,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,3,5,6,9,10,12,17,18,20,24,33,34,36,40,48,65,66,68,72,80,96,129,130,132,136,144,160,192,257,258,260,264,272,288,320,384,513,514,516,520,528,544,576,640,768,1025,1026,1028,1032,1040,1056,1088,1152,1280,1536,2049,2050,2052,2056,2064,2080,2112,2176,2304,2560,3072,4097,4098,4100,4104,4112,4128,4160,4224,4352,4608,5120,6144,8193,8194,8196,8200,8208,8224,8256,8320,8448,8704,9216,10240,12288,16385,16386,16388,16392,16400,16416,16448,16512,16640,16896,17408,18432,20480,24576,32769,32770,32772,32776,32784,32800,32832,32896,33024,33280,33792,34816,36864,40960,49152);\\n#elif HASH_SIZE == 17\\nconst int SWAP_COUNT[3] = int[3](1, 18, 154);\\nconst int[154] SWAP = int[154](0,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,3,5,6,9,10,12,17,18,20,24,33,34,36,40,48,65,66,68,72,80,96,129,130,132,136,144,160,192,257,258,260,264,272,288,320,384,513,514,516,520,528,544,576,640,768,1025,1026,1028,1032,1040,1056,1088,1152,1280,1536,2049,2050,2052,2056,2064,2080,2112,2176,2304,2560,3072,4097,4098,4100,4104,4112,4128,4160,4224,4352,4608,5120,6144,8193,8194,8196,8200,8208,8224,8256,8320,8448,8704,9216,10240,12288,16385,16386,16388,16392,16400,16416,16448,16512,16640,16896,17408,18432,20480,24576,32769,32770,32772,32776,32784,32800,32832,32896,33024,33280,33792,34816,36864,40960,49152,65537,65538,65540,65544,65552,65568,65600,65664,65792,66048,66560,67584,69632,73728,81920,98304);\\n#elif HASH_SIZE == 18\\nconst int SWAP_COUNT[3] = int[3](1, 19, 172);\\nconst int[172] SWAP = int[172](0,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,3,5,6,9,10,12,17,18,20,24,33,34,36,40,48,65,66,68,72,80,96,129,130,132,136,144,160,192,257,258,260,264,272,288,320,384,513,514,516,520,528,544,576,640,768,1025,1026,1028,1032,1040,1056,1088,1152,1280,1536,2049,2050,2052,2056,2064,2080,2112,2176,2304,2560,3072,4097,4098,4100,4104,4112,4128,4160,4224,4352,4608,5120,6144,8193,8194,8196,8200,8208,8224,8256,8320,8448,8704,9216,10240,12288,16385,16386,16388,16392,16400,16416,16448,16512,16640,16896,17408,18432,20480,24576,32769,32770,32772,32776,32784,32800,32832,32896,33024,33280,33792,34816,36864,40960,49152,65537,65538,65540,65544,65552,65568,65600,65664,65792,66048,66560,67584,69632,73728,81920,98304,131073,131074,131076,131080,131088,131104,131136,131200,131328,131584,132096,133120,135168,139264,147456,163840,196608);\\n#elif HASH_SIZE == 19\\nconst int SWAP_COUNT[3] = int[3](1, 20, 191);\\nconst int[191] SWAP = int[191](0,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262144,3,5,6,9,10,12,17,18,20,24,33,34,36,40,48,65,66,68,72,80,96,129,130,132,136,144,160,192,257,258,260,264,272,288,320,384,513,514,516,520,528,544,576,640,768,1025,1026,1028,1032,1040,1056,1088,1152,1280,1536,2049,2050,2052,2056,2064,2080,2112,2176,2304,2560,3072,4097,4098,4100,4104,4112,4128,4160,4224,4352,4608,5120,6144,8193,8194,8196,8200,8208,8224,8256,8320,8448,8704,9216,10240,12288,16385,16386,16388,16392,16400,16416,16448,16512,16640,16896,17408,18432,20480,24576,32769,32770,32772,32776,32784,32800,32832,32896,33024,33280,33792,34816,36864,40960,49152,65537,65538,65540,65544,65552,65568,65600,65664,65792,66048,66560,67584,69632,73728,81920,98304,131073,131074,131076,131080,131088,131104,131136,131200,131328,131584,132096,133120,135168,139264,147456,163840,196608,262145,262146,262148,262152,262160,262176,262208,262272,262400,262656,263168,264192,266240,270336,278528,294912,327680,393216);\\n#elif HASH_SIZE == 20\\nconst int SWAP_COUNT[3] = int[3](1, 21, 211);\\nconst int[211] SWAP = int[211](0,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262144,524288,3,5,6,9,10,12,17,18,20,24,33,34,36,40,48,65,66,68,72,80,96,129,130,132,136,144,160,192,257,258,260,264,272,288,320,384,513,514,516,520,528,544,576,640,768,1025,1026,1028,1032,1040,1056,1088,1152,1280,1536,2049,2050,2052,2056,2064,2080,2112,2176,2304,2560,3072,4097,4098,4100,4104,4112,4128,4160,4224,4352,4608,5120,6144,8193,8194,8196,8200,8208,8224,8256,8320,8448,8704,9216,10240,12288,16385,16386,16388,16392,16400,16416,16448,16512,16640,16896,17408,18432,20480,24576,32769,32770,32772,32776,32784,32800,32832,32896,33024,33280,33792,34816,36864,40960,49152,65537,65538,65540,65544,65552,65568,65600,65664,65792,66048,66560,67584,69632,73728,81920,98304,131073,131074,131076,131080,131088,131104,131136,131200,131328,131584,132096,133120,135168,139264,147456,163840,196608,262145,262146,262148,262152,262160,262176,262208,262272,262400,262656,263168,264192,266240,270336,278528,294912,327680,393216,524289,524290,524292,524296,524304,524320,524352,524416,524544,524800,525312,526336,528384,532480,540672,557056,589824,655360,786432);\\n#else\\n#error Invalid HASH_SIZE\\n#endif\\n#if LEVEL < 0 || LEVEL > 2\\n#error Invalid LEVEL\\n#endif\\nconst uint END_OF_LIST = 0xFFFFFFFFu;\\nconst int NUMBER_OF_HASHES = SWAP_COUNT[LEVEL];\\nuint sequenceElement(int sequenceIndex, int elementIndex)\\n{\\nint offset = (SEQUENCE_MAXLEN) * sequenceIndex + elementIndex;\\nuvec4 tuple = sequences[offset / 4];\\nreturn tuple[offset & 3];\\n}\\nint descriptorHash(uint[DESCRIPTOR_SIZE] descriptor, int sequenceIndex)\\n{\\nuint bit, b, m;\\nint hash = 0;\\n@unroll\\nfor(int i = 0; i < HASH_SIZE; i++) {\\nbit = sequenceElement(sequenceIndex, i);\\nb = bit >> 3u;\\nm = 1u << (bit & 7u);\\nhash = (hash << 1) | int((descriptor[b] & m) != 0u);\\n}\\nreturn hash;\\n}\\n#define readTableData(tables, tablesStride, rasterIndex) decodeUint32(texelFetch((tables), ivec2((rasterIndex) % (tablesStride), (rasterIndex) / (tablesStride)), 0))\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nint keypointIndex = thread.x + thread.y * matcherLength;\\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\\nKeypointAddress address = KeypointAddress(keypointIndex * pixelsPerKeypoint, 0);\\nKeypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, address);\\ncolor = encodeKeypointMatch(MATCH_NOT_FOUND);\\nif(isBadKeypoint(keypoint))\\nreturn;\\nKeypointMatch candidate = decodeKeypointMatch(threadPixel(candidates));\\nKeypointMatch mfilter = decodeKeypointMatch(threadPixel(filters));\\nuint[DESCRIPTOR_SIZE] candidateDescriptor;\\nuint[DESCRIPTOR_SIZE] descriptor = readKeypointDescriptor(encodedKeypoints, descriptorSize, extraSize, encoderLength, address);\\nint hash0 = descriptorHash(descriptor, tableIndex);\\nfor(int h = 0; h < NUMBER_OF_HASHES; h++) {\\nint hash = hash0 ^ SWAP[h];\\nint tableAddress = tableIndex * bucketsPerTable * bucketCapacity;\\nint bucketAddress = tableAddress + hash * bucketCapacity;\\nbool validEntry = true;\\nfor(int b = 0; b < bucketCapacity; b++) {\\nint entryAddress = bucketAddress + b;\\nuint entry = validEntry ? readTableData(tables, tablesStride, entryAddress) : END_OF_LIST;\\nvalidEntry = (validEntry && entry != END_OF_LIST);\\nint candidateIndex = int(entry);\\ncandidateDescriptor = readKeypointDescriptorFromDB(descriptorDB, descriptorDBStride, validEntry ? candidateIndex : -1);\\nint descriptorDistance = distanceBetweenKeypointDescriptors(descriptor, candidateDescriptor);\\nKeypointMatch match = KeypointMatch(candidateIndex, descriptorDistance);\\nbool betterThanCandidate = (match.dist < candidate.dist) || (match.dist == candidate.dist && match.index > candidate.index);\\nbool worseThanFilter = (match.dist > mfilter.dist) || (match.dist == mfilter.dist && match.index < mfilter.index);\\nbool nicerMatch = (validEntry && betterThanCandidate && worseThanFilter);\\nivec2 v = nicerMatch ? ivec2(match.index, match.dist) : ivec2(candidate.index, candidate.dist);\\ncandidate = KeypointMatch(v.x, v.y);\\n}\\n}\\ncolor = encodeKeypointMatch(candidate);\\n}\"","module.exports = \"@include \\\"keypoints.glsl\\\"\\n@include \\\"int32.glsl\\\"\\n#if !defined(STAGE)\\n#error Undefined STAGE\\n#elif STAGE == 1\\nuniform sampler2D encodedKeypointsA;\\nuniform sampler2D encodedKeypointsB;\\nuniform int encoderLengthA;\\nuniform int encoderLengthB;\\nuniform int encoderCapacityA;\\nuniform int encoderCapacityB;\\nuniform int descriptorSize;\\nuniform int extraSize;\\nuniform int encoderLength;\\n#elif STAGE == 2\\nuniform sampler2D encodedKeypoints;\\nuniform int descriptorSize;\\nuniform int extraSize;\\nuniform int encoderLength;\\nuniform int maxKeypoints;\\n#elif STAGE == 3\\nuniform sampler2D array;\\nuniform int blockSize;\\n#elif STAGE == 4\\nuniform sampler2D array;\\nuniform sampler2D encodedKeypoints;\\nuniform int descriptorSize;\\nuniform int extraSize;\\nuniform int encoderLength;\\n#elif STAGE == 5\\nuniform sampler2D array;\\n#else\\n#error Invalid STAGE\\n#endif\\n#define NULL_KEYPOINT_INDEX 0xFFFF\\nconst highp uint UNIT = 0x10000u;\\nvoid main()\\n{\\n#if STAGE == 1\\nivec2 thread = threadLocation();\\nKeypointAddress addr = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\\nint keypointIndex = findKeypointIndex(addr, descriptorSize, extraSize);\\nint newKeypointIndex = keypointIndex < encoderCapacityA ? keypointIndex : keypointIndex - encoderCapacityA;\\ncolor = encodeNullKeypoint();\\nif(newKeypointIndex >= max(encoderCapacityA, encoderCapacityB))\\nreturn;\\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\\naddr = KeypointAddress(newKeypointIndex * pixelsPerKeypoint, addr.offset);\\nvec4 dataA = readKeypointData(encodedKeypointsA, encoderLengthA, addr);\\nvec4 dataB = readKeypointData(encodedKeypointsB, encoderLengthB, addr);\\ncolor = keypointIndex < encoderCapacityA ? dataA : dataB;\\n#elif STAGE == 2\\nivec2 thread = threadLocation();\\nint keypointIndex = thread.y * outputSize().x + thread.x;\\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\\nKeypointAddress addr = KeypointAddress(keypointIndex * pixelsPerKeypoint, 0);\\nKeypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, addr);\\nbool isValid = !isNullKeypoint(keypoint) && keypointIndex < maxKeypoints;\\nkeypointIndex = isValid ? keypointIndex : NULL_KEYPOINT_INDEX;\\ncolor = encodeUint32(uint(keypointIndex & 0xFFFF) | (isValid ? UNIT : 0u));\\n#elif STAGE == 3\\nivec2 thread = threadLocation();\\nivec2 size = outputSize();\\nint arrayLength = size.x * size.y;\\nint arrayIndex = thread.y * size.x + thread.x;\\nint arrayIndexLeft = arrayIndex - blockSize;\\nint arrayIndexRight = arrayIndex + blockSize;\\nint mask = int(arrayIndexRight < arrayLength || arrayIndexRight / blockSize == (arrayLength - 1) / blockSize);\\narrayIndexLeft = max(0, arrayIndexLeft);\\narrayIndexRight = min(arrayLength - 1, arrayIndexRight);\\n#define raster2pos(k) ivec2((k) % size.x, (k) / size.x)\\nuvec3 entries32 = uvec3(\\ndecodeUint32(threadPixel(array)),\\ndecodeUint32(texelFetch(array, raster2pos(arrayIndexLeft), 0)),\\ndecodeUint32(texelFetch(array, raster2pos(arrayIndexRight), 0))\\n);\\nivec3 sb = ivec3((entries32 >> 16u) & 0xFFFFu);\\nsb.z *= mask;\\nint dblBlockSize = 2 * blockSize;\\nint offset = arrayIndex % dblBlockSize;\\nint s2b = sb.x + (offset < blockSize ? sb.z : sb.y);\\nint l2b = offset < blockSize ? sb.x : sb.y;\\nuint keypointIndex = entries32.x & 0xFFFFu;\\nuint shiftedS2b = uint(s2b) << 16u;\\ncolor = encodeUint32(uint(NULL_KEYPOINT_INDEX) | shiftedS2b);\\nif(offset >= s2b)\\nreturn;\\ncolor = encodeUint32(keypointIndex | shiftedS2b);\\nif(offset < l2b)\\nreturn;\\nvec4 entry = texelFetch(array, raster2pos(arrayIndex + blockSize - l2b), 0);\\nkeypointIndex = decodeUint32(entry) & 0xFFFFu;\\ncolor = encodeUint32(keypointIndex | shiftedS2b);\\n#elif STAGE == 4\\nivec2 thread = threadLocation();\\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\\nKeypointAddress addr = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\\nint keypointIndex = findKeypointIndex(addr, descriptorSize, extraSize);\\n#define raster2pos(k) ivec2((k) % size.x, (k) / size.x)\\nivec2 size = textureSize(array, 0);\\nuint sortedPair = decodeUint32(texelFetch(array, raster2pos(keypointIndex), 0));\\nint newKeypointIndex = int(sortedPair & 0xFFFFu);\\ncolor = encodeNullKeypoint();\\nif(newKeypointIndex == NULL_KEYPOINT_INDEX || keypointIndex >= size.x * size.y)\\nreturn;\\nKeypointAddress newAddr = KeypointAddress(newKeypointIndex * pixelsPerKeypoint, addr.offset);\\ncolor = readKeypointData(encodedKeypoints, encoderLength, newAddr);\\n#elif STAGE == 5\\nuint val = decodeUint32(threadPixel(array));\\ncolor = (val & 0xFFFFu) == uint(NULL_KEYPOINT_INDEX) ? vec4(0,1,1,1) : vec4(1,0,0,1);\\n#endif\\n}\"","module.exports = \"@include \\\"pyramids.glsl\\\"\\n@include \\\"float16.glsl\\\"\\n@include \\\"filters.glsl\\\"\\n#if !defined(USE_LAPLACIAN)\\n#error Undefined USE_LAPLACIAN\\n#endif\\nuniform sampler2D corners;\\nuniform sampler2D pyramid;\\nuniform float lodStep;\\n#if USE_LAPLACIAN\\nuniform sampler2D pyrLaplacian;\\n#endif\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nvec4 pixel = threadPixel(corners);\\nfloat score = decodeFloat16(pixel.rb);\\nfloat myEncodedLod = pixel.a;\\nfloat lod = decodeLod(myEncodedLod);\\nfloat lodPlus = lod + lodStep;\\nfloat lodMinus = lod - lodStep;\\nfloat pot = exp2(lod);\\nfloat potPlus = exp2(lodPlus);\\nfloat potMinus = exp2(lodMinus);\\ncolor = pixel;\\nif(score == 0.0f)\\nreturn;\\n#define P(p,u,v) textureLod(corners, texCoord + (p) * vec2((u),(v)) / texSize, 0.0f)\\nvec4 pix[18] = vec4[18](\\n#define D(u,v) P(potMinus,(u),(v))\\nD(-1,-1), D(0,-1), D(1,-1),\\nD(-1,0), D(0,0), D(1,0),\\nD(-1,1), D(0,1), D(1,1)\\n,\\n#define U(u,v) P(potPlus,(u),(v))\\nU(-1,-1), U(0,-1), U(1,-1),\\nU(-1,0), U(0,0), U(1,0),\\nU(-1,1), U(0,1), U(1,1)\\n);\\nfloat scores[18] = float[18](\\n#define C(j) decodeFloat16(pix[j].rb)\\nC(0), C(1), C(2),\\nC(3), C(4), C(5),\\nC(6), C(7), C(8)\\n,\\nC(9), C(10), C(11),\\nC(12), C(13), C(14),\\nC(15), C(16), C(17)\\n);\\nfloat lods[18] = float[18](\\n#define E(j) decodeLod(pix[j].a)\\nE(0), E(1), E(2),\\nE(3), E(4), E(5),\\nE(6), E(7), E(8)\\n,\\nE(9), E(10), E(11),\\nE(12), E(13), E(14),\\nE(15), E(16), E(17)\\n);\\n#if USE_LAPLACIAN\\n#define L(p,u,v) textureLod(pyrLaplacian, texCoord + (p) * vec2((u),(v)) / texSize, 0.0f)\\nmat3 strengths[2] = mat3[2](mat3(\\n#define Lm(u,v) abs(decodeFloat16(L(potMinus,(u),(v)).xy))\\nLm(-1,-1), Lm(0,-1), Lm(1,-1),\\nLm(-1,0), Lm(0,0), Lm(1,0),\\nLm(-1,1), Lm(0,1), Lm(1,1)\\n), mat3(\\n#define Lp(u,v) abs(decodeFloat16(L(potPlus,(u),(v)).zw))\\nLp(-1,-1), Lp(0,-1), Lp(1,-1),\\nLp(-1,0), Lp(0,0), Lp(1,0),\\nLp(-1,1), Lp(0,1), Lp(1,1)\\n));\\nfloat myStrength = abs(laplacian(pyramid, vec2(thread), lod));\\n#else\\n#define L(u,v) (((v)+1)*3 + ((u)+1))\\nmat3 strengths[2] = mat3[2](mat3(\\n#define Lm(u,v) scores[L((u),(v))]\\nLm(-1,-1), Lm(0,-1), Lm(1,-1),\\nLm(-1,0), Lm(0,0), Lm(1,0),\\nLm(-1,1), Lm(0,1), Lm(1,1)\\n), mat3(\\n#define Lp(u,v) scores[9 + L((u),(v))]\\nLp(-1,-1), Lp(0,-1), Lp(1,-1),\\nLp(-1,0), Lp(0,0), Lp(1,0),\\nLp(-1,1), Lp(0,1), Lp(1,1)\\n));\\nfloat myStrength = score;\\n#endif\\n#define B(j,lod) float(isSameLod(lods[j], (lod))) * float(scores[j] > 0.0f)\\nmat3 nearLod[2] = mat3[2](mat3(\\n#define Bm(j) B((j), lodMinus)\\nBm(0), Bm(1), Bm(2),\\nBm(3), Bm(4), Bm(5),\\nBm(6), Bm(7), Bm(8)\\n), mat3(\\n#define Bp(j) B((j), lodPlus)\\nBp(9), Bp(10), Bp(11),\\nBp(12), Bp(13), Bp(14),\\nBp(15), Bp(16), Bp(17)\\n));\\nmat3 upStrengths = matrixCompMult(strengths[1], nearLod[1]);\\nmat3 downStrengths = matrixCompMult(strengths[0], nearLod[0]);\\nvec3 maxUpStrength3 = max(upStrengths[0], max(upStrengths[1], upStrengths[2]));\\nvec3 maxDownStrength3 = max(downStrengths[0], max(downStrengths[1], downStrengths[2]));\\nvec3 maxStrength3 = max(maxUpStrength3, maxDownStrength3);\\nfloat maxStrength = max(maxStrength3.x, max(maxStrength3.y, maxStrength3.z));\\ncolor.rb = encodeFloat16(score * step(maxStrength, myStrength));\\n}\"","module.exports = \"@include \\\"pyramids.glsl\\\"\\n@include \\\"float16.glsl\\\"\\nuniform sampler2D corners;\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nvec4 pixel = threadPixel(corners);\\nfloat encodedLod = pixel.a;\\nfloat score = decodeFloat16(pixel.rb);\\nfloat lod = decodeLod(encodedLod);\\nfloat pot = exp2(lod);\\ncolor = pixel;\\nif(score == 0.0f)\\nreturn;\\n#if 1\\nvec2 gridSize = vec2(pot);\\nvec2 gridLocation = floor(mod(texCoord * texSize, gridSize));\\nvec2 gridDelta = gridLocation / gridSize - vec2(0.5f);\\nfloat gridStep = 1.0f / pot;\\nconst float adjustment = 1.25f;\\ncolor.rb = encodeFloat16(0.0f);\\nif(max(abs(gridDelta.x), abs(gridDelta.y)) > adjustment * gridStep)\\nreturn;\\n#endif\\n#define P(x,y) textureLod(corners, texCoord + pot * vec2((x), (y)) / texSize, 0.0f)\\nvec4 pix[9] = vec4[9](\\nP(-1,-1), P(0,-1), P(1,-1),\\nP(-1,0), pixel, P(1,0),\\nP(-1,1), P(0,1), P(1,1)\\n);\\n#define S(j) decodeFloat16(pix[j].rb)\\nmat3 scores = mat3(\\nS(0), S(1), S(2),\\nS(3), S(4), S(5),\\nS(6), S(7), S(8)\\n);\\n#define B(j) float(isSameLod(decodeLod(pix[j].a), lod))\\nmat3 sameLod = mat3(\\nB(0), B(1), B(2),\\nB(3), B(4), B(5),\\nB(6), B(7), B(8)\\n);\\nmat3 sameLodScores = matrixCompMult(scores, sameLod);\\nvec3 maxScore3 = max(sameLodScores[0], max(sameLodScores[1], sameLodScores[2]));\\nfloat maxScore = max(maxScore3.x, max(maxScore3.y, maxScore3.z));\\ncolor.rb = encodeFloat16(score * step(maxScore, score));\\n}\"","module.exports = \"@include \\\"pyramids.glsl\\\"\\n@include \\\"float16.glsl\\\"\\nuniform sampler2D image;\\nuniform float lodStep;\\n#if !defined(MULTISCALE)\\n#error Must define MULTISCALE\\n#elif MULTISCALE != 0\\n#define LOD_STEP (lodStep)\\n#define USE_MIDDLE_RING\\n#else\\n#define LOD_STEP (0.0f)\\n#endif\\n#define PIX(x,y) pixelAtShortOffset(image, ivec2((x),(y)))\\n#define L2(v,i) bvec2(isSameEncodedLod(v[i].a, alphaMinus), isSameEncodedLod(v[i].a, alphaPlus))\\n#define L3(v,i) bvec3(isSameEncodedLod(v[i].a, alpha), isSameEncodedLod(v[i].a, alphaMinus), isSameEncodedLod(v[i].a, alphaPlus))\\n#define S3(v,i) decodeFloat16(v[i].rb) * float(any(L3(v,i)))\\n#define S2(v,i) decodeFloat16(v[i].rb) * float(any(L2(v,i)))\\n#define P(i) S3(p,i)\\n#define Q(i) S2(q,i)\\n#define R(i) S2(r,i)\\nconst vec4 O = vec4(0.0f);\\nvoid main()\\n{\\nvec4 pixel = threadPixel(image);\\nfloat lod = decodeLod(pixel.a);\\nfloat score = decodeFloat16(pixel.rb);\\ncolor = pixel;\\nif(score == 0.0f)\\nreturn;\\nvec4 p[8] = vec4[8](\\nPIX(0,1), PIX(1,1), PIX(1,0), PIX(1,-1),\\nPIX(0,-1), PIX(-1,-1), PIX(-1,0), PIX(-1,1)\\n);\\n#ifdef USE_MIDDLE_RING\\nvec4 q[16] = vec4[16](\\nPIX(0,2), PIX(1,2), PIX(2,2), PIX(2,1),\\nPIX(2,0), PIX(2,-1), PIX(2,-2), PIX(1,-2),\\nPIX(0,-2), PIX(-1,-2), PIX(-2,-2), PIX(-2,-1),\\nPIX(-2,0), PIX(-2,1), PIX(-2,2), PIX(-1,2)\\n);\\n#else\\nvec4 q[16] = vec4[16](O,O,O,O,O,O,O,O,O,O,O,O,O,O,O,O);\\n#endif\\n#ifdef USE_OUTER_RING\\nvec4 r[16] = vec4[16](\\nPIX(0,3), PIX(1,3), PIX(3,1), PIX(3,0),\\nPIX(3,-1), PIX(1,-3), PIX(0,-3), PIX(-1,-3),\\nPIX(-3,-1), PIX(-3,0), PIX(-3,1), PIX(-1,3),\\nPIX(0,4), PIX(4,0), PIX(0,-4), PIX(-4,0)\\n);\\n#else\\nvec4 r[16] = vec4[16](O,O,O,O,O,O,O,O,O,O,O,O,O,O,O,O);\\n#endif\\nfloat alphaPlus = encodeLod(lod + LOD_STEP);\\nfloat alphaMinus = encodeLod(lod - LOD_STEP);\\nfloat alpha = encodeLod(lod);\\nmat3 innerScore = mat3(\\nP(0), P(1), P(2), P(3),\\nP(4), P(5), P(6), P(7),\\n0.0f);\\nmat4 middleScore = mat4(\\nQ(0), Q(1), Q(2), Q(3),\\nQ(4), Q(5), Q(6), Q(7),\\nQ(8), Q(9), Q(10), Q(11),\\nQ(12), Q(13), Q(14), Q(15)\\n);\\nmat4 outerScore = mat4(\\nR(0), R(1), R(2), R(3),\\nR(4), R(5), R(6), R(7),\\nR(8), R(9), R(10), R(11),\\nR(12), R(13), R(14), R(15)\\n);\\nvec3 maxInnerScore3 = max(innerScore[0], max(innerScore[1], innerScore[2]));\\nvec4 maxMiddleScore4 = max(max(middleScore[0], middleScore[1]), max(middleScore[2], middleScore[3]));\\nvec4 maxOuterScore4 = max(max(outerScore[0], outerScore[1]), max(outerScore[2], outerScore[3]));\\nfloat maxInnerScore = max(maxInnerScore3.x, max(maxInnerScore3.y, maxInnerScore3.z));\\nfloat maxMiddleScore = max(max(maxMiddleScore4.x, maxMiddleScore4.y), max(maxMiddleScore4.z, maxMiddleScore4.w));\\nfloat maxOuterScore = max(max(maxOuterScore4.x, maxOuterScore4.y), max(maxOuterScore4.z, maxOuterScore4.w));\\nfloat maxScore = max(maxInnerScore, max(maxMiddleScore, maxOuterScore));\\nfloat finalScore = step(maxScore, score) * score;\\ncolor.rb = encodeFloat16(finalScore);\\n}\"","module.exports = \"@include \\\"keypoints.glsl\\\"\\nuniform sampler2D encodedCorners;\\nuniform int encoderLength;\\nuniform sampler2D image;\\nuniform int extraSize;\\nconst int descriptorSize = 32;\\n#define P(a,b,c,d) ivec4((a),(b),(c),(d))\\nconst ivec4 pat31[256] = ivec4[256](\\nP(8,-3,9,5),\\nP(4,2,7,-12),\\nP(-11,9,-8,2),\\nP(7,-12,12,-13),\\nP(2,-13,2,12),\\nP(1,-7,1,6),\\nP(-2,-10,-2,-4),\\nP(-13,-13,-11,-8),\\nP(-13,-3,-12,-9),\\nP(10,4,11,9),\\nP(-13,-8,-8,-9),\\nP(-11,7,-9,12),\\nP(7,7,12,6),\\nP(-4,-5,-3,0),\\nP(-13,2,-12,-3),\\nP(-9,0,-7,5),\\nP(12,-6,12,-1),\\nP(-3,6,-2,12),\\nP(-6,-13,-4,-8),\\nP(11,-13,12,-8),\\nP(4,7,5,1),\\nP(5,-3,10,-3),\\nP(3,-7,6,12),\\nP(-8,-7,-6,-2),\\nP(-2,11,-1,-10),\\nP(-13,12,-8,10),\\nP(-7,3,-5,-3),\\nP(-4,2,-3,7),\\nP(-10,-12,-6,11),\\nP(5,-12,6,-7),\\nP(5,-6,7,-1),\\nP(1,0,4,-5),\\nP(9,11,11,-13),\\nP(4,7,4,12),\\nP(2,-1,4,4),\\nP(-4,-12,-2,7),\\nP(-8,-5,-7,-10),\\nP(4,11,9,12),\\nP(0,-8,1,-13),\\nP(-13,-2,-8,2),\\nP(-3,-2,-2,3),\\nP(-6,9,-4,-9),\\nP(8,12,10,7),\\nP(0,9,1,3),\\nP(7,-5,11,-10),\\nP(-13,-6,-11,0),\\nP(10,7,12,1),\\nP(-6,-3,-6,12),\\nP(10,-9,12,-4),\\nP(-13,8,-8,-12),\\nP(-13,0,-8,-4),\\nP(3,3,7,8),\\nP(5,7,10,-7),\\nP(-1,7,1,-12),\\nP(3,-10,5,6),\\nP(2,-4,3,-10),\\nP(-13,0,-13,5),\\nP(-13,-7,-12,12),\\nP(-13,3,-11,8),\\nP(-7,12,-4,7),\\nP(6,-10,12,8),\\nP(-9,-1,-7,-6),\\nP(-2,-5,0,12),\\nP(-12,5,-7,5),\\nP(3,-10,8,-13),\\nP(-7,-7,-4,5),\\nP(-3,-2,-1,-7),\\nP(2,9,5,-11),\\nP(-11,-13,-5,-13),\\nP(-1,6,0,-1),\\nP(5,-3,5,2),\\nP(-4,-13,-4,12),\\nP(-9,-6,-9,6),\\nP(-12,-10,-8,-4),\\nP(10,2,12,-3),\\nP(7,12,12,12),\\nP(-7,-13,-6,5),\\nP(-4,9,-3,4),\\nP(7,-1,12,2),\\nP(-7,6,-5,1),\\nP(-13,11,-12,5),\\nP(-3,7,-2,-6),\\nP(7,-8,12,-7),\\nP(-13,-7,-11,-12),\\nP(1,-3,12,12),\\nP(2,-6,3,0),\\nP(-4,3,-2,-13),\\nP(-1,-13,1,9),\\nP(7,1,8,-6),\\nP(1,-1,3,12),\\nP(9,1,12,6),\\nP(-1,-9,-1,3),\\nP(-13,-13,-10,5),\\nP(7,7,10,12),\\nP(12,-5,12,9),\\nP(6,3,7,11),\\nP(5,-13,6,10),\\nP(2,-12,2,3),\\nP(3,8,4,-6),\\nP(2,6,12,-13),\\nP(9,-12,10,3),\\nP(-8,4,-7,9),\\nP(-11,12,-4,-6),\\nP(1,12,2,-8),\\nP(6,-9,7,-4),\\nP(2,3,3,-2),\\nP(6,3,11,0),\\nP(3,-3,8,-8),\\nP(7,8,9,3),\\nP(-11,-5,-6,-4),\\nP(-10,11,-5,10),\\nP(-5,-8,-3,12),\\nP(-10,5,-9,0),\\nP(8,-1,12,-6),\\nP(4,-6,6,-11),\\nP(-10,12,-8,7),\\nP(4,-2,6,7),\\nP(-2,0,-2,12),\\nP(-5,-8,-5,2),\\nP(7,-6,10,12),\\nP(-9,-13,-8,-8),\\nP(-5,-13,-5,-2),\\nP(8,-8,9,-13),\\nP(-9,-11,-9,0),\\nP(1,-8,1,-2),\\nP(7,-4,9,1),\\nP(-2,1,-1,-4),\\nP(11,-6,12,-11),\\nP(-12,-9,-6,4),\\nP(3,7,7,12),\\nP(5,5,10,8),\\nP(0,-4,2,8),\\nP(-9,12,-5,-13),\\nP(0,7,2,12),\\nP(-1,2,1,7),\\nP(5,11,7,-9),\\nP(3,5,6,-8),\\nP(-13,-4,-8,9),\\nP(-5,9,-3,-3),\\nP(-4,-7,-3,-12),\\nP(6,5,8,0),\\nP(-7,6,-6,12),\\nP(-13,6,-5,-2),\\nP(1,-10,3,10),\\nP(4,1,8,-4),\\nP(-2,-2,2,-13),\\nP(2,-12,12,12),\\nP(-2,-13,0,-6),\\nP(4,1,9,3),\\nP(-6,-10,-3,-5),\\nP(-3,-13,-1,1),\\nP(7,5,12,-11),\\nP(4,-2,5,-7),\\nP(-13,9,-9,-5),\\nP(7,1,8,6),\\nP(7,-8,7,6),\\nP(-7,-4,-7,1),\\nP(-8,11,-7,-8),\\nP(-13,6,-12,-8),\\nP(2,4,3,9),\\nP(10,-5,12,3),\\nP(-6,-5,-6,7),\\nP(8,-3,9,-8),\\nP(2,-12,2,8),\\nP(-11,-2,-10,3),\\nP(-12,-13,-7,-9),\\nP(-11,0,-10,-5),\\nP(5,-3,11,8),\\nP(-2,-13,-1,12),\\nP(-1,-8,0,9),\\nP(-13,-11,-12,-5),\\nP(-10,-2,-10,11),\\nP(-3,9,-2,-13),\\nP(2,-3,3,2),\\nP(-9,-13,-4,0),\\nP(-4,6,-3,-10),\\nP(-4,12,-2,-7),\\nP(-6,-11,-4,9),\\nP(6,-3,6,11),\\nP(-13,11,-5,5),\\nP(11,11,12,6),\\nP(7,-5,12,-2),\\nP(-1,12,0,7),\\nP(-4,-8,-3,-2),\\nP(-7,1,-6,7),\\nP(-13,-12,-8,-13),\\nP(-7,-2,-6,-8),\\nP(-8,5,-6,-9),\\nP(-5,-1,-4,5),\\nP(-13,7,-8,10),\\nP(1,5,5,-13),\\nP(1,0,10,-13),\\nP(9,12,10,-1),\\nP(5,-8,10,-9),\\nP(-1,11,1,-13),\\nP(-9,-3,-6,2),\\nP(-1,-10,1,12),\\nP(-13,1,-8,-10),\\nP(8,-11,10,-6),\\nP(2,-13,3,-6),\\nP(7,-13,12,-9),\\nP(-10,-10,-5,-7),\\nP(-10,-8,-8,-13),\\nP(4,-6,8,5),\\nP(3,12,8,-13),\\nP(-4,2,-3,-3),\\nP(5,-13,10,-12),\\nP(4,-13,5,-1),\\nP(-9,9,-4,3),\\nP(0,3,3,-9),\\nP(-12,1,-6,1),\\nP(3,2,4,-8),\\nP(-10,-10,-10,9),\\nP(8,-13,12,12),\\nP(-8,-12,-6,-5),\\nP(2,2,3,7),\\nP(10,6,11,-8),\\nP(6,8,8,-12),\\nP(-7,10,-6,5),\\nP(-3,-9,-3,9),\\nP(-1,-13,-1,5),\\nP(-3,-7,-3,4),\\nP(-8,-2,-8,3),\\nP(4,2,12,12),\\nP(2,-5,3,11),\\nP(6,-9,11,-13),\\nP(3,-1,7,12),\\nP(11,-1,12,4),\\nP(-3,0,-3,6),\\nP(4,-11,4,12),\\nP(2,-4,2,1),\\nP(-10,-6,-8,1),\\nP(-13,7,-11,1),\\nP(-13,12,-11,-13),\\nP(6,0,11,-13),\\nP(0,-1,1,4),\\nP(-13,3,-9,-2),\\nP(-9,8,-6,-3),\\nP(-13,-6,-8,-2),\\nP(5,-9,8,10),\\nP(2,7,3,-9),\\nP(-1,-6,-1,-1),\\nP(9,5,11,-2),\\nP(11,-3,12,-8),\\nP(3,0,3,5),\\nP(-1,4,0,10),\\nP(3,-6,4,5),\\nP(-13,0,-10,5),\\nP(5,8,12,11),\\nP(8,9,9,-6),\\nP(7,-4,8,-12),\\nP(-10,4,-10,9),\\nP(7,3,12,4),\\nP(9,-7,10,-2),\\nP(7,0,12,-2),\\nP(-1,-6,0,-11)\\n);\\nvoid getPair(int index, mat2 rot, out vec2 p, out vec2 q)\\n{\\nivec4 data = pat31[index];\\nvec2 op = vec2(data.xy);\\nvec2 oq = vec2(data.zw);\\np = rot * op;\\nq = rot * oq;\\n}\\nvoid main()\\n{\\nvec4 pixel = threadPixel(encodedCorners);\\nivec2 thread = threadLocation();\\nKeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\\nint descriptorCell = address.offset - sizeofEncodedKeypoint(0, extraSize) / 4;\\ncolor = pixel;\\nif(descriptorCell < 0)\\nreturn;\\nKeypoint keypoint = decodeKeypoint(encodedCorners, encoderLength, address);\\nif(isBadKeypoint(keypoint))\\nreturn;\\nfloat degreesOrientation = round(360.0f + degrees(keypoint.orientation));\\nfloat orientation = radians(degreesOrientation - mod(degreesOrientation, 12.0f));\\nfloat kcos = cos(orientation);\\nfloat ksin = sin(orientation);\\nmat2 rot = mat2(kcos, ksin, -ksin, kcos);\\nfloat pot = exp2(keypoint.lod);\\nint patternStart = 32 * descriptorCell;\\nuint test[4] = uint[4](0u, 0u, 0u, 0u);\\nfor(int t = 0; t < 4; t++) {\\nuint bits = 0u;\\nvec2 p, q;\\nvec4 a, b;\\nint i = t * 8;\\n@unroll\\nfor(int j = 0; j < 8; j++) {\\ngetPair(patternStart + i + j, rot, p, q);\\na = texelFetch(image, ivec2(round(keypoint.position + pot * p)), 0);\\nb = texelFetch(image, ivec2(round(keypoint.position + pot * q)), 0);\\nbits |= uint(a.g < b.g) << j;\\n}\\ntest[t] = bits;\\n}\\ncolor = vec4(test[0], test[1], test[2], test[3]) / 255.0f;\\n}\"","module.exports = \"@include \\\"keypoints.glsl\\\"\\nuniform sampler2D image;\\nuniform sampler2D encodedKeypoints;\\nuniform int descriptorSize;\\nuniform int extraSize;\\nuniform int encoderLength;\\n#define P(x,y) ivec2((x),(y))\\nconst int diskPointCount[16] = int[16](0, 4, 12, 28, 48, 80, 112, 148, 196, 252, 316, 376, 440, 528, 612, 708);\\nconst ivec2 diskPoint[708] = ivec2[708](\\nP(0,-1),P(-1,0),P(1,0),P(0,1),\\nP(-1,-1),P(1,-1),P(-1,1),P(1,1),P(0,-2),P(-2,0),P(2,0),P(0,2),\\nP(-1,-2),P(1,-2),P(-2,-1),P(2,-1),P(-2,1),P(2,1),P(-1,2),P(1,2),P(-2,-2),P(2,-2),P(-2,2),P(2,2),P(0,-3),P(-3,0),P(3,0),P(0,3),\\nP(-1,-3),P(1,-3),P(-3,-1),P(3,-1),P(-3,1),P(3,1),P(-1,3),P(1,3),P(-2,-3),P(2,-3),P(-3,-2),P(3,-2),P(-3,2),P(3,2),P(-2,3),P(2,3),P(0,-4),P(-4,0),P(4,0),P(0,4),\\nP(-1,-4),P(1,-4),P(-4,-1),P(4,-1),P(-4,1),P(4,1),P(-1,4),P(1,4),P(-3,-3),P(3,-3),P(-3,3),P(3,3),P(-2,-4),P(2,-4),P(-4,-2),P(4,-2),P(-4,2),P(4,2),P(-2,4),P(2,4),P(0,-5),P(-3,-4),P(3,-4),P(-4,-3),P(4,-3),P(-5,0),P(5,0),P(-4,3),P(4,3),P(-3,4),P(3,4),P(0,5),\\nP(-1,-5),P(1,-5),P(-5,-1),P(5,-1),P(-5,1),P(5,1),P(-1,5),P(1,5),P(-2,-5),P(2,-5),P(-5,-2),P(5,-2),P(-5,2),P(5,2),P(-2,5),P(2,5),P(-4,-4),P(4,-4),P(-4,4),P(4,4),P(-3,-5),P(3,-5),P(-5,-3),P(5,-3),P(-5,3),P(5,3),P(-3,5),P(3,5),P(0,-6),P(-6,0),P(6,0),P(0,6),\\nP(-1,-6),P(1,-6),P(-6,-1),P(6,-1),P(-6,1),P(6,1),P(-1,6),P(1,6),P(-2,-6),P(2,-6),P(-6,-2),P(6,-2),P(-6,2),P(6,2),P(-2,6),P(2,6),P(-4,-5),P(4,-5),P(-5,-4),P(5,-4),P(-5,4),P(5,4),P(-4,5),P(4,5),P(-3,-6),P(3,-6),P(-6,-3),P(6,-3),P(-6,3),P(6,3),P(-3,6),P(3,6),P(0,-7),P(-7,0),P(7,0),P(0,7),\\nP(-1,-7),P(1,-7),P(-5,-5),P(5,-5),P(-7,-1),P(7,-1),P(-7,1),P(7,1),P(-5,5),P(5,5),P(-1,7),P(1,7),P(-4,-6),P(4,-6),P(-6,-4),P(6,-4),P(-6,4),P(6,4),P(-4,6),P(4,6),P(-2,-7),P(2,-7),P(-7,-2),P(7,-2),P(-7,2),P(7,2),P(-2,7),P(2,7),P(-3,-7),P(3,-7),P(-7,-3),P(7,-3),P(-7,3),P(7,3),P(-3,7),P(3,7),P(-5,-6),P(5,-6),P(-6,-5),P(6,-5),P(-6,5),P(6,5),P(-5,6),P(5,6),P(0,-8),P(-8,0),P(8,0),P(0,8),\\nP(-1,-8),P(1,-8),P(-4,-7),P(4,-7),P(-7,-4),P(7,-4),P(-8,-1),P(8,-1),P(-8,1),P(8,1),P(-7,4),P(7,4),P(-4,7),P(4,7),P(-1,8),P(1,8),P(-2,-8),P(2,-8),P(-8,-2),P(8,-2),P(-8,2),P(8,2),P(-2,8),P(2,8),P(-6,-6),P(6,-6),P(-6,6),P(6,6),P(-3,-8),P(3,-8),P(-8,-3),P(8,-3),P(-8,3),P(8,3),P(-3,8),P(3,8),P(-5,-7),P(5,-7),P(-7,-5),P(7,-5),P(-7,5),P(7,5),P(-5,7),P(5,7),P(-4,-8),P(4,-8),P(-8,-4),P(8,-4),P(-8,4),P(8,4),P(-4,8),P(4,8),P(0,-9),P(-9,0),P(9,0),P(0,9),\\nP(-1,-9),P(1,-9),P(-9,-1),P(9,-1),P(-9,1),P(9,1),P(-1,9),P(1,9),P(-2,-9),P(2,-9),P(-6,-7),P(6,-7),P(-7,-6),P(7,-6),P(-9,-2),P(9,-2),P(-9,2),P(9,2),P(-7,6),P(7,6),P(-6,7),P(6,7),P(-2,9),P(2,9),P(-5,-8),P(5,-8),P(-8,-5),P(8,-5),P(-8,5),P(8,5),P(-5,8),P(5,8),P(-3,-9),P(3,-9),P(-9,-3),P(9,-3),P(-9,3),P(9,3),P(-3,9),P(3,9),P(-4,-9),P(4,-9),P(-9,-4),P(9,-4),P(-9,4),P(9,4),P(-4,9),P(4,9),P(-7,-7),P(7,-7),P(-7,7),P(7,7),P(0,-10),P(-6,-8),P(6,-8),P(-8,-6),P(8,-6),P(-10,0),P(10,0),P(-8,6),P(8,6),P(-6,8),P(6,8),P(0,10),\\nP(-1,-10),P(1,-10),P(-10,-1),P(10,-1),P(-10,1),P(10,1),P(-1,10),P(1,10),P(-2,-10),P(2,-10),P(-10,-2),P(10,-2),P(-10,2),P(10,2),P(-2,10),P(2,10),P(-5,-9),P(5,-9),P(-9,-5),P(9,-5),P(-9,5),P(9,5),P(-5,9),P(5,9),P(-3,-10),P(3,-10),P(-10,-3),P(10,-3),P(-10,3),P(10,3),P(-3,10),P(3,10),P(-7,-8),P(7,-8),P(-8,-7),P(8,-7),P(-8,7),P(8,7),P(-7,8),P(7,8),P(-4,-10),P(4,-10),P(-10,-4),P(10,-4),P(-10,4),P(10,4),P(-4,10),P(4,10),P(-6,-9),P(6,-9),P(-9,-6),P(9,-6),P(-9,6),P(9,6),P(-6,9),P(6,9),P(0,-11),P(-11,0),P(11,0),P(0,11),\\nP(-1,-11),P(1,-11),P(-11,-1),P(11,-1),P(-11,1),P(11,1),P(-1,11),P(1,11),P(-2,-11),P(2,-11),P(-5,-10),P(5,-10),P(-10,-5),P(10,-5),P(-11,-2),P(11,-2),P(-11,2),P(11,2),P(-10,5),P(10,5),P(-5,10),P(5,10),P(-2,11),P(2,11),P(-8,-8),P(8,-8),P(-8,8),P(8,8),P(-3,-11),P(3,-11),P(-7,-9),P(7,-9),P(-9,-7),P(9,-7),P(-11,-3),P(11,-3),P(-11,3),P(11,3),P(-9,7),P(9,7),P(-7,9),P(7,9),P(-3,11),P(3,11),P(-6,-10),P(6,-10),P(-10,-6),P(10,-6),P(-10,6),P(10,6),P(-6,10),P(6,10),P(-4,-11),P(4,-11),P(-11,-4),P(11,-4),P(-11,4),P(11,4),P(-4,11),P(4,11),P(0,-12),P(-12,0),P(12,0),P(0,12),\\nP(-1,-12),P(1,-12),P(-8,-9),P(8,-9),P(-9,-8),P(9,-8),P(-12,-1),P(12,-1),P(-12,1),P(12,1),P(-9,8),P(9,8),P(-8,9),P(8,9),P(-1,12),P(1,12),P(-5,-11),P(5,-11),P(-11,-5),P(11,-5),P(-11,5),P(11,5),P(-5,11),P(5,11),P(-2,-12),P(2,-12),P(-12,-2),P(12,-2),P(-12,2),P(12,2),P(-2,12),P(2,12),P(-7,-10),P(7,-10),P(-10,-7),P(10,-7),P(-10,7),P(10,7),P(-7,10),P(7,10),P(-3,-12),P(3,-12),P(-12,-3),P(12,-3),P(-12,3),P(12,3),P(-3,12),P(3,12),P(-6,-11),P(6,-11),P(-11,-6),P(11,-6),P(-11,6),P(11,6),P(-6,11),P(6,11),P(-4,-12),P(4,-12),P(-12,-4),P(12,-4),P(-12,4),P(12,4),P(-4,12),P(4,12),P(-9,-9),P(9,-9),P(-9,9),P(9,9),P(-8,-10),P(8,-10),P(-10,-8),P(10,-8),P(-10,8),P(10,8),P(-8,10),P(8,10),P(0,-13),P(-5,-12),P(5,-12),P(-12,-5),P(12,-5),P(-13,0),P(13,0),P(-12,5),P(12,5),P(-5,12),P(5,12),P(0,13),\\nP(-1,-13),P(1,-13),P(-7,-11),P(7,-11),P(-11,-7),P(11,-7),P(-13,-1),P(13,-1),P(-13,1),P(13,1),P(-11,7),P(11,7),P(-7,11),P(7,11),P(-1,13),P(1,13),P(-2,-13),P(2,-13),P(-13,-2),P(13,-2),P(-13,2),P(13,2),P(-2,13),P(2,13),P(-3,-13),P(3,-13),P(-13,-3),P(13,-3),P(-13,3),P(13,3),P(-3,13),P(3,13),P(-6,-12),P(6,-12),P(-12,-6),P(12,-6),P(-12,6),P(12,6),P(-6,12),P(6,12),P(-9,-10),P(9,-10),P(-10,-9),P(10,-9),P(-10,9),P(10,9),P(-9,10),P(9,10),P(-4,-13),P(4,-13),P(-8,-11),P(8,-11),P(-11,-8),P(11,-8),P(-13,-4),P(13,-4),P(-13,4),P(13,4),P(-11,8),P(11,8),P(-8,11),P(8,11),P(-4,13),P(4,13),P(-7,-12),P(7,-12),P(-12,-7),P(12,-7),P(-12,7),P(12,7),P(-7,12),P(7,12),P(-5,-13),P(5,-13),P(-13,-5),P(13,-5),P(-13,5),P(13,5),P(-5,13),P(5,13),P(0,-14),P(-14,0),P(14,0),P(0,14),\\nP(-1,-14),P(1,-14),P(-14,-1),P(14,-1),P(-14,1),P(14,1),P(-1,14),P(1,14),P(-2,-14),P(2,-14),P(-10,-10),P(10,-10),P(-14,-2),P(14,-2),P(-14,2),P(14,2),P(-10,10),P(10,10),P(-2,14),P(2,14),P(-9,-11),P(9,-11),P(-11,-9),P(11,-9),P(-11,9),P(11,9),P(-9,11),P(9,11),P(-3,-14),P(3,-14),P(-6,-13),P(6,-13),P(-13,-6),P(13,-6),P(-14,-3),P(14,-3),P(-14,3),P(14,3),P(-13,6),P(13,6),P(-6,13),P(6,13),P(-3,14),P(3,14),P(-8,-12),P(8,-12),P(-12,-8),P(12,-8),P(-12,8),P(12,8),P(-8,12),P(8,12),P(-4,-14),P(4,-14),P(-14,-4),P(14,-4),P(-14,4),P(14,4),P(-4,14),P(4,14),P(-7,-13),P(7,-13),P(-13,-7),P(13,-7),P(-13,7),P(13,7),P(-7,13),P(7,13),P(-5,-14),P(5,-14),P(-10,-11),P(10,-11),P(-11,-10),P(11,-10),P(-14,-5),P(14,-5),P(-14,5),P(14,5),P(-11,10),P(11,10),P(-10,11),P(10,11),P(-5,14),P(5,14),P(0,-15),P(-9,-12),P(9,-12),P(-12,-9),P(12,-9),P(-15,0),P(15,0),P(-12,9),P(12,9),P(-9,12),P(9,12),P(0,15)\\n);\\nconst int DEFAULT_PATCH_RADIUS = 15;\\nconst int MIN_PATCH_RADIUS = 2;\\nvoid main()\\n{\\nvec4 pixel = threadPixel(encodedKeypoints);\\nivec2 thread = threadLocation();\\nint keypointIndex = thread.x + thread.y * outputSize().x;\\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\\nKeypointAddress address = KeypointAddress(keypointIndex * pixelsPerKeypoint, 0);\\nKeypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, address);\\nvec2 m = vec2(0.0f);\\nfloat pot = exp2(keypoint.lod);\\nvec2 imageSize = vec2(textureSize(image, 0));\\nint scaledRadius = int(ceil(float(DEFAULT_PATCH_RADIUS) / pot));\\nint radius = max(scaledRadius, MIN_PATCH_RADIUS);\\nint count = diskPointCount[radius];\\nfor(int j = 0; j < count; j++) {\\nvec2 offset = vec2(diskPoint[j]);\\nvec2 position = keypoint.position + round(pot * offset);\\nvec4 patchPixel = texture(image, (position + vec2(0.5f)) / imageSize);\\nm += offset * patchPixel.g;\\n}\\nfloat angle = fastAtan2(m.y, m.x);\\nfloat encodedOrientation = encodeKeypointOrientation(angle);\\ncolor = vec4(0.0f, encodedOrientation, 0.0f, 0.0f);\\n}\"","module.exports = \"@include \\\"keypoints.glsl\\\"\\n@include \\\"filters.glsl\\\"\\n#if !defined(METHOD)\\n#error Undefined METHOD\\n#endif\\nuniform sampler2D pyramid;\\nuniform float lodStep;\\nuniform sampler2D encodedKeypoints;\\nuniform int descriptorSize;\\nuniform int extraSize;\\nuniform int encoderLength;\\n#if METHOD == 1\\nuniform int threshold;\\n#endif\\nconst float eps = 1e-6;\\nfloat cornerStrength(vec2 position, float lod)\\n{\\n#if METHOD == 0\\nreturn laplacian(pyramid, position, lod);\\n#elif METHOD == 1\\nfloat pot = exp2(lod);\\nfloat t = float(clamp(threshold, 0, 255)) / 255.0f;\\n#define P(x,y) pyrPixelAtOffset(pyramid, lod, pot, ivec2((x),(y))).g\\nmat4 mp = mat4(\\nP(0,3),P(3,0),P(0,-3),P(-3,0),\\nP(1,3),P(2,2),P(3,1),P(3,-1),\\nP(2,-2),P(1,-3),P(-1,-3),P(-2,-2),\\nP(-3,-1),P(-3,1),P(-2,2),P(-1,3)\\n);\\nfloat c = P(0,0);\\nfloat ct = c + t, c_t = c - t;\\nmat4 mct = mp - mat4(ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct);\\nmat4 mc_t = mat4(c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t) - mp;\\nconst vec4 zeros = vec4(0.0f), ones = vec4(1.0f);\\nvec4 bs = max(mct[0], zeros), ds = max(mc_t[0], zeros);\\nbs += max(mct[1], zeros);     ds += max(mc_t[1], zeros);\\nbs += max(mct[2], zeros);     ds += max(mc_t[2], zeros);\\nbs += max(mct[3], zeros);     ds += max(mc_t[3], zeros);\\nreturn max(dot(bs, ones), dot(ds, ones)) / 16.0f;\\n#else\\n#error Invalid method\\n#endif\\n}\\nvoid main()\\n{\\nvec4 pixel = threadPixel(encodedKeypoints);\\nivec2 thread = threadLocation();\\nKeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\\ncolor = pixel;\\nif(address.offset != 1)\\nreturn;\\nKeypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, address);\\nif(isBadKeypoint(keypoint))\\nreturn;\\nvec3 strength = vec3(\\ncornerStrength(keypoint.position, max(0.0f, keypoint.lod - lodStep)),\\ncornerStrength(keypoint.position, keypoint.lod),\\ncornerStrength(keypoint.position, keypoint.lod + lodStep)\\n);\\nvec3 p = mat3(\\n2, -3, 1,\\n-4, 4, 0,\\n2, -1, 0\\n) * strength;\\nfloat maxStrength = max(strength.x, max(strength.y, strength.z));\\nvec3 diffStrength = abs(strength - vec3(maxStrength));\\nvec3 strengthIndicators = vec3(lessThan(diffStrength, vec3(eps)));\\nfloat maxPoint = min(1.0f, dot(vec3(0.0f, 0.5f, 1.0f), strengthIndicators));\\nbool hasMax = p.x < -eps;\\nfloat pmax = hasMax ? -0.5f * p.y / p.x : maxPoint;\\nfloat alpha = abs(pmax - 0.5f) <= 0.5f ? pmax : maxPoint;\\nfloat lodOffset = mix(-lodStep, lodStep, alpha);\\nfloat lod = keypoint.lod + lodOffset;\\ncolor.r = encodeLod(lod);\\n}\"","module.exports = \"@include \\\"float16.glsl\\\"\\nuniform sampler2D corners;\\nuniform int iterationNumber;\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nivec2 bounds = outputSize();\\nint jump = (1 << iterationNumber);\\nint clusterLength = jump << 1;\\nint clusterMask = clusterLength - 1;\\nivec2 clusterPos = ivec2(thread >> (1 + iterationNumber)) << (1 + iterationNumber);\\nivec2 next1 = clusterPos + ((thread - clusterPos + ivec2(jump, 0)) & clusterMask);\\nivec2 next2 = clusterPos + ((thread - clusterPos + ivec2(0, jump)) & clusterMask);\\nivec2 next3 = clusterPos + ((thread - clusterPos + ivec2(jump, jump)) & clusterMask);\\nvec4 p0 = threadPixel(corners);\\nvec4 p1 = texelFetch(corners, next1 % bounds, 0);\\nvec4 p2 = texelFetch(corners, next2 % bounds, 0);\\nvec4 p3 = texelFetch(corners, next3 % bounds, 0);\\nfloat s0 = decodeFloat16(p0.rb);\\nfloat s1 = decodeFloat16(p1.rb);\\nfloat s2 = decodeFloat16(p2.rb);\\nfloat s3 = decodeFloat16(p3.rb);\\nbool b0 = s0 >= s1 && s0 >= s2 && s0 >= s3;\\nbool b1 = s1 >= s0 && s1 >= s2 && s1 >= s3;\\nbool b2 = s2 >= s0 && s2 >= s1 && s2 >= s3;\\ncolor = vec4(0.0f);\\ncolor.rb = b0 ? p0.rb : (\\nb1 ? p1.rb : (\\nb2 ? p2.rb : p3.rb\\n)\\n);\\n}\"","module.exports = \"@include \\\"keypoints.glsl\\\"\\nuniform sampler2D encodedKeypoints;\\nuniform int descriptorSize;\\nuniform int extraSize;\\nuniform int encoderLength;\\n#if PERMUTATION_MAXLEN % 4 > 0 || PERMUTATION_MAXLEN * 4 > 16384\\n#error Invalid PERMUTATION_MAXLEN\\n#endif\\nlayout(std140) uniform Permutation\\n{\\nivec4 permutation[PERMUTATION_MAXLEN / 4];\\n};\\nint permutationElement(int index)\\n{\\nint base = index - (index % PERMUTATION_MAXLEN);\\nint offset = index - base;\\nivec4 tuple = permutation[offset / 4];\\nint newOffset = tuple[offset & 3];\\nreturn base + newOffset;\\n}\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\\nKeypointAddress myAddress = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\\nint myIndex = findKeypointIndex(myAddress, descriptorSize, extraSize);\\nint otherIndex = permutationElement(myIndex);\\nKeypointAddress otherAddress = KeypointAddress(otherIndex * pixelsPerKeypoint, myAddress.offset);\\nKeypoint myKeypoint = decodeKeypoint(encodedKeypoints, encoderLength, myAddress);\\nKeypoint otherKeypoint = decodeKeypoint(encodedKeypoints, encoderLength, otherAddress);\\ncolor = readKeypointData(encodedKeypoints, encoderLength, otherAddress);\\n}\"","module.exports = \"@include \\\"keypoints.glsl\\\"\\n#if !defined(STAGE)\\n#error Undefined STAGE\\n#elif STAGE == 1\\nuniform sampler2D encodedKeypoints;\\nuniform int descriptorSize;\\nuniform int extraSize;\\nuniform int encoderLength;\\n#elif STAGE == 2\\nuniform sampler2D permutation;\\nuniform int blockSize;\\nuniform int dblLog2BlockSize;\\n#elif STAGE == 3\\nuniform sampler2D permutation;\\nuniform int maxKeypoints;\\nuniform sampler2D encodedKeypoints;\\nuniform int descriptorSize;\\nuniform int extraSize;\\n#else\\n#error Invalid STAGE\\n#endif\\nstruct PermutationElement\\n{\\nint keypointIndex;\\nfloat score;\\nbool valid;\\n};\\nvec4 encodePermutationElement(PermutationElement element)\\n{\\nconst vec2 ONES = vec2(1.0f);\\nvec2 encodedScore = element.valid ? encodeFloat16(element.score) : ONES;\\nvec2 encodedIndex = vec2(element.keypointIndex & 255, (element.keypointIndex >> 8) & 255) / 255.0f;\\nreturn vec4(encodedIndex, encodedScore);\\n}\\nPermutationElement decodePermutationElement(vec4 pixel)\\n{\\nconst vec2 ONES = vec2(1.0f);\\nPermutationElement element;\\nelement.keypointIndex = int(pixel.r * 255.0f) | (int(pixel.g * 255.0f) << 8);\\nelement.valid = !all(equal(pixel.ba, ONES));\\nelement.score = element.valid ? decodeFloat16(pixel.ba) : -1.0f;\\nreturn element;\\n}\\nPermutationElement readPermutationElement(sampler2D permutation, int elementIndex, int stride, int height)\\n{\\nconst vec4 INVALID_PIXEL = vec4(1.0f);\\nivec2 pos = ivec2(elementIndex % stride, elementIndex / stride);\\nvec4 pixel = pos.y < height ? pixelAt(permutation, pos) : INVALID_PIXEL;\\nreturn decodePermutationElement(pixel);\\n}\\n#if STAGE == 2\\nPermutationElement selectKth(sampler2D permutation, int k, int la, int ra, int lb, int rb)\\n{\\nfloat scoreA, scoreB;\\nint ha, hb, ma, mb;\\nbool discard1stHalf, altb;\\nbool locked = false;\\nint tmp, result = 0;\\nint stride = outputSize().x;\\nint height = outputSize().y;\\nfor(int i = 0; i < dblLog2BlockSize; i++) {\\ntmp = (lb > rb && !locked) ? (la+k) : result;\\nresult = (la > ra && !locked) ? (lb+k) : tmp;\\nlocked = locked || (la > ra) || (lb > rb);\\nha = (ra - la + 1) / 2;\\nhb = (rb - lb + 1) / 2;\\nma = la + ha;\\nmb = lb + hb;\\nscoreA = readPermutationElement(permutation, ma, stride, height).score;\\nscoreB = readPermutationElement(permutation, mb, stride, height).score;\\ndiscard1stHalf = (k > ha + hb);\\naltb = (-scoreA < -scoreB);\\nk -= int(discard1stHalf && altb) * (ha + 1);\\nk -= int(discard1stHalf && !altb) * (hb + 1);\\nla += int(discard1stHalf && altb) * (ma + 1 - la);\\nlb += int(discard1stHalf && !altb) * (mb + 1 - lb);\\nra += int(!discard1stHalf && !altb) * (ma - 1 - ra);\\nrb += int(!discard1stHalf && altb) * (mb - 1 - rb);\\n}\\nreturn readPermutationElement(permutation, result, stride, height);\\n}\\n#endif\\nvoid main()\\n{\\n#if STAGE == 1\\nivec2 thread = threadLocation();\\nint stride = outputSize().x;\\nint keypointIndex = thread.y * stride + thread.x;\\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\\nKeypointAddress address = KeypointAddress(keypointIndex * pixelsPerKeypoint, 0);\\nKeypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, address);\\nPermutationElement element;\\nelement.keypointIndex = keypointIndex;\\nelement.score = keypoint.score;\\nelement.valid = !isBadKeypoint(keypoint);\\ncolor = encodePermutationElement(element);\\n#elif STAGE == 2\\nivec2 thread = threadLocation();\\nint stride = outputSize().x;\\nint elementIndex = thread.y * stride + thread.x;\\nint blockIndex = elementIndex / blockSize;\\nint blockOffset = elementIndex % blockSize;\\nint la = blockIndex * blockSize;\\nint lb = la + blockSize / 2;\\nint ra = lb - 1;\\nint rb = (blockIndex + 1) * blockSize - 1;\\nint k = blockOffset;\\nPermutationElement element = selectKth(permutation, k, la, ra, lb, rb);\\ncolor = encodePermutationElement(element);\\n#elif STAGE == 3\\nivec2 thread = threadLocation();\\nint newEncoderLength = outputSize().x;\\nKeypointAddress myAddress = findKeypointAddress(thread, newEncoderLength, descriptorSize, extraSize);\\nint myKeypointIndex = findKeypointIndex(myAddress, descriptorSize, extraSize);\\nivec2 psize = textureSize(permutation, 0);\\nPermutationElement element = readPermutationElement(permutation, myKeypointIndex, psize.x, psize.y);\\nint oldEncoderLength = textureSize(encodedKeypoints, 0).x;\\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\\nKeypointAddress address = KeypointAddress(element.keypointIndex * pixelsPerKeypoint, myAddress.offset);\\nvec4 keypointData = readKeypointData(encodedKeypoints, oldEncoderLength, address);\\ncolor = myKeypointIndex < maxKeypoints && element.valid ? keypointData : encodeNullKeypoint();\\n#endif\\n}\"","module.exports = \"@include \\\"keypoints.glsl\\\"\\n@include \\\"float16.glsl\\\"\\n#if !defined(METHOD)\\n#error Must define METHOD\\n#endif\\nuniform sampler2D pyramid;\\nuniform sampler2D encodedKeypoints;\\nuniform int descriptorSize;\\nuniform int extraSize;\\nuniform int encoderLength;\\nuniform int maxIterations;\\nuniform float epsilon;\\nconst int PATCH_RADIUS = 1;\\nconst int PATCH_SIZE = 2 * PATCH_RADIUS + 1;\\nconst int PATCH_SIZE_SQUARED = PATCH_SIZE * PATCH_SIZE;\\nconst int LARGE_PATCH_RADIUS = PATCH_RADIUS + 1;\\nconst int LARGE_PATCH_SIZE = 2 * LARGE_PATCH_RADIUS + 1;\\nconst int LARGE_PATCH_SIZE_SQUARED = LARGE_PATCH_SIZE * LARGE_PATCH_SIZE;\\nconst int LARGER_PATCH_RADIUS = LARGE_PATCH_RADIUS + 1;\\nconst int LARGER_PATCH_SIZE = 2 * LARGER_PATCH_RADIUS + 1;\\nconst int LARGER_PATCH_SIZE_SQUARED = LARGER_PATCH_SIZE * LARGER_PATCH_SIZE;\\nconst float EPS = 1e-5;\\nfloat smoothPixelBuffer[LARGER_PATCH_SIZE_SQUARED];\\nvec2 derivativesBuffer[LARGE_PATCH_SIZE_SQUARED];\\nfloat responseBuffer[PATCH_SIZE_SQUARED];\\n#define patchPixelAt(u,v) smoothPixelBuffer[((v) + LARGER_PATCH_RADIUS) * LARGER_PATCH_SIZE + ((u) + LARGER_PATCH_RADIUS)]\\n#define derivativesAt(u,v) derivativesBuffer[((v) + LARGE_PATCH_RADIUS) * LARGE_PATCH_SIZE + ((u) + LARGE_PATCH_RADIUS)]\\n#define responseAt(u,v) responseBuffer[((v) + PATCH_RADIUS) * PATCH_SIZE + ((u) + PATCH_RADIUS)]\\nvoid readPixels(vec2 center, float lod)\\n{\\nivec2 pyrBaseSize = textureSize(pyramid, 0);\\nfloat pot = exp2(lod);\\nint u, v;\\nfor(int j = 0; j < LARGER_PATCH_SIZE; j++) {\\nfor(int i = 0; i < LARGER_PATCH_SIZE; i++) {\\nu = i - LARGER_PATCH_RADIUS;\\nv = j - LARGER_PATCH_RADIUS;\\npatchPixelAt(u,v) = pyrSubpixelAtExOffset(pyramid, center, lod, pot, ivec2(u,v), pyrBaseSize).g;\\n}\\n}\\n}\\nvoid computeDerivatives()\\n{\\nconst mat3 dx = mat3(\\n-1, 0, 1,\\n-2, 0, 2,\\n-1, 0, 1\\n);\\nconst mat3 dy = mat3(\\n1, 2, 1,\\n0, 0, 0,\\n-1,-2,-1\\n);\\nint u, v;\\nmat3 pix, convX, convY;\\nconst vec3 ones = vec3(1.0f);\\nfor(int j = 0; j < LARGE_PATCH_SIZE; j++) {\\nfor(int i = 0; i < LARGE_PATCH_SIZE; i++) {\\nu = i - LARGE_PATCH_RADIUS;\\nv = j - LARGE_PATCH_RADIUS;\\npix = mat3(\\npatchPixelAt(u+1,v+1), patchPixelAt(u+0,v+1), patchPixelAt(u-1,v+1),\\npatchPixelAt(u+1,v+0), patchPixelAt(u+0,v+0), patchPixelAt(u-1,v+0),\\npatchPixelAt(u+1,v-1), patchPixelAt(u+0,v-1), patchPixelAt(u-1,v-1)\\n);\\nconvX = matrixCompMult(dx, pix);\\nconvY = matrixCompMult(dy, pix);\\nderivativesAt(u,v) = vec2(\\ndot(ones, vec3(\\ndot(convX[0], ones),\\ndot(convX[1], ones),\\ndot(convX[2], ones)\\n)),\\ndot(ones, vec3(\\ndot(convY[0], ones),\\ndot(convY[1], ones),\\ndot(convY[2], ones)\\n))\\n);\\n}\\n}\\n}\\nvec2 computeResponseMap()\\n{\\nfloat patchArea = float(PATCH_SIZE * PATCH_SIZE);\\nvec3 h; vec2 d, c = vec2(0.0f);\\nconst vec3 ones = vec3(1.0f);\\nfloat response, sum = 0.0f;\\nint u, v;\\n#define H(r,s) d = derivativesAt((r),(s)); h += vec3(d.x * d.x, d.x * d.y, d.y * d.y)\\nfor(int j = 0; j < PATCH_SIZE; j++) {\\nfor(int i = 0; i < PATCH_SIZE; i++) {\\nu = i - PATCH_RADIUS;\\nv = j - PATCH_RADIUS;\\nh = vec3(0.0f);\\nH(u-1,v-1); H(u+0,v-1); H(u+1,v-1);\\nH(u-1,v+0); H(u+0,v+0); H(u+1,v+0);\\nH(u-1,v+1); H(u+0,v+1); H(u+1,v+1);\\nresponse = 0.5f * (h.x + h.z - sqrt((h.x - h.z) * (h.x - h.z) + 4.0f * h.y * h.y));\\nresponse /= patchArea;\\nresponseAt(u,v) = response;\\nc += vec2(u,v) * response;\\nsum += response;\\n}\\n}\\nreturn abs(sum) > EPS ? c / sum : vec2(0.0f);\\n}\\n#if METHOD == 0\\nvec2 quadratic1d()\\n{\\nfloat a = 0.5f * (responseAt(-1,0) - 2.0f * responseAt(0,0) + responseAt(1,0));\\nfloat b = 0.5f * (responseAt(1,0) - responseAt(-1,0));\\nfloat c = responseAt(0,0);\\nfloat d = 0.5f * (responseAt(0,-1) - 2.0f * responseAt(0,0) + responseAt(0,1));\\nfloat e = 0.5f * (responseAt(0,1) - responseAt(0,-1));\\nfloat f = responseAt(0,0);\\nbool hasMax = a < -EPS && d < -EPS;\\nreturn hasMax ? -0.5f * vec2(b / a, e / d) : vec2(0.0f);\\n}\\n#endif\\n#if METHOD == 1\\nvec2 taylor2d()\\n{\\nfloat dx = (-responseAt(-1,0) + responseAt(1,0)) * 0.5f;\\nfloat dy = (-responseAt(0,-1) + responseAt(0,1)) * 0.5f;\\nfloat dxx = responseAt(-1,0) - 2.0f * responseAt(0,0) + responseAt(1,0);\\nfloat dyy = responseAt(0,-1) - 2.0f * responseAt(0,0) + responseAt(0,1);\\nfloat dxy = (responseAt(-1,-1) + responseAt(1,1) - responseAt(1,-1) - responseAt(-1,1)) * 0.25f;\\nfloat det = dxx * dyy - dxy * dxy;\\nmat2 inv = mat2(dyy, -dxy, -dxy, dxx);\\nbool hasMax = det > EPS && dxx < 0.0f;\\nreturn hasMax ? inv * vec2(dx, dy) / (-det) : vec2(0.0f);\\n}\\n#endif\\n#if METHOD == 2\\nvoid bilinearUpsample(ivec2 patchOffset, vec4 pixelsOfPatch)\\n{\\nint u, v, i, j;\\nvec2 frc, ifrc; vec4 sub;\\nconst vec4 ones = vec4(1.0f);\\nfloat s = 1.0f / float(PATCH_SIZE - 1);\\nint xoff = 2 * patchOffset.x;\\nint yoff = 2 * patchOffset.y;\\nfor(j = 0; j < PATCH_SIZE; j++) {\\nfor(i = 0; i < PATCH_SIZE; i++) {\\nu = i - PATCH_RADIUS;\\nv = j - PATCH_RADIUS;\\nfrc = vec2(i, j) * s;\\nifrc = vec2(1.0f) - frc;\\nsub = vec4(\\nifrc.x * ifrc.y,\\nfrc.x * ifrc.y,\\nifrc.x * frc.y,\\nfrc.x * frc.y\\n);\\npatchPixelAt(u+xoff,v+yoff) = dot(sub*pixelsOfPatch, ones);\\n}\\n}\\n}\\n#endif\\n#if METHOD == 3\\nvoid bicubicUpsample(ivec2 patchOffset, vec4 pixelsOfPatch, vec4 dx, vec4 dy, vec4 dxy)\\n{\\nfloat x, y, s = 1.0f / float(PATCH_SIZE - 1);\\nint u, v, i, j;\\nfloat f00 = pixelsOfPatch.x;\\nfloat f10 = pixelsOfPatch.y;\\nfloat f01 = pixelsOfPatch.z;\\nfloat f11 = pixelsOfPatch.w;\\nfloat fx00 = dx.x;\\nfloat fx10 = dx.y;\\nfloat fx01 = dx.z;\\nfloat fx11 = dx.w;\\nfloat fy00 = dy.x;\\nfloat fy10 = dy.y;\\nfloat fy01 = dy.z;\\nfloat fy11 = dy.w;\\nfloat fxy00 = dxy.x;\\nfloat fxy10 = dxy.y;\\nfloat fxy01 = dxy.z;\\nfloat fxy11 = dxy.w;\\nmat4 bicubic = mat4(\\n1, 0, -3, 2,\\n0, 0, 3, -2,\\n0, 1, -2, 1,\\n0, 0, -1, 1\\n) * mat4(\\nf00, f10, fx00, fx10,\\nf01, f11, fx01, fx11,\\nfy00, fy10, fxy00, fxy10,\\nfy01, fy11, fxy01, fxy11\\n) * mat4(\\n1, 0, 0, 0,\\n0, 0, 1, 0,\\n-3, 3, -2, -1,\\n2, -2, 1, 1\\n);\\nint xoff = 2 * patchOffset.x;\\nint yoff = 2 * patchOffset.y;\\nfor(j = 0; j < PATCH_SIZE; j++) {\\nfor(i = 0; i < PATCH_SIZE; i++) {\\nu = i - PATCH_RADIUS;\\nv = j - PATCH_RADIUS;\\nx = float(i) * s;\\ny = float(j) * s;\\npatchPixelAt(u+xoff,v+yoff) = dot(\\nvec4(1, x, x*x, x*x*x),\\nbicubic * vec4(1, y, y*y, y*y*y)\\n);\\n}\\n}\\n}\\n#endif\\n#if METHOD == 2 || METHOD == 3\\nvoid upsamplePatch(int left, int top, int right, int bottom)\\n{\\nint x, y, k;\\nvec4 ptch[9];\\nvec2 d00, d10, d01, d11;\\nfor(k = 0; k < 9; k++) {\\nx = -1 + (k % 3);\\ny = -1 + (k / 3);\\nptch[k] = vec4(\\npatchPixelAt(left+x, top+y),\\npatchPixelAt(right+x, top+y),\\npatchPixelAt(left+x, bottom+y),\\npatchPixelAt(right+x, bottom+y)\\n);\\n}\\nfor(k = 0; k < 9; k++) {\\nx = -1 + (k % 3);\\ny = -1 + (k / 3);\\n#if METHOD == 2\\nbilinearUpsample(ivec2(x, y), ptch[k]);\\n#elif METHOD == 3\\nd00 = derivativesAt(left+x, top+y);\\nd10 = derivativesAt(right+x, top+y);\\nd01 = derivativesAt(left+x, bottom+y);\\nd11 = derivativesAt(right+x, bottom+y);\\nbicubicUpsample(ivec2(x, y), ptch[k],\\nvec4(d00.x, d10.x, d01.x, d11.x),\\nvec4(d00.y, d10.y, d01.y, d11.y),\\n0.25f * vec4(\\n(patchPixelAt(left+x + 1,top+y + 1) + patchPixelAt(left+x - 1, top+y - 1)) - (patchPixelAt(left+x + 1, top+y - 1) + patchPixelAt(left+x - 1, top+y + 1)),\\n(patchPixelAt(right+x + 1,top+y + 1) + patchPixelAt(right+x - 1, top+y - 1)) - (patchPixelAt(right+x + 1, top+y - 1) + patchPixelAt(right+x - 1, top+y + 1)),\\n(patchPixelAt(left+x + 1,bottom+y + 1) + patchPixelAt(left+x - 1, bottom+y - 1)) - (patchPixelAt(left+x + 1, bottom+y - 1) + patchPixelAt(left+x - 1, bottom+y + 1)),\\n(patchPixelAt(right+x + 1,bottom+y + 1) + patchPixelAt(right+x - 1, bottom+y - 1)) - (patchPixelAt(right+x + 1, bottom+y - 1) + patchPixelAt(right+x - 1, bottom+y + 1))\\n)\\n);\\n#endif\\n}\\n}\\nvec2 upsampleResponseMap(int left, int top, int right, int bottom)\\n{\\nupsamplePatch(left, top, right, bottom);\\ncomputeDerivatives();\\nreturn computeResponseMap();\\n}\\nvec2 iterativeUpsample(vec2 initialGuess)\\n{\\nint refine = 1;\\nfloat scale = 0.5f;\\nfloat eps2 = epsilon * epsilon;\\nvec2 guess = initialGuess, localGuess = initialGuess;\\nfor(int k = 0; k < maxIterations; k++) {\\nivec4 quad = ivec4(floor(localGuess.x), floor(localGuess.y), ceil(localGuess.x), ceil(localGuess.y));\\nvec2 response = (refine != 0) ? upsampleResponseMap(quad.x, quad.y, quad.z, quad.w) : vec2(0.0f);\\nlocalGuess = response * scale;\\nguess += localGuess;\\nscale *= 0.5f;\\nrefine *= int(dot(localGuess, localGuess) >= eps2);\\n}\\nreturn guess;\\n}\\n#endif\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nint keypointIndex = thread.x + thread.y * outputSize().x;\\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\\nKeypointAddress address = KeypointAddress(keypointIndex * pixelsPerKeypoint, 0);\\nKeypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, address);\\ncolor = encodeNullPairOfFloat16();\\nif(isNullKeypoint(keypoint))\\nreturn;\\ncolor = encodeDiscardedPairOfFloat16();\\nif(isBadKeypoint(keypoint))\\nreturn;\\nreadPixels(keypoint.position, keypoint.lod);\\ncomputeDerivatives();\\nvec2 offset = computeResponseMap();\\n#if METHOD == 0\\noffset = quadratic1d();\\n#elif METHOD == 1\\noffset = taylor2d();\\n#elif METHOD == 2 || METHOD == 3\\noffset = iterativeUpsample(offset);\\n#else\\n#error Unknown METHOD\\n#endif\\nfloat pot = exp2(keypoint.lod);\\ncolor = encodePairOfFloat16(offset * pot);\\n}\"","module.exports = \"@include \\\"keypoints.glsl\\\"\\n@include \\\"float16.glsl\\\"\\nuniform sampler2D encodedFlow;\\nuniform sampler2D encodedKeypoints;\\nuniform int descriptorSize;\\nuniform int extraSize;\\nuniform int encoderLength;\\nvoid main()\\n{\\nvec4 pixel = threadPixel(encodedKeypoints);\\nivec2 thread = threadLocation();\\nint len = textureSize(encodedFlow, 0).x;\\nKeypointAddress myAddress = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\\nKeypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, myAddress);\\nint myIndex = findKeypointIndex(myAddress, descriptorSize, extraSize);\\ncolor = pixel;\\nif(isBadKeypoint(keypoint))\\nreturn;\\nivec2 location = ivec2(myIndex % len, myIndex / len);\\nvec4 encodedFlow = myIndex < len * len ? pixelAt(encodedFlow, location) : encodeDiscardedKeypoint();\\nbool discardFlow = isDiscardedPairOfFloat16(encodedFlow);\\nvec2 flow = !discardFlow ? decodePairOfFloat16(encodedFlow) : vec2(0.0f);\\nvec4 newPosition = encodeKeypointPosition(keypoint.position + flow);\\nvec4 newPixel = myAddress.offset == 0 ? newPosition : pixel;\\ncolor = !discardFlow ? newPixel : encodeDiscardedKeypoint();\\n}\"","module.exports = \"@include \\\"keypoints.glsl\\\"\\nuniform sampler2D encodedOrientations;\\nuniform sampler2D encodedKeypoints;\\nuniform int descriptorSize;\\nuniform int extraSize;\\nuniform int encoderLength;\\nvoid main()\\n{\\nvec4 pixel = threadPixel(encodedKeypoints);\\nivec2 thread = threadLocation();\\nKeypointAddress myAddress = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\\nint myIndex = findKeypointIndex(myAddress, descriptorSize, extraSize);\\nint orientationEncoderLength = textureSize(encodedOrientations, 0).x;\\nivec2 location = ivec2(myIndex % orientationEncoderLength, myIndex / orientationEncoderLength);\\nvec4 targetPixel = pixelAt(encodedOrientations, location);\\nKeypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, myAddress);\\nbool isValid = !isBadKeypoint(keypoint);\\nfloat encodedOrientation = targetPixel.g;\\ncolor = isValid && myAddress.offset == 1 ? vec4(pixel.r, encodedOrientation, pixel.ba) : pixel;\\n}\"","module.exports = \"@include \\\"keypoints.glsl\\\"\\nuniform sampler2D encodedData;\\nuniform int strideOfEncodedData;\\nuniform sampler2D encodedKeypoints;\\nuniform int descriptorSize;\\nuniform int extraSize;\\nuniform int encoderLength;\\nvec4 readEncodedData(sampler2D encodedData, int strideOfEncodedData, int elementId, int pixelsPerElement, int pixelOffset)\\n{\\nint rasterIndex = elementId * pixelsPerElement + pixelOffset;\\nivec2 pos = ivec2(rasterIndex % strideOfEncodedData, rasterIndex / strideOfEncodedData);\\nreturn texelFetch(encodedData, pos, 0);\\n}\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nKeypointAddress myAddress = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\\nint myIndex = findKeypointIndex(myAddress, descriptorSize, extraSize);\\nint headerSize = sizeofEncodedKeypointHeader();\\nint extraCell = myAddress.offset - headerSize / 4;\\nint numberOfExtraCells = extraSize / 4;\\ncolor = threadPixel(encodedKeypoints);\\nif(extraCell < 0 || extraCell >= numberOfExtraCells)\\nreturn;\\nKeypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, myAddress);\\nif(isBadKeypoint(keypoint))\\nreturn;\\ncolor = readEncodedData(encodedData, strideOfEncodedData, myIndex, numberOfExtraCells, extraCell);\\n}\"","module.exports = \"@include \\\"keypoints.glsl\\\"\\nuniform sampler2D encodedKeypoints;\\nuniform int startIndex;\\nuniform int endIndex;\\nuniform int descriptorSize;\\nuniform int extraSize;\\nuniform int encoderLength;\\n#ifndef BUFFER_SIZE\\n#error Undefined BUFFER_SIZE\\n#endif\\nlayout(std140) uniform KeypointBuffer\\n{\\nvec4 keypointBuffer[BUFFER_SIZE];\\n};\\nvoid main()\\n{\\nvec4 pixel = threadPixel(encodedKeypoints);\\nivec2 thread = threadLocation();\\nKeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\\nint index = findKeypointIndex(address, descriptorSize, extraSize);\\ncolor = pixel;\\nif(index < startIndex)\\nreturn;\\ncolor = encodeNullKeypoint();\\nif(index >= endIndex)\\nreturn;\\nvec4 data = keypointBuffer[index - startIndex];\\nswitch(address.offset) {\\ncase 0: {\\ncolor = encodeKeypointPosition(data.xy);\\nbreak;\\n}\\ncase 1: {\\nvec2 score = encodeKeypointScore(max(data.w, 0.0f));\\nfloat scale = encodeLod(data.z);\\nfloat rotation = encodeKeypointOrientation(0.0f);\\ncolor = vec4(scale, rotation, score);\\nbreak;\\n}\\ndefault: {\\ncolor = vec4(0.0f);\\nbreak;\\n}\\n}\\n}\"","module.exports = \"uniform sampler2D image;\\nvoid main()\\n{\\n#if 1\\ncolor = texture(image, texCoord);\\n#else\\nivec2 thread = threadLocation();\\nivec2 pos = min(thread * 2, textureSize(image, 0) - ivec2(1));\\ncolor = pixelAt(image, pos);\\n#endif\\n}\"","module.exports = \"uniform sampler2D image;\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nvec4 pixel = pixelAt(image, thread / 2);\\ncolor = (((thread.x + thread.y) & 1) == 0) ? pixel : vec4(0.0f, 0.0f, 0.0f, pixel.a);\\n}\"","module.exports = \"@include \\\"subpixel.glsl\\\"\\nuniform sampler2D image0;\\nuniform sampler2D image1;\\nuniform float alpha;\\nuniform float beta;\\nuniform float gamma;\\nconst vec4 BACKGROUND = vec4(0.0f);\\nvoid main()\\n{\\nivec2 location = threadLocation();\\nivec2 size0 = textureSize(image0, 0);\\nivec2 size1 = textureSize(image1, 0);\\nvec4 pix0 = all(lessThan(location, size0)) ? pixelAt(image0, location) : BACKGROUND;\\nvec4 pix1 = all(lessThan(location, size1)) ? pixelAt(image1, location) : BACKGROUND;\\nvec4 pix = clamp(alpha * pix0 + beta * pix1 + vec4(gamma), 0.0f, 1.0f);\\ncolor = vec4(pix.rgb, 1.0f);\\n}\"","module.exports = \"@include \\\"subpixel.glsl\\\"\\nuniform sampler2D image;\\nvoid main()\\n{\\nvec2 imageSize = vec2(textureSize(image, 0));\\n#if !defined(INTERPOLATION_METHOD)\\n#error Must define INTERPOLATION_METHOD\\n#elif INTERPOLATION_METHOD == 0\\nvec2 pos = texCoord * imageSize;\\ncolor = textureLod(image, (round(pos) + vec2(0.5f)) / imageSize, 0.0f);\\n#elif INTERPOLATION_METHOD == 1\\ncolor = subpixelAtBI(image, texCoord * imageSize);\\n#else\\n#error Invalid INTERPOLATION_METHOD\\n#endif\\n}\"","module.exports = \"@include \\\"subpixel.glsl\\\"\\nuniform sampler2D image;\\nuniform mat3 inverseHomography;\\nconst vec4 emptyColor = vec4(0.0f, 0.0f, 0.0f, 1.0f);\\nvec2 perspectiveWarp(mat3 homography, vec2 p)\\n{\\nvec3 q = homography * vec3(p, 1.0f);\\nreturn q.xy / q.z;\\n}\\nvoid main()\\n{\\nivec2 location = threadLocation();\\nivec2 size = outputSize();\\nconst vec2 zero = vec2(0.0f);\\nvec2 target = perspectiveWarp(inverseHomography, vec2(location));\\nbool withinBounds = all(bvec4(greaterThanEqual(target, zero), lessThan(target, vec2(size))));\\ncolor = withinBounds ? subpixelAtBI(image, target) : emptyColor;\\n}\"","module.exports = \"@include \\\"colors.glsl\\\"\\nuniform sampler2D dest, src;\\nuniform int destComponents;\\nuniform int srcComponentId;\\nvoid main()\\n{\\nvec4 destPixel = threadPixel(dest);\\nvec4 srcPixel = threadPixel(src);\\nbvec4 flags = bvec4(\\n(destComponents & PIXELCOMPONENT_RED) != 0,\\n(destComponents & PIXELCOMPONENT_GREEN) != 0,\\n(destComponents & PIXELCOMPONENT_BLUE) != 0,\\n(destComponents & PIXELCOMPONENT_ALPHA) != 0\\n);\\ncolor = mix(destPixel, vec4(srcPixel[srcComponentId]), flags);\\n}\"","module.exports = \"#if !defined(TYPE)\\n#error Undefined TYPE\\n#elif TYPE == 1\\n@include \\\"keypoints.glsl\\\"\\n#define nullPixel() encodeNullKeypoint()\\n#elif TYPE == 2\\n@include \\\"float16.glsl\\\"\\n#define nullPixel() encodeNullPairOfFloat16()\\n#else\\n#error Invalid TYPE\\n#endif\\nuniform sampler2D image;\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nivec2 imageSize = textureSize(image, 0);\\nint rasterIndex = thread.y * outputSize().x + thread.x;\\nbool isValidPixel = rasterIndex < imageSize.x * imageSize.y;\\nivec2 pos = ivec2(rasterIndex % imageSize.x, rasterIndex / imageSize.x);\\nvec4 nullpix = nullPixel();\\ncolor = isValidPixel ? texelFetch(image, pos, 0) : nullpix;\\n}\"","module.exports = \"uniform sampler2D image;\\nvoid main()\\n{\\ncolor = threadPixel(image);\\n}\"","module.exports = \"@include \\\"colors.glsl\\\"\\nuniform sampler2D image;\\nuniform int pixelComponents;\\nuniform float value;\\nvoid main()\\n{\\nvec4 pixel = threadPixel(image);\\nbvec4 flags = bvec4(\\n(pixelComponents & PIXELCOMPONENT_RED) != 0,\\n(pixelComponents & PIXELCOMPONENT_GREEN) != 0,\\n(pixelComponents & PIXELCOMPONENT_BLUE) != 0,\\n(pixelComponents & PIXELCOMPONENT_ALPHA) != 0\\n);\\ncolor = mix(pixel, vec4(value), flags);\\n}\"","module.exports = \"uniform float value;\\nvoid main()\\n{\\ncolor = vec4(value);\\n}\"","module.exports = \"void vsmain()\\n{\\ngl_Position *= vec4(1,-1,1,1);\\n}\"","module.exports = \"uniform sampler2D image;\\nuniform int iterationNumber;\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nivec2 last = outputSize() - ivec2(1);\\nint jump = (1 << iterationNumber);\\nint clusterLength = jump << 1;\\nint clusterMask = clusterLength - 1;\\nivec2 clusterPos = ivec2(thread >> (1 + iterationNumber)) << (1 + iterationNumber);\\nivec2 next1 = clusterPos + ((thread - clusterPos + ivec2(jump, 0)) & clusterMask);\\nivec2 next2 = clusterPos + ((thread - clusterPos + ivec2(0, jump)) & clusterMask);\\nivec2 next3 = clusterPos + ((thread - clusterPos + ivec2(jump, jump)) & clusterMask);\\nvec4 p0 = texelFetch(image, thread, 0);\\nvec4 p1 = texelFetch(image, min(next1, last), 0);\\nvec4 p2 = texelFetch(image, min(next2, last), 0);\\nvec4 p3 = texelFetch(image, min(next3, last), 0);\\nvec4 pmax = max(max(p0, p1), max(p2, p3));\\nvec4 pmin = min(min(p0, p1), min(p2, p3));\\ncolor = vec4(pmax.r, pmin.g, pmax.r - pmin.g, p0.a);\\n}\"","module.exports = \"@include \\\"pyramids.glsl\\\"\\n@include \\\"float16.glsl\\\"\\nuniform sampler2D pyramid;\\nuniform float lod;\\n#define USE_VARYINGS 1\\nin vec2 v_pix0, v_pix1, v_pix2,\\nv_pix3, v_pix4, v_pix5,\\nv_pix6, v_pix7, v_pix8;\\nconst mat3 hkern = mat3(\\n1.0f, 0.0f,-1.0f,\\n2.0f, 0.0f,-2.0f,\\n1.0f, 0.0f,-1.0f\\n), vkern = mat3(\\n1.0f, 2.0f, 1.0f,\\n0.0f, 0.0f, 0.0f,\\n-1.0f,-2.0f,-1.0f\\n);\\n#define PIX(x,y) pyrPixelAtOffset(pyramid, lod, pot, ivec2((x),(y))).g\\n#define XIP(v) textureLod(pyramid, (v), lod).g\\nvoid main()\\n{\\nconst vec3 ones = vec3(1.0f);\\nfloat pot = exp2(lod);\\nmat3 win = mat3(\\n#if USE_VARYINGS\\nXIP(v_pix0), XIP(v_pix1), XIP(v_pix2),\\nXIP(v_pix3), XIP(v_pix4), XIP(v_pix5),\\nXIP(v_pix6), XIP(v_pix7), XIP(v_pix8)\\n#else\\nPIX(-1,-1), PIX(0,-1), PIX(1,-1),\\nPIX(-1,0), PIX(0,0), PIX(1,0),\\nPIX(-1,1), PIX(0,1), PIX(1,1)\\n#endif\\n);\\nmat3 dx = matrixCompMult(hkern, win);\\nmat3 dy = matrixCompMult(vkern, win);\\nvec2 df = vec2(\\ndot(dx[0] + dx[1] + dx[2], ones),\\ndot(dy[0] + dy[1] + dy[2], ones)\\n);\\ncolor = encodePairOfFloat16(df);\\n}\"","module.exports = \"uniform mediump float lod;\\nout vec2 v_pix0, v_pix1, v_pix2,\\nv_pix3, v_pix4, v_pix5,\\nv_pix6, v_pix7, v_pix8;\\n#define PIX(x,y) (texCoord + ((pot) * vec2((x),(y))) / texSize)\\nvoid vsmain()\\n{\\nfloat pot = exp2(lod);\\nv_pix0 = PIX(-1,-1); v_pix1 = PIX(0,-1); v_pix2 = PIX(1,-1);\\nv_pix3 = PIX(-1,0); v_pix4 = PIX(0,0); v_pix5 = PIX(1,0);\\nv_pix6 = PIX(-1,1); v_pix7 = PIX(0,1); v_pix8 = PIX(1,1);\\n}\"","module.exports = `AGFzbQEAAAABiwETYAABfmADf39/AX9gAX8AYAN/f38AYAF9AX9gAX8Bf2ACf38Bf2AFf39/f38B\nf2AFf39/f38AYAZ/f39/f38Bf2AAAX9gAn99AX9gA39/fQF/YAJ/fwF9YAF/AX1gBH9/f38AYAR/\nf39/AX9gEX98fHx8fHx8fHx8fHx8fHx8AGAHf39/f39/fQF/AjsEA2VudgZtZW1vcnkCAAIDZW52\nBWZhdGFsAAIDZW52CGJ5dGVmaWxsAAMDZW52CmNvcHlXaXRoaW4AAwNAPwQFBgIGAQECBwgGAwAJ\nAgYCBgYKBQUFCQsFBgEBDAEBBgYGAQEMAQ0OAwgPAxAIAwYBEQEBAQEBARIBEgEBDwQFAXABBQUG\nCAF/AUHwmgQLB/QDHAZtYWxsb2MABARmcmVlAAYFc3JhbmQACgxNYXQzMl9jcmVhdGUAEA1NYXQz\nMl9kZXN0cm95ABcKTWF0MzJfZGF0YQAYDk1hdDMyX2RhdGFTaXplABkPTWF0MzJfdHJhbnNwb3Nl\nAB0JTWF0MzJfYWRkAB4OTWF0MzJfc3VidHJhY3QAHwtNYXQzMl9zY2FsZQAgDk1hdDMyX2NvbXBt\ndWx0ACEOTWF0MzJfbXVsdGlwbHkAIg5NYXQzMl9pbnZlcnNlMQAjDk1hdDMyX2ludmVyc2UyACQO\nTWF0MzJfaW52ZXJzZTMAJQ1NYXQzMl9xcl9mdWxsACwQTWF0MzJfcXJfcmVkdWNlZAAvDE1hdDMy\nX3FyX29scwAwEE1hdDMyX3FyX2ludmVyc2UAMxZNYXQzMl9ob21vZ3JhcGh5X25kbHQ0ADcVTWF0\nMzJfaG9tb2dyYXBoeV9uZGx0ADgUTWF0MzJfYWZmaW5lX2RpcmVjdDMAOhNNYXQzMl9hZmZpbmVf\nZGlyZWN0ADsYTWF0MzJfcHJhbnNhY19ob21vZ3JhcGh5ADwUTWF0MzJfcHJhbnNhY19hZmZpbmUA\nPhtNYXQzMl90cmFuc2Zvcm1fcGVyc3BlY3RpdmUAPxZNYXQzMl90cmFuc2Zvcm1fYWZmaW5lAEAJ\nCgEAQQELBA8REz0Kh7oBPyMBAX8gALwiAUGAgID8B3FBgICA/AdGIAFB////A3FBAEdxC2kBAX9B\nAEEAKALAmoCAAEEBajYCwJqAgABBAEEAKAK0moCAACIBQQdxIAFqIgEgAGo2ArSagIAAAkBB8JqE\n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\noZlEje21oPfGsD5jDQAgHCAFoiIYIB8gA6KhIiIgFCAIoiAcIAaiIh6gIiOiIB4gHyAEoqEiHiAU\nIAeiIBigIhiioSIkmUSN7bWg98awPmMNACAcmiIlIBShIiYgIqIgHyAcoSIiIBiioUQAAAAAAADw\nPyAkoyIkoiEYICIgI6IgJiAeoqEgJKIhHgJAAkAgHSAgZEEBcw0AIBMgGCAEoiAeIAOiRAAAAAAA\nAPA/oKAiBKIgJaMhHSAcIR8MAQsgEyAYIAaiIB4gBaJEAAAAAAAA8D+goCIEoiAfmqMhHQsgFyAE\noiAfoyETAkACQCAhICWZZEEBcw0AIBogGCAGoiAeIAWiRAAAAAAAAPA/oKAiBKIgFJqjIQcMAQsg\nGiAYIAiiIB4gB6JEAAAAAAAA8D+goCIEoiAcoyEHICUhFAsgGCAdmiABoiATIAKioSIXIAeioiAd\nIBsgBKIgFKMiFKIgHiATIAeaIAGiIBQgAqKhIhyioqCgIBMgB6KhIBggHSAcoqKhIB4gFyAUoqKh\nmUSN7bWg98awPmMNACALIA2hIhsgECAOoSIaoiAWIA8gDaEiH6KhIiCZRI3ttaD3xrA+Yw0AIBEh\nBCARIQIgESEGIBEhDiARIQEgESEDIBEhBSARIQggGyAVIBmgIhWiIBYgCSALoSANIA+hoCIZoqFE\nAAAAAAAA8D8gIKMiFqIiDSAMIAqhIBogGaIgHyAVoqEgFqIiFiAMoqAiDCAJoqIgCyAJoSAWIAui\noCILIBIgDSAQoqAiEKIgFiAPIAmhIA0gD6KgIg8gCqKioKAgDyAMoqEgDSALIAqioqEgFiAQIAmi\noqGZRI3ttaD3xrA+Yw0BIBYgF6IgDSAcoqBEAAAAAAAA8D+gIQUgGCAWIBOiIA0gFKKgoCEDIB4g\nFiAdoiANIAeioKAhASAMIBeiIBAgHKKgIAqgIQ4gGCAKoiAMIBOiIBAgFKKgoCEGIB4gCqIgDCAd\noiAQIAeioKAhAiALIBeiIA8gHKKgIAmgIQQgGCAJoiALIBOiIA8gFKKgoCERIB4gCaIgCyAdoiAP\nIAeioKAhCAwBCyARIQQgESECIBEhBiARIQ4gESEBIBEhAyARIQUgESEICyAAKAIAIicgCLY4AgAg\nJyAAQRRqKAIAIihBAnRqIBG2OAIAICcgKEEDdGogBLY4AgAgJyAAKAIQIgBBAnRqIAK2OAIAICcg\nACAoaiIpQQJ0aiAGtjgCACAnIAAgKEEBdGpBAnRqIA62OAIAICcgAEEDdGogAbY4AgAgJyAoIABB\nAXRqQQJ0aiADtjgCACAnIClBA3RqIAW2OAIAC7oHAhZ/Cn0CQAJAIAAoAghBA0cNACAAKAIMQQNH\nDQAgASgCCEECRw0AIAEoAgwiA0EESA0AIAIoAghBAkcNACACKAIMIANGDQELQbKTgIAAEICAgIAA\nIAEoAgwhAwsgA0EBdCIEQQgQkoCAgAAhBSAEQQEQkoCAgAAhBkEIQQEQkoCAgAAhBwJAIANBAUgN\nACAFQRRqKAIAIgRBDGwgBSgCECIIQQJ0IglqIQogBEEEdCAJaiELIARBFGwgCWohDCAEQRhsIg0g\nCWohDiAEQRxsIg8gCWohECACKAIQQQJ0IREgASgCEEECdCESIAhBA3QhCCAGKAIQIglBA3QhEyAJ\nQQJ0IRQgAkEUaigCAEECdCEVIAFBFGooAgBBAnQhFiAEQQN0IRcgBEECdCEYIAYoAgAhCSAFKAIA\nIQQgAigCACECIAEoAgAhAQNAIAIgEWoqAgAhGSABIBJqKgIAIRogAioCACEbIAQgASoCACIcOAIA\nIAQgGGogGjgCACAEIBdqQYCAgPwDNgIAIAQgCmogHDgCACAEIAtqIBo4AgAgBCAMakGAgID8AzYC\nACAEIA1qIBsgHIwiHJQ4AgAgBCAOaiAZIByUOAIAIAQgD2ogGyAajCIalDgCACAEIBBqIBkgGpQ4\nAgAgCSAbOAIAIAkgFGogGTgCACACIBVqIQIgASAWaiEBIAQgCGohBCAJIBNqIQkgA0F/aiIDDQAL\nCyAHIAUgBkEDELCAgIAAGgJAAkAgBygCACIEKgIAIhkgBCAHKAIQIglBBHRqKgIAIhqUIAQgCUEC\ndGoqAgAiGyAEIAlBFGxqKgIAIhyUIAQgCUEYbGoqAgAiHZSSIAQgCUEDdGoqAgAiHiAEIAlBDGxq\nKgIAIh+UIAQgCUEcbGoqAgAiIJSSIBsgH5STIBkgHJQgIJSTIB4gGpQgHZSTIiEQg4CAgAANAEMA\nAIA/ISIgIYu7RI3ttaD3xrA+Y0EBcw0BC0EAKgKAiICAACIZIRsgGSEeIBkhHyAZIRogGSEcIBkh\nHSAZISAgGSEiCyAAKAIAIgQgGTgCACAEIABBFGooAgAiCUECdGogGzgCACAEIAlBA3RqIB44AgAg\nBCAAKAIQIgJBAnRqIB84AgAgBCACIAlqIgFBAnRqIBo4AgAgBCACIAlBAXRqQQJ0aiAcOAIAIAQg\nAkEDdGogHTgCACAEIAkgAkEBdGpBAnRqICA4AgAgBCABQQN0aiAiOAIAIAcQl4CAgAAaIAYQl4CA\ngAAaIAUQl4CAgAAaIAALnwgKAX8BfQF/An0Bfwp9AX8BfQN/AX0CQAJAIAAoAghBA0cNACAAKAIM\nQQNHDQAgASgCCEECRw0AIAEoAgxBBEcNACACKAIIQQJHDQAgAigCDEEERg0BC0HZk4CAABCAgICA\nAAsgACABKAIAIgMqAgAiBCAEIAMgAUEUaigCACIFQQJ0aioCACIGkiADIAVBA3RqKgIAIgeSIAMg\nBUEDbCIIQQJ0aioCACIJkkMAAIA+lCIKkyIEQwAAAEEgAyAIIAEoAhAiAWpBAnRqKgIAIgsgCyAD\nIAFBAnRqKgIAIgwgAyAFIAFqQQJ0aioCACINkiADIAVBAXQgAWpBAnRqKgIAIg6SkkMAAIA+lCIP\nkyILIAuUIAkgCpMiCSAJlCAOIA+TIg4gDpQgByAKkyIHIAeUIA0gD5MiDSANlCAGIAqTIgYgBpQg\nBCAElCAMIA+TIgwgDJSSkpKSkpKSlZEiBJS7IAwgBJS7IAYgBJS7IA0gBJS7IAcgBJS7IA4gBJS7\nIAkgBJS7IAsgBJS7IAIoAgAiAyoCACILIAsgAyACQRRqKAIAIgVBAnRqKgIAIhCSIAMgBUEDdGoq\nAgAiDJIgAyAFQQNsIghBAnRqKgIAIg2SQwAAgD6UIgmTIgtDAAAAQSADIAggAigCECIBakECdGoq\nAgAiDiAOIAMgAUECdGoqAgAiESADIAUgAWpBAnRqKgIAIhKSIAMgBUEBdCABakECdGoqAgAiBpKS\nQwAAgD6UIg6TIgcgB5QgDSAJkyINIA2UIAYgDpMiBiAGlCAMIAmTIgwgDJQgEiAOkyISIBKUIBAg\nCZMiECAQlCALIAuUIBEgDpMiESARlJKSkpKSkpKVkSILlLsgESALlLsgECALlLsgEiALlLsgDCAL\nlLsgBiALlLsgDSALlLsgByALlLsQtYCAgAAgACgCACIDIABBFGooAgAiBUEBdCICIAAoAhAiAUEB\ndCIIakECdGoqAgAhECADIAggBWpBAnRqIggqAgAhByADIAIgAWpBAnRqIgIqAgAhESADIAVBA3Rq\nIhMqAgAhFCADIAUgAWoiFUECdGoiFioCACEGIAMgBUECdGoiBSoCACEMIAMgAUECdGoiFyoCACES\nIAMgBCAJIAMgAUEDdGoiASoCACINlCADKgIAIhhDAACAPyALlSILlJKUOAIAIBcgBCAOIA2UIBIg\nC5SSlDgCACABIAQgDZQ4AgAgBSAEIAkgB5QgDCALlJKUOAIAIBYgBCAOIAeUIAYgC5SSlDgCACAI\nIAQgB5Q4AgAgEyAUIAQgCiAYlCAPIAyUkpSTIAuUIAkgECAEIAogDZQgDyAHlJKUkyIHlJI4AgAg\nAiARIAQgCiASlCAPIAaUkpSTIAuUIA4gB5SSOAIAIAMgFUEDdGogBzgCACAAC5sCAQZ/AkACQCAA\nKAIIQQNHDQAgACgCDEEDRw0AIAEoAghBAkcNACABKAIMIgNBBEgNACACKAIIQQJHDQAgAigCDCAD\nRg0BC0GAlICAABCAgICAACABKAIMIQMLQQIgAxCSgICAACEEQQIgAxCSgICAACEFQQNBAxCSgICA\nACEGQQNBAxCSgICAACEHQQNBAxCSgICAACEIIAQgASAGQQNBAxCSgICAACIDEMGAgIAAIAUgAiAD\nIAcQwYCAgAAgAyAIIAQgBRC2gICAACIBIAYQp4CAgAAaIAAgByADEKeAgIAAGiADEJeAgIAAGiAB\nEJeAgIAAGiAHEJeAgIAAGiAGEJeAgIAAGiAFEJeAgIAAGiAEEJeAgIAAGiAAC/kFAhZ/Bn0CQAJA\nIAAoAghBAkcNACAAKAIMQQNHDQAgASgCCEECRw0AIAEoAgwiA0EDSA0AIAIoAghBAkcNACACKAIM\nIANGDQELQaeUgIAAEICAgIAAIAEoAgwhAwsgA0EBdCIEQQYQkoCAgAAhBSAEQQEQkoCAgAAhBkEG\nQQEQkoCAgAAhBwJAIANBAUgNACAFQRRqKAIAIgRBDGwgBSgCECIIQQJ0IglqIQogBEEEdCAJaiEL\nIARBFGwgCWohDCACKAIQQQJ0IQ0gASgCEEECdCEOIAhBA3QhDyAGKAIQIglBA3QhECAJQQJ0IREg\nAkEUaigCAEECdCESIAFBFGooAgBBAnQhEyAEQQN0IRQgBEECdCEVIAYoAgAhCSAFKAIAIQQgAigC\nACECIAEoAgAhAQNAIAIgDWooAgAhFiABIA5qKAIAIQggAigCACEXIAQgASgCACIYNgIAIAQgFWog\nCDYCACAEIBRqQYCAgPwDNgIAIAQgCmogGDYCACAEIAtqIAg2AgAgBCAMakGAgID8AzYCACAJIBc2\nAgAgCSARaiAWNgIAIAIgEmohAiABIBNqIQEgBCAPaiEEIAkgEGohCSADQX9qIgMNAAsLIAcgBSAG\nQQMQsICAgAAaAkACQCAHKAIAIgQqAgAiGSAEIAcoAhAiCUECdGoqAgAiGpIgBCAJQQN0aioCACIb\nkiAEIAlBDGxqKgIAIhySIAQgCUEEdGoqAgAiHZIgBCAJQRRsaioCACIekhCDgICAAA0AIBkgHZQg\nGiAclJOLu0SN7bWg98awPmNBAXMNAQtBACoCgIiAgAAiGSEaIBkhGyAZIRwgGSEdIBkhHgsgACgC\nACIEIBk4AgAgBCAAQRRqKAIAIglBAnRqIBo4AgAgBCAJQQN0aiAbOAIAIAQgACgCECICQQJ0aiAc\nOAIAIAQgAiAJakECdGogHTgCACAEIAIgCUEBdGpBAnRqIB44AgAgBxCXgICAABogBhCXgICAABog\nBRCXgICAABogAAvNBQMBfAJ/FXwCQAJAIAAoAghBAkcNACAAKAIMQQNHDQAgASgCCEECRw0AIAEo\nAgxBA0cNACACKAIIQQJHDQAgAigCDEEDRg0BC0HKlICAABCAgICAAAtBACoCgIiAgAC7IQMCQAJA\nIAEoAgAiBCABKAIQIgVBAnRqKgIAuyIGIAQgAUEUaigCACIBIAVqQQJ0aioCALsiB6EiCCAEIAFB\nA3RqKgIAuyIJoiAHIAQgAUEBdCAFakECdGoqAgC7IgqhIgsgBCoCALsiDKIgCiAGoSINIAQgAUEC\ndGoqAgC7Ig6ioKAiD5lEje21oPfGsD5jDQAgAigCACIEIAIoAhAiBUECdGoqAgC7IhAgBCACQRRq\nKAIAIgEgBWpBAnRqKgIAuyIRoSAEIAFBA3RqKgIAuyISoiARIAQgAUEBdCAFakECdGoqAgC7IhOh\nIAQqAgC7IhSiIBMgEKEgBCABQQJ0aioCALsiFaKgoJlEje21oPfGsD5jDQBEAAAAAAAA8D8gD6Mi\nFiALIBSiIA0gFaKgIAggEqKgoiIPIBYgCSAOoSIXIBCiIAwgCaEiGCARoqAgDiAMoSIZIBOioKIi\nGqIgFiAXIBSiIBggFaKgIBkgEqKgoiIXIBYgCyAQoiANIBGioCAIIBOioKIiCKKhmUSN7bWg98aw\nPmNBAXNFDQAgFiAOIAqiIAcgCaKhIgMgEKIgBiAJoiAMIAqioSIKIBGioCAMIAeiIAYgDqKhIgcg\nE6KgoiEGIBYgAyAUoiAKIBWioCAHIBKioKIhAwwBCyADIQ8gAyEXIAMhCCADIRogAyEGCyAAKAIA\nIgQgD7Y4AgAgBCAAQRRqKAIAIgFBAnRqIBe2OAIAIAQgAUEDdGogA7Y4AgAgBCAAKAIQIgVBAnRq\nIAi2OAIAIAQgBSABakECdGogGrY4AgAgBCAFIAFBAXRqQQJ0aiAGtjgCACAAC4EDAQl/AkACQCAA\nKAIIQQJHDQAgACgCDEEDRw0AIAEoAghBAkcNACABKAIMIgNBA0gNACACKAIIQQJHDQAgAigCDCAD\nRg0BC0HtlICAABCAgICAACABKAIMIQMLQQIgAxCSgICAACEEQQIgAxCSgICAACEFQQNBAxCSgICA\nACEGQQNBAxCSgICAACEHQQNBAxCUgICAACEIEJaAgIAAIAhBAEEBQQBBAhCagICAACEJQQNBAxCS\ngICAACEDQQNBAxCSgICAACEKEJaAgIAAIApBAEEBQQBBAhCagICAACELIAQgASAGIAMQwYCAgAAg\nBSACIAMgBxDBgICAACAJIAQgBRC5gICAACEBIAMgCCAGEKeAgIAAGiAKIAcgAxCngICAABogACAL\nEJWAgIAAGiALEJeAgIAAGiAKEJeAgIAAGiADEJeAgIAAGiABEJeAgIAAGiAIEJeAgIAAGiAHEJeA\ngIAAGiAGEJeAgIAAGiAFEJeAgIAAGiAEEJeAgIAAGiAAC5kUAhx/DX0jgICAgABBEGsiBySAgICA\nAAJAAkAgACgCCEEDRw0AIAAoAgxBA0cNACACKAIIQQJHDQAgAigCDCIIQQRIDQAgAygCCEECRw0A\nIAMoAgwgCEcNAAJAIAFFDQAgASgCCEEBRw0BIAEoAgwgCEcNAQsgBEEBSA0AIAVBAUgNACAGQwAA\nAABgDQELQZCVgIAAEICAgIAAIAIoAgwhCAsCQCABRQ0AIAFDAAAAABCbgICAABoLIAhBAnQiCUGy\nlYCAABCFgICAACEKIAlB0ZWAgAAQhYCAgAAgCBCNgICAACILIAhBBBCOgICAACAIIARBAnQiDCAI\nb2sgDGoiDUECdEHwlYCAABCFgICAACEOAkAgDUEBSA0AQQAhDyAIQQFIIRAgDiERA0ACQCAQDQBB\n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\nNgIACwv2EgMAQYAIC7ISAAD4f091dCBvZiBtZW1vcnkhAERvdWJsZSBmcmVlAEFzc2VydGlvbiBm\nYWlsZWQgYXQgbWF0MzIuYzo2MQBPdXQgb2YgbWVtb3J5IGF0IG1hdDMyLmM6NjMAQXNzZXJ0aW9u\nIGZhaWxlZCBhdCBtYXQzMi5jOjg0AE91dCBvZiBtZW1vcnkgYXQgbWF0MzIuYzo4NgBPdXQgb2Yg\nbWVtb3J5IGF0IG1hdDMyLmM6ODkAT3V0IG9mIG1lbW9yeSBhdCBtYXQzMi5jOjEzNgAAAGANAAAB\nAAAAAAAAAAAAAAABAAAAAQAAAAIAAABEb3VibGUgZnJlZSBhdCBtYXQzMi5jOjE0OQBBc3NlcnRp\nb24gZmFpbGVkIGF0IG1hdDMyLmM6MTg0AEFzc2VydGlvbiBmYWlsZWQgYXQgbWF0MzIuYzoxODgA\nQXNzZXJ0aW9uIGZhaWxlZCBhdCBtYXQzMi5jOjI3NQBEb3VibGUgZnJlZSBhdCBtYXQzMi5jOjI5\nAEFzc2VydGlvbiBmYWlsZWQgYXQgYXJpdGhtZXRpYzMyLmM6MzYAQXNzZXJ0aW9uIGZhaWxlZCBh\ndCBhcml0aG1ldGljMzIuYzo1OABBc3NlcnRpb24gZmFpbGVkIGF0IGFyaXRobWV0aWMzMi5jOjgw\nAEFzc2VydGlvbiBmYWlsZWQgYXQgYXJpdGhtZXRpYzMyLmM6OTkAQXNzZXJ0aW9uIGZhaWxlZCBh\ndCBhcml0aG1ldGljMzIuYzoxMjEAQXNzZXJ0aW9uIGZhaWxlZCBhdCBhcml0aG1ldGljMzIuYzox\nNDMAQXNzZXJ0aW9uIGZhaWxlZCBhdCBhcml0aG1ldGljMzIuYzoxNjgAQXNzZXJ0aW9uIGZhaWxl\nZCBhdCBhcml0aG1ldGljMzIuYzoxODkAQXNzZXJ0aW9uIGZhaWxlZCBhdCBhcml0aG1ldGljMzIu\nYzoyMTgAQXNzZXJ0aW9uIGZhaWxlZCBhdCBhcml0aG1ldGljMzIuYzoyNzEAQXNzZXJ0aW9uIGZh\naWxlZCBhdCBhcml0aG1ldGljMzIuYzozMjIAQXNzZXJ0aW9uIGZhaWxlZCBhdCBhcml0aG1ldGlj\nMzIuYzozNTYAQXNzZXJ0aW9uIGZhaWxlZCBhdCBhcml0aG1ldGljMzIuYzozNzgAQXNzZXJ0aW9u\nIGZhaWxlZCBhdCBhcml0aG1ldGljMzIuYzo0MjAAQXNzZXJ0aW9uIGZhaWxlZCBhdCBhcml0aG1l\ndGljMzIuYzo0MzYAQXNzZXJ0aW9uIGZhaWxlZCBhdCBxcjMyLmM6MjYxAEFzc2VydGlvbiBmYWls\nZWQgYXQgcXIzMi5jOjI2NQBBc3NlcnRpb24gZmFpbGVkIGF0IHFyMzIuYzoyODYAQXNzZXJ0aW9u\nIGZhaWxlZCBhdCBxcjMyLmM6MjkwAEFzc2VydGlvbiBmYWlsZWQgYXQgcXIzMi5jOjMyMQBBc3Nl\ncnRpb24gZmFpbGVkIGF0IHFyMzIuYzozMjUAQXNzZXJ0aW9uIGZhaWxlZCBhdCBxcjMyLmM6Mzc5\nAE91dCBvZiBtZW1vcnkgYXQgcXIzMi5jOjM2AEFzc2VydGlvbiBmYWlsZWQgYXQgcXIzMi5jOjY5\nAEFzc2VydGlvbiBmYWlsZWQgYXQgcXIzMi5jOjczAEFzc2VydGlvbiBmYWlsZWQgYXQgcXIzMi5j\nOjE4NABEb3VibGUgZnJlZSBhdCBxcjMyLmM6NTUAQXNzZXJ0aW9uIGZhaWxlZCBhdCBxcjMyLmM6\nMTQ4AEFzc2VydGlvbiBmYWlsZWQgYXQgcXIzMi5jOjIyNABBc3NlcnRpb24gZmFpbGVkIGF0IHFy\nMzIuYzoyMjgAQXNzZXJ0aW9uIGZhaWxlZCBhdCBob21vZ3JhcGh5MzIuYzoyNDQAQXNzZXJ0aW9u\nIGZhaWxlZCBhdCBob21vZ3JhcGh5MzIuYzoyODAAQXNzZXJ0aW9uIGZhaWxlZCBhdCBob21vZ3Jh\ncGh5MzIuYzozNTkAQXNzZXJ0aW9uIGZhaWxlZCBhdCBob21vZ3JhcGh5MzIuYzo0NDQAQXNzZXJ0\naW9uIGZhaWxlZCBhdCBhZmZpbmUzMi5jOjExOQBBc3NlcnRpb24gZmFpbGVkIGF0IGFmZmluZTMy\nLmM6MTk2AEFzc2VydGlvbiBmYWlsZWQgYXQgYWZmaW5lMzIuYzoyMjkAQXNzZXJ0aW9uIGZhaWxl\nZCBhdCByYW5zYWMzMi5jOjcxAE91dCBvZiBtZW1vcnkgYXQgcmFuc2FjMzIuYzo4NABPdXQgb2Yg\nbWVtb3J5IGF0IHJhbnNhYzMyLmM6ODgAT3V0IG9mIG1lbW9yeSBhdCByYW5zYWMzMi5jOjkzAE91\ndCBvZiBtZW1vcnkgYXQgcmFuc2FjMzIuYzoxMDcARG91YmxlIGZyZWUgYXQgcmFuc2FjMzIuYzoy\nMzYARG91YmxlIGZyZWUgYXQgcmFuc2FjMzIuYzoyNDMARG91YmxlIGZyZWUgYXQgcmFuc2FjMzIu\nYzoyNDYARG91YmxlIGZyZWUgYXQgcmFuc2FjMzIuYzoyNDkAQXNzZXJ0aW9uIGZhaWxlZCBhdCBy\nYW5zYWMzMi5jOjI3NQBPdXQgb2YgbWVtb3J5IGF0IHJhbnNhYzMyLmM6Mjg4AE91dCBvZiBtZW1v\ncnkgYXQgcmFuc2FjMzIuYzoyOTIAT3V0IG9mIG1lbW9yeSBhdCByYW5zYWMzMi5jOjI5NwBPdXQg\nb2YgbWVtb3J5IGF0IHJhbnNhYzMyLmM6MzExAERvdWJsZSBmcmVlIGF0IHJhbnNhYzMyLmM6NDM2\nAERvdWJsZSBmcmVlIGF0IHJhbnNhYzMyLmM6NDQzAERvdWJsZSBmcmVlIGF0IHJhbnNhYzMyLmM6\nNDQ2AERvdWJsZSBmcmVlIGF0IHJhbnNhYzMyLmM6NDQ5AEFzc2VydGlvbiBmYWlsZWQgYXQgdHJh\nbnNmb3JtMzIuYzozOQBBc3NlcnRpb24gZmFpbGVkIGF0IHRyYW5zZm9ybTMyLmM6NzcAQXNzZXJ0\naW9uIGZhaWxlZCBhdCB0cmFuc2Zvcm0zMi5jOjExNAAAQbQaCwwIAAAAUA0AAAEAAAAAQcAaCyQA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\n`","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * main.js\n * The entry point of the library\n */\n\nimport { SpeedyGL } from './gpu/speedy-gl';\nimport { SpeedyMedia } from './core/speedy-media';\nimport { FPSCounter } from './utils/fps-counter';\nimport { SpeedyVector2 } from './core/speedy-vector';\nimport { SpeedyPoint2 } from './core/speedy-point';\nimport { SpeedySize } from './core/speedy-size';\nimport { SpeedyMatrixFactory } from './core/speedy-matrix-factory';\nimport { SpeedyPromise } from './utils/speedy-promise';\nimport { SpeedyPipeline } from './core/pipeline/pipeline';\nimport { SpeedyPipelineImageFactory } from './core/pipeline/factories/image-factory';\nimport { SpeedyPipelineFilterFactory } from './core/pipeline/factories/filter-factory';\nimport { SpeedyPipelineTransformFactory } from './core/pipeline/factories/transform-factory';\nimport { SpeedyPipelineKeypointFactory } from './core/pipeline/factories/keypoint-factory';\nimport { SpeedyPipelineVector2Factory } from './core/pipeline/factories/vector2-factory';\nimport { Utils } from './utils/utils';\nimport { LITTLE_ENDIAN } from './utils/globals';\n\n/* eslint-disable no-undef */\n/** @typedef {import('./core/speedy-matrix').SpeedyMatrix} SpeedyMatrix */\n/** @typedef {import('./core/speedy-matrix-expr').SpeedyMatrixExpr} SpeedyMatrixExpr */\n/** @typedef {import('./core/speedy-media').SpeedyMediaOptions} SpeedyMediaOptions */\n/** @typedef {import('./core/speedy-media-source').SpeedyMediaSourceNativeElement} SpeedyMediaSourceNativeElement */\n/** @typedef {import('./gpu/speedy-gl').SpeedyPowerPreference} SpeedyPowerPreference */\n\n\n// Constants\n\n/** @type {SpeedyMatrixFactory} */\nconst matrixFactory = new SpeedyMatrixFactory();\n\n/** @type {SpeedyPipelineVector2Factory} */\nconst vector2Factory = new SpeedyPipelineVector2Factory();\n\n\n\n/**\n * GPU-accelerated Computer Vision for JavaScript\n */\nexport default class Speedy\n{\n    /**\n     * Loads a SpeedyMedia object based on the provided source element\n     * @param {SpeedyMediaSourceNativeElement} sourceElement The source media\n     * @param {SpeedyMediaOptions} [options] Additional options for advanced configuration\n     * @returns {SpeedyPromise<SpeedyMedia>}\n     */\n    static load(sourceElement, options = {})\n    {\n        return SpeedyMedia.load(sourceElement, options);\n    }\n\n    /**\n     * Loads a camera stream\n     * @param {number | MediaStreamConstraints} [widthOrConstraints] width of the stream or contraints object\n     * @param {number} [height] height of the stream\n     * @returns {SpeedyPromise<SpeedyMedia>}\n     */\n    static camera(widthOrConstraints = 640, height = 360)\n    {\n        const constraints = (typeof(widthOrConstraints) === 'object') ? widthOrConstraints : ({\n            audio: false,\n            video: {\n                width: widthOrConstraints | 0,\n                height: height | 0,\n            },\n        });\n\n        return Utils.requestCameraStream(constraints).then(\n            video => SpeedyMedia.load(video)\n        );\n    }\n\n    /**\n     * Checks if Speedy can be executed in this machine & browser\n     * @returns {boolean} true if Speedy can be executed in this machine & browser\n     */\n    static isSupported()\n    {\n        return (\n            (typeof WebAssembly !== 'undefined') &&\n            (typeof WebGL2RenderingContext !== 'undefined') &&\n            (SpeedyGL.instance.gl != null)\n        );\n    }\n\n    /**\n     * Create a 2D vector\n     * @returns {SpeedyPipelineVector2Factory & ((x: number, y: number) => SpeedyVector2)}\n     */\n    static get Vector2()\n    {\n        return vector2Factory;\n    }\n\n    /**\n     * Create a 2D point\n     * @param {number} x\n     * @param {number} y\n     * @returns {SpeedyPoint2}\n     */\n    static Point2(x, y)\n    {\n        return new SpeedyPoint2(x, y);\n    }\n\n    /**\n     * Create a new size object\n     * @param {number} width\n     * @param {number} height\n     * @returns {SpeedySize}\n     */\n    static Size(width, height)\n    {\n        return new SpeedySize(width, height);\n    }\n\n    /**\n     * Create a Matrix (entries are given in column-major format)\n     * @returns {SpeedyMatrixFactory & ((rows: number, columns: number, entries: number[]) => SpeedyMatrix) & ((expr: SpeedyMatrixExpr) => SpeedyMatrix)}\n     */\n    static get Matrix()\n    {\n        return matrixFactory;\n    }\n\n    /**\n     * Speedy Promises\n     * @returns {typeof SpeedyPromise}\n     */\n    static get Promise()\n    {\n        return SpeedyPromise;\n    }\n\n    /**\n     * Create a new Pipeline\n     * @returns {SpeedyPipeline}\n     */\n    static Pipeline()\n    {\n        return new SpeedyPipeline();\n    }\n\n    /**\n     * Image-related nodes\n     * @returns {typeof SpeedyPipelineImageFactory}\n     */\n    static get Image()\n    {\n        return SpeedyPipelineImageFactory;\n    }\n\n    /**\n     * Image filters\n     * @returns {typeof SpeedyPipelineFilterFactory}\n     */\n    static get Filter()\n    {\n        return SpeedyPipelineFilterFactory;\n    }\n\n    /**\n     * Image transforms\n     * @returns {typeof SpeedyPipelineTransformFactory}\n     */\n    static get Transform()\n    {\n        return SpeedyPipelineTransformFactory;\n    }\n\n    /**\n     * Keypoint-related nodes\n     * @returns {typeof SpeedyPipelineKeypointFactory}\n     */\n    static get Keypoint()\n    {\n        return SpeedyPipelineKeypointFactory;\n    }\n\n    /**\n     * The version of the library\n     * @returns {string} The version of the library\n     */\n    static get version()\n    {\n        if(__SPEEDY_DEVELOPMENT_MODE__)\n            return __SPEEDY_VERSION__ + '-dev';\n        else\n            return __SPEEDY_VERSION__;\n    }\n\n    /**\n     * The FPS rate\n     * @returns {number} Frames per second (FPS)\n     */\n    static get fps()\n    {\n        return FPSCounter.instance.fps;\n    }\n\n    /**\n     * Power preference for the WebGL context\n     * @returns {SpeedyPowerPreference}\n     */\n    static get powerPreference()\n    {\n        return SpeedyGL.powerPreference;\n    }\n\n    /**\n     * Power preference for the WebGL context\n     * @param {SpeedyPowerPreference} value\n     */\n    static set powerPreference(value)\n    {\n        SpeedyGL.powerPreference = value;\n    }\n}\n\n// Notice\nUtils.log(\n    `Speedy Vision v${Speedy.version}. ` +\n    `GPU-accelerated Computer Vision for JavaScript by Alexandre Martins. ` +\n    __SPEEDY_WEBSITE__\n);\n\n// Big-endian machine? Currently untested.\nif(!LITTLE_ENDIAN)\n    Utils.warning('Running on a big-endian machine');\n"],"names":[],"sourceRoot":""}